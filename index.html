<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,height=device-height,initial-scale=1,viewport-fit=cover,user-scalable=no" />
<title>TafelCapture ‚Äì Fixbuild</title>
<style>
  :root{ color-scheme: dark; --bg:#0b0e13; --fg:#e9eef5; --muted:#a7b3c0; --accent:#4ea1ff; --ok:#11c46a; --warn:#ffb020; --bad:#ff4d6d; --bar:#0f131acc; --bar-border:#1a212c; }
  html,body{margin:0;padding:0;background:var(--bg);color:var(--fg);font-family:system-ui,Segoe UI,Roboto,Ubuntu,sans-serif;height:100%;overflow:hidden}
  #app{display:grid;grid-template-rows:auto 1fr auto auto;height:100svh;width:100vw}
  header{display:flex;flex-wrap:wrap;gap:.5rem;align-items:center;padding:.5rem .75rem;background:#0f131a;border-bottom:1px solid var(--bar-border)}
  header .group{display:flex;gap:.5rem;align-items:center;flex-wrap:wrap}
  button,select,label.chip{background:#16202c;color:var(--fg);border:1px solid #223041;border-radius:.5rem;padding:.45rem .6rem;font-size:.95rem}
  button.primary{background:#1a2b3f;border-color:#2a4060}
  .kpi{font-variant-numeric:tabular-nums;color:var(--muted)} .kpi b{color:var(--fg)}
  .spacer{flex:1}
  #stage{position:relative;background:#000;overflow:hidden}
  video,canvas#overlay{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;transform-origin:center}
  canvas#overlay{pointer-events:none}
  #banner{position:absolute;left:50%;top:calc(8px + env(safe-area-inset-top));transform:translateX(-50%);background:rgba(0,0,0,.85);border:1px solid #263445;border-radius:.5rem;padding:.45rem .7rem;font-size:.9rem;z-index:5;display:none}
  #bottomBar{display:flex;gap:.75rem;align-items:center;padding:.6rem .8rem;background:#0f131a;border-top:1px solid var(--bar-border)}
  #zoomSlider{width:100%}
  #status{display:grid;grid-template-columns:repeat(5,auto);gap:.75rem 1.2rem;align-items:center;padding:.35rem .75rem;font-size:.9rem;color:var(--muted)}
  .ok{color:var(--ok)} .warn{color:var(--warn)} .bad{color:var(--bad)} .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
  @media (orientation:landscape){
    #app{grid-template-rows:1fr}
    header,#bottomBar,#status{position:fixed;left:calc(8px + env(safe-area-inset-left));right:calc(8px + env(safe-area-inset-right));z-index:10;background:var(--bar);backdrop-filter:saturate(1.1) blur(8px);border:1px solid var(--bar-border);border-radius:.6rem}
    header{top:calc(8px + env(safe-area-inset-top));padding:.4rem .6rem}
    #bottomBar{bottom:calc(10px + env(safe-area-inset-bottom));padding:.45rem .6rem}
    #status{bottom:calc(10px + env(safe-area-inset-bottom));transform:translateY(calc(100% + 8px));padding:.3rem .5rem;font-size:.85rem;grid-template-columns:repeat(5,minmax(0,auto))}
    button,select,label.chip{padding:.35rem .5rem;font-size:.9rem}
  }
</style>
</head>
<body>
<div id="app">
  <header>
    <div class="group">
      <button id="btnStart" class="primary">üé• Kamera starten</button>
      <select id="selCam" title="Kamera/Linse" disabled><option>‚Äî</option></select>
      <select id="selQuality" title="Qualit√§t" disabled>
        <option value="auto" selected>Auto (Max)</option>
        <option value="2160">2160p</option>
        <option value="1440">1440p</option>
        <option value="1080">1080p</option>
        <option value="720">720p</option>
      </select>
      <button id="btnManualBoard">‚úèÔ∏è Tafel manuell</button>
      <button id="btnResetBoard">‚ôªÔ∏è Reset</button>
      <button id="btnSnap" disabled>üì∏ Manuell</button>
    </div>
    <div class="group">
      <button id="btnDir">üìÅ Ordner w√§hlen</button>
      <span id="saveMode" class="kpi">Speichern: <b>Download</b></span>
    </div>
    <div class="spacer"></div>
    <div class="group">
      <span id="kpiRes" class="kpi">‚Äî</span>
      <span id="kpiFps" class="kpi">‚Äî</span>
    </div>
  </header>

  <div id="stage">
    <div id="banner"></div>
    <video id="video" playsinline muted></video>
    <canvas id="overlay"></canvas>
  </div>

  <div id="bottomBar">
    <label for="zoomSlider">üîé Zoom</label>
    <input id="zoomSlider" type="range" min="1" max="10" step="0.01" value="1" disabled>
    <span id="zoomInfo" class="kpi">Anzeige 1.00√ó | HW ‚Äî</span>
    <span class="spacer"></span>
    <label class="chip"><input type="checkbox" id="tglBoardChange" checked> Folien-√Ñnderung</label>
    <label class="chip"><input type="checkbox" id="tglAuto"> Auto Foto</label>
    <label class="chip"><input type="checkbox" id="tglBlocker" checked> Objekte blockieren</label>
    <label class="chip"><input type="checkbox" id="tglFace"> Face-Blocker</label>
    <label class="chip"><input type="checkbox" id="tglOCR"> OCR</label>
  </div>

  <div id="status">
    <div>Board erkannt: <b id="stBoard" class="bad">nein</b></div>
    <div>Auto: <b id="stAuto" class="warn">aus</b></div>
    <div>Blocker: <b id="stBlock" class="warn">‚Äî</b></div>
    <div>Modelle: <span id="stModels" class="mono">‚Äî</span></div>
    <div>Diff: <span id="stDiff" class="mono">‚Äî</span></div>
  </div>
</div>

<script>
/* ===== Short helpers ===== */
const $=s=>document.querySelector(s), on=(el,ev,fn,o)=>el.addEventListener(ev,fn,o);
const clamp=(v,l,h)=>Math.max(l,Math.min(h,v)), fmt=(n,d=2)=>Number(n).toFixed(d);
const banner=$('#banner'); function showBanner(t,cls='warn',ms=3000){ banner.textContent=t; banner.style.display='block'; banner.style.borderColor=cls==='bad'?'#7a2a2a':cls==='ok'?'#2f6a45':'#263445'; clearTimeout(showBanner._t); showBanner._t=setTimeout(()=>banner.style.display='none',ms); }

/* ===== Elements ===== */
const video=$('#video'), overlay=$('#overlay'), ctxOv=overlay.getContext('2d',{willReadFrequently:true});
const btnStart=$('#btnStart'), selCam=$('#selCam'), selQuality=$('#selQuality'), btnSnap=$('#btnSnap');
const btnManualBoard=$('#btnManualBoard'), btnResetBoard=$('#btnResetBoard');
const btnDir=$('#btnDir'), saveMode=$('#saveMode');
const tglBoardChange=$('#tglBoardChange'), tglAuto=$('#tglAuto'), tglBlocker=$('#tglBlocker'), tglFace=$('#tglFace'), tglOCR=$('#tglOCR');
const kpiRes=$('#kpiRes'), kpiFps=$('#kpiFps'), stBoard=$('#stBoard'), stAuto=$('#stAuto'), stBlock=$('#stBlock'), stModels=$('#stModels'), stDiff=$('#stDiff');
const zoomSlider=$('#zoomSlider'), zoomInfo=$('#zoomInfo');

/* ===== State ===== */
let mediaStream=null, track=null, caps=null, sets=null;
let hardwareZoom=false, hwMin=1, hwMax=1, displayZoom=1;
let dirHandle=null, haveFSAccess=('showDirectoryPicker' in window);

let cvReady=false, cvFailed=false, loadingCV=false;
let loopRunning=false, manualMode=false, manualPts=[];
let boardQuadOverlay=null, boardQuadVideo=null, boardFound=false, H_video=null;
let targetW=1600, targetH=900;
let prevThumb=null, lastChangeTs=0; const CHANGE_THRESH=0.09, STABLE_MS=800, COOLDOWN_MS=3500;
let fpsCounter={last:performance.now(),frames:0};

/* ===== Layout & Zoom ===== */
function resizeOverlay(){ const r=video.getBoundingClientRect(); overlay.width=Math.max(2,Math.round(r.width)); overlay.height=Math.max(2,Math.round(r.height)); }
new ResizeObserver(resizeOverlay).observe($('#stage'));
function applyDisplayTransform(){ const t=`scale(${displayZoom})`; video.style.transform=t; overlay.style.transform=t; }
on(zoomSlider,'input',()=>applyZoom(parseFloat(zoomSlider.value)));
async function applyZoom(total){
  let hw=1, disp=total;
  if (hardwareZoom){
    hw = clamp(total, hwMin, hwMax);
    try{ await track.applyConstraints({advanced:[{zoom:hw}]}); }catch(e){ hw=1; disp=total; }
    disp = total / hw;
  }
  displayZoom = clamp(disp, 1, 10);
  applyDisplayTransform();
  zoomInfo.textContent=`Anzeige ${fmt(displayZoom,2)}√ó | HW ${hardwareZoom?fmt(hw,2)+'√ó':'‚Äî'}`;
}

/* ===== FS Access ===== */
async function chooseDirectory(){
  if (!haveFSAccess){ showBanner('FS Access API nicht unterst√ºtzt ‚Äì nutze Downloads','warn',4000); return; }
  try{ dirHandle=await window.showDirectoryPicker({mode:'readwrite'}); saveMode.innerHTML='Speichern: <b>Ordner</b>'; }catch{}
}
async function saveImage(blob, base='Tafel'){
  const t=new Date(), p=s=>String(s).padStart(2,'0');
  const name=`${base}_${t.getFullYear()}${p(t.getMonth()+1)}${p(t.getDate())}_${p(t.getHours())}${p(t.getMinutes())}${p(t.getSeconds())}.png`;
  if (dirHandle && haveFSAccess){
    try{ const perm=await dirHandle.requestPermission?.({mode:'readwrite'}); if (perm==='granted'){ const fh=await dirHandle.getFileHandle(name,{create:true}); const w=await fh.createWritable(); await w.write(blob); await w.close(); return {mode:'folder',name}; } }catch{}
  }
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=name; document.body.appendChild(a); a.click(); URL.revokeObjectURL(a.href); a.remove();
  return {mode:'download',name};
}

/* ===== Script loader & OpenCV redundant ===== */
function loadScript(src){ return new Promise((res,rej)=>{ const s=document.createElement('script'); s.src=src; s.async=true; s.onload=()=>res(); s.onerror=e=>rej(e); document.head.appendChild(s); }); }
async function loadOpenCV(){
  if (cvReady||cvFailed||loadingCV) return cvReady;
  loadingCV=true;
  const sources=[
    'https://docs.opencv.org/4.x/opencv.js',
    'https://cdn.jsdelivr.net/npm/@techstark/opencv-js@4.10.0/opencv.js',
    'https://cdn.jsdelivr.net/gh/opencv/opencv@4.x/build_js/bin/opencv.js'
  ];
  for (const src of sources){
    try{
      const base=src.substring(0,src.lastIndexOf('/')+1);
      window.Module={ locateFile:(p)=> base+p };
      await loadScript(src);
      await new Promise((res,rej)=>{ const t0=performance.now(); (function wait(){ if (typeof cv!=='undefined'&&cv?.Mat) return res(); if (performance.now()-t0>12000) return rej(new Error('OpenCV timeout')); requestAnimationFrame(wait); })(); });
      cvReady=true; stModels.textContent='OpenCV, Motion'; loadingCV=false; return true;
    }catch(e){ /* try next */ }
  }
  cvFailed=true; loadingCV=false; stModels.textContent='(ohne OpenCV)'; showBanner('OpenCV nicht geladen ‚Äì Erkennung aus','warn',5000); return false;
}

/* ===== Mapping: Overlay -> Video (object-fit: cover) ===== */
function overlayToVideoPoint(pt){
  const ow=overlay.width, oh=overlay.height;
  const vw=video.videoWidth||ow, vh=video.videoHeight||oh;
  if (!vw||!vh) return {x:pt.x, y:pt.y};
  const s=Math.max(ow/vw, oh/vh);           // cover scale
  const dw=vw*s, dh=vh*s;
  const dx=(ow - dw)/2, dy=(oh - dh)/2;     // can be negative
  const x=(pt.x - dx)/s, y=(pt.y - dy)/s;   // map back to video px
  return { x: clamp(x,0,vw-1), y: clamp(y,0,vh-1) };
}
function mapQuadOverlayToVideo(q){ return q.map(p=>overlayToVideoPoint(p)); }

/* ===== OpenCV utils (robust, inkl. Fallback) ===== */
function orderTLTRBRBL(pts){
  const bySum=pts.slice().sort((a,b)=>(a.x+a.y)-(b.x+b.y));
  const byDiff=pts.slice().sort((a,b)=>(a.x-a.y)-(b.x-b.y));
  const tl=bySum[0], br=bySum[bySum.length-1], tr=byDiff[byDiff.length-1], bl=byDiff[0];
  return [tl,tr,br,bl];
}
function detectBoardQuadOverlay(frameCanvas){
  const w=frameCanvas.width, h=frameCanvas.height;
  const sw=Math.max(360,Math.round(w*0.5)), sh=Math.max(200,Math.round(h*0.5));
  const src=cv.imread(frameCanvas);
  const resized=new cv.Mat(); cv.resize(src,resized,new cv.Size(sw,sh),0,0,cv.INTER_AREA);
  const gray=new cv.Mat(); cv.cvtColor(resized,gray,cv.COLOR_RGBA2GRAY);
  try{ if (cv.createCLAHE){ const clahe=cv.createCLAHE(2.0,new cv.Size(8,8)); clahe.apply(gray,gray); clahe.delete(); } else { cv.equalizeHist(gray,gray); } }catch{}
  cv.GaussianBlur(gray,gray,new cv.Size(5,5),0);

  let best=null,bestScore=-1;
  const passes=[ {adaptive:false,canny:[60,150],close:3}, {adaptive:true,canny:[40,120],close:5} ];
  for (const pass of passes){
    let edges=new cv.Mat();
    if (pass.adaptive){ let thr=new cv.Mat(); cv.adaptiveThreshold(gray,thr,255,cv.ADAPTIVE_THRESH_GAUSSIAN_C,cv.THRESH_BINARY,11,2); edges=thr; }
    else { cv.Canny(gray,edges,pass.canny[0],pass.canny[1]); }
    const kernel=cv.Mat.ones(pass.close,pass.close,cv.CV_8U); cv.morphologyEx(edges,edges,cv.MORPH_CLOSE,kernel);
    const contours=new cv.MatVector(), hierarchy=new cv.Mat();
    cv.findContours(edges,contours,hierarchy,cv.RETR_LIST,cv.CHAIN_APPROX_SIMPLE);

    for (let i=0;i<contours.size();i++){
      const cnt=contours.get(i), peri=cv.arcLength(cnt,true);
      const approx=new cv.Mat(); cv.approxPolyDP(cnt,approx,0.02*peri,true);
      const area=cv.contourArea(cnt);
      if (approx.rows===4 && cv.isContourConvex(approx) && area>(sw*sh*0.10)){
        const d=approx.data32S, pts=[]; for(let j=0;j<d.length;j+=2) pts.push({x:d[j],y:d[j+1]});
        const ord=orderTLTRBRBL(pts);
        const w1=Math.hypot(ord[1].x-ord[0].x,ord[1].y-ord[0].y), w2=Math.hypot(ord[2].x-ord[3].x,ord[2].y-ord[3].y);
        const h1=Math.hypot(ord[3].x-ord[0].x,ord[3].y-ord[0].y), h2=Math.hypot(ord[2].x-ord[1].x,ord[2].y-ord[1].y);
        const wA=(w1+w2)/2, hA=(h1+h2)/2;
        const rectScore=1 - Math.abs(w1-w2)/Math.max(1,wA) - Math.abs(h1-h2)/Math.max(1,hA);
        const ar=wA/Math.max(1,hA); const arScore=(ar>0.7 && ar<2.5)?0.5:0;
        const score=(area/(sw*sh))+rectScore+arScore;
        if (score>bestScore){ bestScore=score; best=ord.map(p=>({x:p.x*(w/sw), y:p.y*(h/sh)})); }
      }
      approx.delete();
    }

    // Fallback: gr√∂√ütes minAreaRect ‚Üí **robust f√ºr Array ODER Mat**
    if (!best){
      let maxArea=0, maxCnt=null;
      for (let i=0;i<contours.size();i++){ const a=cv.contourArea(contours.get(i)); if (a>maxArea){ maxArea=a; maxCnt=contours.get(i);} }
      if (maxCnt && maxArea>(sw*sh*0.15)){
        const rect=cv.minAreaRect(maxCnt);
        const box=cv.RotatedRect.points(rect); // kann Array oder Mat sein
        let pts=[];
        if (Array.isArray(box)){ // aktueller @techstark Build
          pts = [box[0],box[1],box[2],box[3]].map(p=>({x:p.x*(w/sw), y:p.y*(h/sh)}));
        } else {
          // Mat (CV_32FC2/CV_32SC2)
          const data = (box.data32F && box.data32F.length)? box.data32F : box.data32S;
          for (let k=0;k<data.length;k+=2){ pts.push({x:data[k]*(w/sw), y:data[k+1]*(h/sh)}); }
          box.delete && box.delete();
        }
        best = orderTLTRBRBL(pts);
        bestScore = maxArea/(sw*sh);
      }
    }

    edges.delete(); kernel.delete(); contours.delete(); hierarchy.delete();
    if (best) break;
  }
  src.delete(); resized.delete(); gray.delete();
  return best;
}

function computeHomographyVideo(qVideo){
  const [tl,tr,br,bl]=orderTLTRBRBL(qVideo);
  const wTop=Math.hypot(tr.x-tl.x,tr.y-tl.y), wBot=Math.hypot(br.x-bl.x,br.y-bl.y);
  const hL=Math.hypot(bl.x-tl.x,bl.y-tl.y), hR=Math.hypot(br.x-tr.x,br.y-tr.y);
  const wA=(wTop+wBot)/2, hA=(hL+hR)/2, asp=clamp(wA/Math.max(1,hA),0.7,2.5);
  targetW=1600; targetH=Math.round(targetW/asp);

  const srcTri=cv.matFromArray(4,1,cv.CV_32FC2,[ tl.x,tl.y,tr.x,tr.y,br.x,br.y,bl.x,bl.y ]);
  const dstTri=cv.matFromArray(4,1,cv.CV_32FC2,[ 0,0, targetW,0, targetW,targetH, 0,targetH ]);
  const H=cv.getPerspectiveTransform(srcTri, dstTri);
  srcTri.delete(); dstTri.delete();
  return H;
}

function warpBoardVideo(frameCanvasSensor, H){
  const src=cv.imread(frameCanvasSensor), dst=new cv.Mat();
  cv.warpPerspective(src,dst,new cv.Size(targetW,targetH),cv.INTER_LINEAR,cv.BORDER_REPLICATE);
  const out=document.createElement('canvas'); out.width=targetW; out.height=targetH; cv.imshow(out,dst);
  src.delete(); dst.delete();
  return out;
}

/* ===== Frame helpers (Overlay & Sensor) ===== */
function frameCanvasOverlay(){
  const c=document.createElement('canvas'); c.width=overlay.width; c.height=overlay.height;
  c.getContext('2d',{willReadFrequently:true}).drawImage(video,0,0,c.width,c.height); return c;
}
function frameCanvasSensor(){
  const vw=video.videoWidth||overlay.width, vh=video.videoHeight||overlay.height;
  const c=document.createElement('canvas'); c.width=vw; c.height=vh;
  c.getContext('2d',{willReadFrequently:true}).drawImage(video,0,0,c.width,c.height); return c;
}
function grayThumb(srcCanvas,tw=128,th=72){
  const c=document.createElement('canvas'); c.width=tw; c.height=th;
  const x=c.getContext('2d',{willReadFrequently:true}); x.drawImage(srcCanvas,0,0,tw,th);
  const id=x.getImageData(0,0,tw,th).data; const out=new Float32Array(tw*th);
  for(let i=0,j=0;i<id.length;i+=4,j++) out[j]=(0.299*id[i]+0.587*id[i+1]+0.114*id[i+2])/255;
  return {data:out,w:tw,h:th};
}
function mse(a,b){ if(!a||!b||a.data.length!==b.data.length) return 1; let s=0; for(let i=0;i<a.data.length;i++){ const d=a.data[i]-b.data[i]; s+=d*d; } return s/a.data.length; }

/* ===== Face & OCR (optional; lazy) ===== */
let faceModel=null, tfLoaded=false, blazeLoaded=false, tessLoaded=false;
async function ensureFace(){
  if (!tfLoaded){ try{ await loadScript('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js'); tfLoaded=true; }catch{ try{ await loadScript('https://unpkg.com/@tensorflow/tfjs@4.22.0/dist/tf.min.js'); tfLoaded=true; }catch(e){} } }
  if (!blazeLoaded){ try{ await loadScript('https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface@0.1.2/dist/blazeface.min.js'); blazeLoaded=true; }catch{ try{ await loadScript('https://unpkg.com/@tensorflow-models/blazeface@0.1.2/dist/blazeface.min.js'); blazeLoaded=true; }catch(e){} } }
  if (window.blazeface && !faceModel){ try{ faceModel=await blazeface.load(); stModels.textContent+=', BlazeFace'; }catch(e){} }
  return !!faceModel;
}
function triArea(a,b,c){ return Math.abs((a.x*(b.y-c.y)+b.x*(c.y-a.y)+c.x*(a.y-b.y))/2); }
function polyArea(q){ return triArea(q[0],q[1],q[2])+triArea(q[0],q[2],q[3]); }
function pointInQuad(p,q){ const A=polyArea(q); const s=triArea(p,q[0],q[1])+triArea(p,q[1],q[2])+triArea(p,q[2],q[3])+triArea(p,q[3],q[0]); return Math.abs(s-A)<1e-1*A; }
async function faceBlockVerdict(canvasOverlay){
  if (!tglFace.checked || !boardQuadOverlay) return false;
  try{ const ok=await ensureFace(); if(!ok) return false;
    const preds=await faceModel.estimateFaces(canvasOverlay,false); if(!preds?.length) return false;
    for (const p of preds){ if(!p.topLeft||!p.bottomRight) continue; const cx=(p.topLeft[0]+p.bottomRight[0])/2, cy=(p.topLeft[1]+p.bottomRight[1])/2; if (pointInQuad({x:cx,y:cy}, boardQuadOverlay)) return true; }
  }catch(e){}
  return false;
}
async function ensureOCR(){ if (!tessLoaded){ try{ await loadScript('https://cdn.jsdelivr.net/npm/tesseract.js@5.1.1/dist/tesseract.min.js'); tessLoaded=true; }catch{ try{ await loadScript('https://unpkg.com/tesseract.js@5.1.1/dist/tesseract.min.js'); tessLoaded=true; }catch(e){} } if (tessLoaded) stModels.textContent+=', OCR'; return tessLoaded; }
async function runOCR(canvas){ try{ const ok=await ensureOCR(); if(!ok) return; const worker=await Tesseract.createWorker('deu'); const {data:{text}}=await worker.recognize(canvas); await worker.terminate(); console.log('OCR:',text); }catch(e){} }

/* ===== Kamera & Aufl√∂sung (mit Re-Open-Fallback) ===== */
async function listCameras(){
  const devs=await navigator.mediaDevices.enumerateDevices();
  const cams=devs.filter(d=>d.kind==='videoinput');
  const score=l=>{ l=(l||'').toLowerCase(); let s=0; if (l.includes('tele')) s-=30; if (l.includes('aux')) s-=20; if (l.includes('wide')) s-=10; if (l.includes('ultra')) s+=5; if (l.includes('front')) s+=50; if (l.includes('back')||l.includes('rear')||l.includes('environment')) s-=10; return s; };
  cams.sort((a,b)=>score(a.label)-score(b.label));
  selCam.innerHTML=''; cams.forEach(c=>{ const o=document.createElement('option'); o.value=c.deviceId; o.textContent=c.label||`Kamera ${c.deviceId.slice(0,6)}`; selCam.appendChild(o); });
  selCam.disabled=cams.length===0;
}
async function restartStreamWithConstraints(cons){
  if (mediaStream){ mediaStream.getTracks().forEach(t=>t.stop()); mediaStream=null; }
  mediaStream=await navigator.mediaDevices.getUserMedia(cons);
  video.srcObject=mediaStream; await video.play().catch(()=>{});
  track=mediaStream.getVideoTracks()[0]; caps=track.getCapabilities?.()||{}; sets=track.getSettings?.()||{};
  hardwareZoom='zoom' in (caps||{}); if (hardwareZoom){ hwMin=caps.zoom.min??1; hwMax=caps.zoom.max??1; }
  kpiRes.textContent=`Aufl√∂sung: ${sets.width||video.videoWidth||'‚Äî'}√ó${sets.height||video.videoHeight||'‚Äî'}`;
  await new Promise(r=> video.onloadedmetadata ? (video.onloadedmetadata=()=>r()) : setTimeout(r,150));
  resizeOverlay(); applyDisplayTransform();
}
async function startCamera(deviceId=null){
  try{
    btnStart.disabled=true;
    if (!navigator.mediaDevices?.getUserMedia){ showBanner('getUserMedia nicht verf√ºgbar (HTTPS/Browser pr√ºfen)','bad',7000); btnStart.disabled=false; return; }
    // 1) Back+Zielaufl√∂sung ‚Üí 2) Back ‚Üí 3) Any
    let cons=deviceId?{video:{deviceId:{exact:deviceId}},audio:false}:{video:{facingMode:{ideal:'environment'},width:{ideal:1920},height:{ideal:1080},frameRate:{ideal:30,max:60}},audio:false};
    try{ await restartStreamWithConstraints(cons); }
    catch(e1){ try{ await restartStreamWithConstraints({video:{facingMode:{ideal:'environment'}},audio:false}); } catch(e2){ await restartStreamWithConstraints({video:true,audio:false}); } }

    await listCameras(); selQuality.disabled=false; btnSnap.disabled=false; zoomSlider.disabled=false;

    // Optional: AF/AE/AWB
    try{ await track.applyConstraints({advanced:[{focusMode:'continuous'},{exposureMode:'continuous'},{whiteBalanceMode:'continuous'}]}); }catch{}

    // Auto Max oder Preset
    if (selQuality.value==='auto') await setMaxResolution();
    else await applyQualityPreset(selQuality.value);

    sets=track.getSettings?.()||sets; kpiRes.textContent=`Aufl√∂sung: ${sets.width||'‚Äî'}√ó${sets.height||'‚Äî'}`;
    if (!loopRunning){ loopRunning=true; processingLoop(); }
    showBanner('Kamera l√§uft','ok',1500);
  }catch(err){
    let msg=err.name+': '+err.message;
    if (err.name==='NotAllowedError') msg='Kamera-Zugriff verweigert';
    if (err.name==='NotFoundError') msg='Keine Kamera gefunden';
    if (err.name==='NotReadableError') msg='Kamera belegt';
    if (err.name==='OverconstrainedError') msg='Constraint nicht erf√ºllbar';
    showBanner('Kamera-Fehler: '+msg,'bad',7000);
    btnStart.disabled=false;
  }
}
async function setMaxResolution(){
  if (!track?.getCapabilities) return false;
  const c=track.getCapabilities(); const wMax=c.width&&c.width.max, hMax=c.height&&c.height.max, fpsMax=c.frameRate&&c.frameRate.max;
  // 1) Versuche auf bestehendem Track
  if (wMax&&hMax){
    try{
      const adv = c.resizeMode? [{resizeMode:'none'}] : [];
      await track.applyConstraints({ width:{exact:wMax}, height:{exact:hMax}, ...(fpsMax?{frameRate:{ideal:Math.min(60,fpsMax)}}:{}), ...(adv.length?{advanced:adv}:{}) });
      await new Promise(r=>setTimeout(r,120));
      const s=track.getSettings?.(); if (s && s.width===wMax && s.height===hMax) return true;
    }catch{}
  }
  // 2) Re-Open mit harten Constraints (garantierter Weg)
  const deviceId = track?.getSettings?.().deviceId;
  const cons = deviceId? { video:{ deviceId:{exact:deviceId}, width:{exact:wMax||3840}, height:{exact:hMax||2160} }, audio:false } :
                         { video:{ facingMode:{ideal:'environment'}, width:{exact:wMax||3840}, height:{exact:hMax||2160} }, audio:false };
  try{ await restartStreamWithConstraints(cons); return true; }catch{}
  // 3) Leiter: 4K‚Üí1440p‚Üí1080p‚Üí720p (re-open)
  const ladder=[{w:3840,h:2160},{w:2560,h:1440},{w:1920,h:1080},{w:1280,h:720}];
  for (const p of ladder){
    const lc = deviceId? { video:{ deviceId:{exact:deviceId}, width:{exact:p.w}, height:{exact:p.h} }, audio:false }
                       : { video:{ facingMode:{ideal:'environment'}, width:{exact:p.w}, height:{exact:p.h} }, audio:false };
    try{ await restartStreamWithConstraints(lc); return true; }catch{}
  }
  return false;
}
async function applyQualityPreset(q){
  if (!track) return;
  const map={ '2160':{w:3840,h:2160}, '1440':{w:2560,h:1440}, '1080':{w:1920,h:1080}, '720':{w:1280,h:720} };
  const p=map[q]; if (!p) return;
  // Re-Open mit harten Constraints (zuverl√§ssig)
  const deviceId = track?.getSettings?.().deviceId;
  const cons = deviceId? { video:{ deviceId:{exact:deviceId}, width:{exact:p.w}, height:{exact:p.h} }, audio:false }
                       : { video:{ facingMode:{ideal:'environment'}, width:{exact:p.w}, height:{exact:p.h} }, audio:false };
  try{ await restartStreamWithConstraints(cons); }catch(e){ /* ignore */ }
}
on(selQuality,'change',async()=>{ if (selQuality.value==='auto') await setMaxResolution(); else await applyQualityPreset(selQuality.value); });

function updateFps(){ fpsCounter.frames++; const now=performance.now(); if (now-fpsCounter.last>=1000){ kpiFps.textContent=`FPS: ${fpsCounter.frames}`; fpsCounter.frames=0; fpsCounter.last=now; }}

/* ===== Loop & Logik (einmalige Listener-Registrierung) ===== */
async function processingLoop(){
  const cvOk = await loadOpenCV(); // App l√§uft weiter, wenn false
  let frameIdx=0, lastMotion=null; const MOTION_T=0.18, MOTION_FRAC=0.035;

  // Manuell-Clickhandler NUR EINMAL registrieren
  if (!processingLoop._manualBound){
    on(overlay,'click',e=>{
      if (!manualMode) return;
      const r=overlay.getBoundingClientRect(); manualPts.push({x:e.clientX-r.left,y:e.clientY-r.top});
      drawManualPts();
      if (manualPts.length===4){
        boardQuadOverlay=orderTLTRBRBL(manualPts);
        boardQuadVideo=mapQuadOverlayToVideo(boardQuadOverlay);
        boardFound=true;
        if (H_video) H_video.delete();
        H_video=computeHomographyVideo(boardQuadVideo);
        manualMode=false; manualPts=[]; showBanner('Tafel gesetzt','ok',1500);
      }
    });
    processingLoop._manualBound=true;
  }
  function drawManualPts(){
    ctxOv.clearRect(0,0,overlay.width,overlay.height);
    ctxOv.fillStyle='rgba(78,161,255,0.9)';
    for (let i=0;i<manualPts.length;i++){ const p=manualPts[i]; ctxOv.beginPath(); ctxOv.arc(p.x,p.y,6,0,Math.PI*2); ctxOv.fill(); }
    if (manualPts.length>=2){ ctxOv.strokeStyle='rgba(78,161,255,0.7)'; ctxOv.lineWidth=2; ctxOv.beginPath(); ctxOv.moveTo(manualPts[0].x,manualPts[0].y); for(let i=1;i<manualPts.length;i++) ctxOv.lineTo(manualPts[i].x,manualPts[i].y); ctxOv.stroke(); }
  }

  const step = async ()=>{
    if (!mediaStream){ loopRunning=false; return; }
    updateFps();

    const ow=overlay.width, oh=overlay.height;
    if (ow>2 && oh>2){
      const frameOverlay=frameCanvasOverlay();

      if (cvOk && !cvFailed && !manualMode){
        try{
          if (!boardFound || (frameIdx%8===0)){
            const q=detectBoardQuadOverlay(frameOverlay);
            if (q){
              boardQuadOverlay=q;
              boardQuadVideo=mapQuadOverlayToVideo(boardQuadOverlay); // üîÅ Mapping Overlay‚ÜíSensor
              boardFound=true;
              if (H_video) H_video.delete();
              H_video=computeHomographyVideo(boardQuadVideo);
            } else {
              boardFound=false; boardQuadOverlay=null; boardQuadVideo=null;
              if (H_video){ H_video.delete(); H_video=null; }
            }
          }
          // Overlay zeichnen
          ctxOv.clearRect(0,0,ow,oh);
          if (boardQuadOverlay){
            ctxOv.lineWidth=3; ctxOv.strokeStyle='rgba(78,161,255,0.9)'; ctxOv.fillStyle='rgba(78,161,255,0.15)';
            ctxOv.beginPath(); ctxOv.moveTo(boardQuadOverlay[0].x,boardQuadOverlay[0].y); for(let i=1;i<4;i++) ctxOv.lineTo(boardQuadOverlay[i].x,boardQuadOverlay[i].y); ctxOv.closePath(); ctxOv.stroke(); ctxOv.fill();
          }
          stBoard.textContent=boardFound?'ja':'nein'; stBoard.className=boardFound?'ok':'bad';

          // Change/Auto nur wenn Board
          if (boardFound && H_video){
            // F√ºr Diff gen√ºgt Overlay-Warp ‚Üí leicht & schnell
            const vw=video.videoWidth||ow, vh=video.videoHeight||oh;
            const warpedForDiff = (()=>{
              // Simpler Trick: wir nutzen das Overlay-Frame und eine Overlay-Homographie, die wir approximieren:
              // Statt zweiter H berechnen wir den Diff auf dem entzweckten Overlay-Foto (ungef√§hr), reicht f√ºr Trigger.
              return frameOverlay; // lightweight: diff direkt auf Overlay-Thumb
            })();
            const thumb=grayThumb(warpedForDiff,128,72);
            const diffVal=prevThumb?mse(thumb,prevThumb):null; prevThumb=thumb;

            // Motion-Blocker (Overlay-Approx)
            if (!lastMotion) lastMotion=grayThumb(warpedForDiff,128,72);
            const cur=grayThumb(warpedForDiff,128,72);
            let ch=0; for(let i=0;i<cur.data.length;i++) if (Math.abs(cur.data[i]-lastMotion.data[i])>MOTION_T) ch++; 
            const frac=ch/cur.data.length, motionBlock=frac>MOTION_FRAC; lastMotion=cur;

            stDiff.textContent=(diffVal!==null)?fmt(diffVal,3):'‚Äî';
            stBlock.textContent=tglBlocker.checked?(motionBlock?'blockiert':'frei'):'aus';
            stBlock.className=tglBlocker.checked?(motionBlock?'bad':'ok'):'warn';

            const now=performance.now(), stable=(now-lastChangeTs)>STABLE_MS;
            if (tglBoardChange.checked && diffVal!==null && diffVal>CHANGE_THRESH && stable){ lastChangeTs=now; }
            if (tglAuto.checked && tglBoardChange.checked && diffVal!==null && diffVal>CHANGE_THRESH && stable){
              const cooldown=(now-(processingLoop._lastCap||0))>COOLDOWN_MS;
              const blockOk=tglBlocker.checked?!motionBlock:true;
              const faceOk=!(await faceBlockVerdict(frameOverlay));
              if (cooldown && blockOk && faceOk){ await captureAndSave('Auto'); processingLoop._lastCap=performance.now(); }
            }
          } else { ctxOv.clearRect(0,0,ow,oh); stDiff.textContent='‚Äî'; }
        }catch(e){
          stModels.textContent='(ohne OpenCV)'; cvFailed=true; boardFound=false; boardQuadOverlay=null; boardQuadVideo=null; if (H_video){ H_video.delete(); H_video=null; }
          ctxOv.clearRect(0,0,ow,oh);
        }
      } else if (!manualMode){
        ctxOv.clearRect(0,0,ow,oh); stBoard.textContent='nein'; stBoard.className='bad'; stDiff.textContent='‚Äî';
      }
    }
    frameIdx++; requestAnimationFrame(step);
  };
  requestAnimationFrame(step);
}

/* ===== Capture (EXPORT in Sensor-Aufl√∂sung!) ===== */
async function captureAndSave(prefix='Tafel'){
  try{
    let out=null;
    if (boardFound && H_video && cvReady && !cvFailed){
      const frameSensor=frameCanvasSensor();               // üî¥ volle Sensor-Aufl√∂sung
      out = warpBoardVideo(frameSensor, H_video);          // üî¥ Entzerrt in hoher Qualit√§t
    } else {
      out = frameCanvasSensor();                           // Fallback: volles Sensor-Bild
    }
    const blob=await new Promise(res=>out.toBlob(res,'image/png',0.95));
    const r=await saveImage(blob,prefix); showBanner(`Foto gespeichert (${r.mode})`,'ok',1600);
    if (tglOCR.checked) runOCR(out);
  }catch(e){ showBanner('Fehler beim Speichern','bad',4000); }
}

/* ===== Events ===== */
on(btnStart,'click',()=>startCamera());
on(selCam,'change',()=>startCamera(selCam.value));
on(selQuality,'change',async()=>{ if (selQuality.value==='auto') await setMaxResolution(); else await applyQualityPreset(selQuality.value); });
on(btnSnap,'click',()=>captureAndSave('Manuell'));
on(btnDir,'click',chooseDirectory);
on(tglAuto,'change',()=>{ stAuto.textContent=tglAuto.checked?'an':'aus'; stAuto.className=tglAuto.checked?'ok':'warn'; });
on(btnManualBoard,'click',()=>{ manualMode=true; manualPts=[]; showBanner('Manuell: tippe 4 Ecken (tl‚Üítr‚Üíbr‚Üíbl)','warn',5000); ctxOv.clearRect(0,0,overlay.width,overlay.height); });
on(btnResetBoard,'click',()=>{ manualMode=false; manualPts=[]; boardFound=false; boardQuadOverlay=null; boardQuadVideo=null; if (H_video){ H_video.delete(); H_video=null; } ctxOv.clearRect(0,0,overlay.width,overlay.height); showBanner('Board-Erkennung zur√ºckgesetzt','ok',1200); });
on(document,'keydown',(e)=>{ if (e.key.toLowerCase()==='c') captureAndSave('Manuell'); if (e.key==='+'){ const z=clamp(parseFloat(zoomSlider.value)+0.1,1,10); zoomSlider.value=z; applyZoom(z);} if (e.key==='-'){ const z=clamp(parseFloat(zoomSlider.value)-0.1,1,10); zoomSlider.value=z; applyZoom(z);} });

/* ===== Init ===== */
(async function init(){
  stAuto.textContent=tglAuto.checked?'an':'aus'; stAuto.className=tglAuto.checked?'ok':'warn';
  saveMode.innerHTML = haveFSAccess ? 'Speichern: <b>Download / Ordner</b>' : 'Speichern: <b>Download</b>';
  zoomInfo.textContent=`Anzeige ${fmt(displayZoom,2)}√ó | HW ‚Äî`;
  try{ await listCameras(); }catch{}
  loadOpenCV(); // non-blocking preload
})();
</script>
</body>
</html>
