
!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TafelCapture ‚Äì Android 15</title>
  <style>
    :root {
      --bg:#0f1115; --fg:#e8eaf0; --muted:#9aa3b2; --accent:#4cc9f0; --ok:#2ecc71; --warn:#f1c40f; --err:#e74c3c;
      --card:#161a22; --border:#283042;
      --zoom:1;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:var(--bg);color:var(--fg)}
    .app{display:grid;gap:.75rem;padding:.75rem;height:100vh}
    @media (orientation:portrait){
      .app{grid-template-rows:auto 1fr auto;grid-template-columns:1fr}
      .stage{grid-row:2}
      .controls-top{grid-row:1}
      .controls-bottom{grid-row:3}
    }
    @media (orientation:landscape){
      .app{grid-template-columns:1fr 340px;grid-template-rows:1fr auto}
      .stage{grid-column:1;grid-row:1/span 2}
      .controls-top{grid-column:2;grid-row:1}
      .controls-bottom{grid-column:2;grid-row:2}
    }
    .card{background:var(--card);border:1px solid var(--border);border-radius:10px;padding:.75rem}
    .row{display:flex;gap:.5rem;flex-wrap:wrap;align-items:center;margin:.5rem 0}
    .btn{background:#1f2633;color:var(--fg);border:1px solid var(--border);border-radius:8px;padding:.55rem .8rem;cursor:pointer}
    .btn.primary{background:linear-gradient(180deg,#2a3446,#1e2635);border-color:#3a4a66}
    .btn:disabled{opacity:.5;cursor:not-allowed}
    .toggle{display:flex;align-items:center;gap:.4rem}
    .pill{display:inline-flex;align-items:center;gap:.4rem;padding:.15rem .5rem;border-radius:999px;font-size:.85rem;border:1px solid var(--border)}
    .pill.ok{color:var(--ok)} .pill.warn{color:var(--warn)} .pill.err{color:var(--err)}
    .sep{height:1px;background:var(--border);margin:.5rem 0}
    .status{display:grid;grid-template-columns:1fr 1fr;gap:.35rem;font-size:.9rem;color:var(--muted)}
    .status .kv{display:flex;justify-content:space-between;gap:.75rem;background:#11151d;border:1px solid var(--border);border-radius:8px;padding:.35rem .5rem}

    /* B√ºhne mit Livebild & Overlay */
    .stage{position:relative;overflow:hidden}
    video,canvas{width:100%;height:100%;object-fit:contain;border-radius:10px}
    #preview{position:absolute;inset:0;z-index:0;background:#000;transform:scale(var(--zoom));transform-origin:center center}
    #overlay{position:absolute;inset:0;z-index:1;pointer-events:none;background:transparent !important;transform:scale(var(--zoom));transform-origin:center center}

    /* Zoom-Leiste unten auf dem Livebild */
    .zoombar{position:absolute;left:.75rem;right:.75rem;bottom:.75rem;z-index:2;
             display:flex;gap:.5rem;align-items:center;justify-content:center;
             background:rgba(0,0,0,.35);backdrop-filter:blur(2px);border-radius:10px;padding:.35rem .6rem}
    .zoombar input[type="range"]{width:200px}
    .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
  </style>
</head>
<body>
  <div class="app">
    <div class="stage card" id="stage">
      <video id="preview" playsinline autoplay muted></video>
      <canvas id="overlay"></canvas>

      <!-- Zoom -->
      <div class="zoombar">
        <label class="toggle" style="color:#e8eaf0">
          üîé Zoom
          <input type="range" id="zoomRange" min="1" max="3" step="0.1" value="1">
        </label>
        <span id="zoomVal" class="pill mono">1.0√ó</span>
      </div>
    </div>

    <div class="controls-top card">
      <h2 style="margin:0 0 .25rem;color:#9aa3b2">Aufnahme &amp; Ordner</h2>
      <div class="row">
        <button class="btn primary" id="btnStart">Kamera starten</button>
        <button class="btn" id="btnTorch" disabled>üî¶ Taschenlampe</button>
        <button class="btn" id="btnShot" disabled>üì∏ Manuell ausl√∂sen</button>
      </div>
      <div class="row">
        <button class="btn" id="btnChooseDir">üìÅ Ordner w√§hlen</button>
        <span id="dirStatus" class="pill warn">kein Ordner</span>
        <label class="toggle"><input type="checkbox" id="cbUseDownloads"> Fallback: Downloads nutzen</label>
      </div>
      <div class="row">
        <span class="pill mono" id="permCam">Kamera: ?</span>
        <span class="pill mono" id="permFS">Dateizugriff: ?</span>
        <span class="pill mono" id="pillFPS">0 FPS</span>
      </div>

      <div class="sep"></div>
      <h2 style="margin:0 0 .25rem;color:#9aa3b2">Erkennung</h2>
      <div class="row">
        <label class="toggle"><input type="checkbox" id="cbPerson" checked> Personenerkennung</label>
        <label class="toggle"><input type="checkbox" id="cbSlide" checked> Folien‚Äë√Ñnderung</label>
        <!-- nicht voraktiviert -->
        <label class="toggle"><input type="checkbox" id="cbAutoCap"> Auto‚ÄëFoto bei Folienwechsel</label>
      </div>
      <div class="row">
        <label>Schwellwert √Ñnderung:
          <input type="range" id="slideThresh" min="5" max="40" value="12"> <span id="slideVal">12%</span>
        </label>
      </div>
      <div class="row">
        <span id="statePerson" class="pill mono">Person: unbekannt</span>
        <span id="stateSlide" class="pill mono">Folie: stabil</span>
      </div>
    </div>

    <div class="controls-bottom card">
      <h2 style="margin:0 0 .25rem;color:#9aa3b2">Status</h2>
      <div class="status">
        <div class="kv"><span>Board erkannt</span><span id="kvBoard">-</span></div>
        <div class="kv"><span>Aufl√∂sung</span><span id="kvRes">-</span></div>
        <div class="kv"><span>Modell</span><span id="kvModel">-</span></div>
        <div class="kv"><span>Gespeichert</span><span id="kvSaved">0</span></div>
      </div>
      <div class="sep"></div>
      <small>
        Hinweis: Kamera-Zugriff funktioniert nur √ºber <code>https://</code> oder <code>http://localhost</code>. Auf Android per Chrome empfohlen.
      </small>
    </div>
  </div>

  <script>
  (function(){
    // ======= DOM =======
    const $ = s => document.querySelector(s);
    const stage = $('#stage');
    const video = $('#preview');
    const overlay = $('#overlay');
    const ctx = overlay.getContext('2d');

    const btnStart = $('#btnStart');
    const btnTorch = $('#btnTorch');
    const btnShot  = $('#btnShot');
    const btnChooseDir = $('#btnChooseDir');
    const cbUseDownloads = $('#cbUseDownloads');

    const cbPerson = $('#cbPerson');
    const cbSlide  = $('#cbSlide');
    const cbAutoCap= $('#cbAutoCap');
    const slideThresh = $('#slideThresh');
    const slideVal = $('#slideVal');

    const permCam = $('#permCam');
    const permFS  = $('#permFS');
    const pillFPS = $('#pillFPS');
    const kvBoard = $('#kvBoard');
    const kvRes   = $('#kvRes');
    const kvModel = $('#kvModel');
    const kvSaved = $('#kvSaved');

    const zoomRange = $('#zoomRange');
    const zoomVal   = $('#zoomVal');

    // ======= State =======
    let stream = null, videoTrack = null, torchOn = false;
    let dirHandle = null, savedCount = 0;

    // Recognition state
    let cvReady = false, cvLoading = false;
    let segmenter = null, tfLoading = false; // optional persons
    let boardQuad = null;
    let lastSlideThumb = null;
    let slideStableSince = 0, personPresent = false;
    let lastTickT = performance.now(), frames = 0, rafId = 0;

    slideVal.textContent = slideThresh.value + '%';
    slideThresh.addEventListener('input', () => slideVal.textContent = slideThresh.value + '%');

    // ======= Zoom (Anzeige) =======
    function setZoom(z) { stage.style.setProperty('--zoom', z); zoomVal.textContent = z.toFixed(1)+'√ó'; }
    zoomRange.addEventListener('input', () => setZoom(parseFloat(zoomRange.value)||1));
    setZoom(1);

    // ======= Kamera =======
    async function startCamera() {
      stopCamera();

      // Mobile: Inline & stumm, sonst blockt play()
      video.setAttribute('playsinline',''); video.muted = true; video.autoplay = true;

      if (!navigator.mediaDevices?.getUserMedia) {
        permCam.textContent = 'Kamera: nicht unterst√ºtzt'; permCam.className = 'pill err';
        alert('getUserMedia wird von diesem Browser nicht unterst√ºtzt.');
        return;
      }

      const preferred = { video:{ facingMode:{ideal:'environment'}, width:{ideal:1920}, height:{ideal:1080} }, audio:false };
      try {
        stream = await navigator.mediaDevices.getUserMedia(preferred);
      } catch (e1) {
        console.warn('preferred getUserMedia failed', e1);
        stream = await navigator.mediaDevices.getUserMedia({ video:true, audio:false });
      }

      video.srcObject = stream;
      videoTrack = stream.getVideoTracks()[0];

      // Aufl√∂sung/Overlay setzen, sobald Meta da sind
      const applyMeta = () => {
        overlay.width  = video.videoWidth  || overlay.clientWidth  || 1280;
        overlay.height = video.videoHeight || overlay.clientHeight || 720;
        kvRes.textContent = `${overlay.width}√ó${overlay.height}`;
      };
      if (video.readyState >= 1) applyMeta();
      else video.addEventListener('loadedmetadata', applyMeta, { once:true });

      try { await video.play(); } catch(e){ console.warn('video.play blocked:', e); }

      btnShot.disabled = false;
      permCam.textContent = 'Kamera: ok'; permCam.className = 'pill ok';

      detectTorchSupport();
      loadOpenCV(); // startet asynchron; Fallback-Erkennung l√§uft sofort
      if (cbPerson.checked) loadSegmentation();

      runLoop();
    }

    function stopCamera() {
      cancelAnimationFrame(rafId);
      if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
      videoTrack = null;
      btnShot.disabled = true;
      ctx.clearRect(0,0,overlay.width, overlay.height);
      // Zoom zur√ºck
      zoomRange.value = '1'; setZoom(1);
    }

    async function detectTorchSupport() {
      try {
        const caps = videoTrack?.getCapabilities?.();
        btnTorch.disabled = !(caps && 'torch' in caps);
      } catch { btnTorch.disabled = true; }
    }

    btnTorch.addEventListener('click', async () => {
      const track = videoTrack; if (!track) return;
      try {
        torchOn = !torchOn;
        await track.applyConstraints({ advanced:[{ torch: torchOn }] });
        btnTorch.textContent = torchOn ? 'üî¶ Taschenlampe AN' : 'üî¶ Taschenlampe';
      } catch (e) {
        console.warn('Torch not supported', e);
        alert('Taschenlampe wird von diesem Ger√§t/Kamera nicht unterst√ºtzt.');
      }
    });

    btnStart.addEventListener('click', startCamera);

    // ======= Speichern / Ordner =======
    btnChooseDir.addEventListener('click', chooseDirectory);
    async function chooseDirectory() {
      if (!window.showDirectoryPicker) {
        permFS.textContent = 'Dateizugriff: nicht unterst√ºtzt'; permFS.className = 'pill warn';
        alert('Ordnerwahl nicht unterst√ºtzt. Fallback: Downloads.');
        return;
      }
      try {
        dirHandle = await window.showDirectoryPicker({ mode:'readwrite', id:'tafel-capture' });
        const perm = await dirHandle.requestPermission({ mode:'readwrite' });
        if (perm === 'granted') {
          permFS.textContent = 'Dateizugriff: ok'; permFS.className = 'pill ok';
          document.getElementById('dirStatus').textContent = 'Ordner gew√§hlt';
          document.getElementById('dirStatus').className = 'pill ok';
        }
      } catch (e) { console.warn('chooseDirectory', e); }
    }

    async function saveBlob(name, blob) {
      if (dirHandle) {
        try {
          const fh = await dirHandle.getFileHandle(name, { create:true });
          const w  = await fh.createWritable(); await w.write(blob); await w.close();
          kvSaved.textContent = String(++savedCount);
          return true;
        } catch(e){ console.warn('write failed, fallback', e); }
      }
      if (cbUseDownloads.checked || !dirHandle) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = name; a.click();
        setTimeout(() => URL.revokeObjectURL(url), 2000);
        kvSaved.textContent = String(++savedCount);
        return true;
      }
      return false;
    }

    btnShot.addEventListener('click', async () => {
      const shot = await captureAndRectify();
      if (shot) await saveBlob(`tafel_${ts()}.jpg`, shot);
    });

    function ts(){
      const d = new Date(); const p = n => String(n).padStart(2,'0');
      return `${d.getFullYear()}-${p(d.getMonth()+1)}-${p(d.getDate())}_${p(d.getHours())}-${p(d.getMinutes())}-${p(d.getSeconds())}`;
    }

    // ======= Capture (Offscreen-Canvas; Overlay bleibt transparent) =======
    async function captureAndRectify() {
      if (!stream) return null;

      if ((!overlay.width || !overlay.height) && video.videoWidth) {
        overlay.width = video.videoWidth; overlay.height = video.videoHeight;
      }
      const w = overlay.width || video.videoWidth || 1280;
      const h = overlay.height|| video.videoHeight|| 720;

      const cap = document.createElement('canvas'); cap.width=w; cap.height=h;
      const capCtx = cap.getContext('2d', { willReadFrequently:true });
      capCtx.drawImage(video, 0, 0, w, h);

      let blob;
      if (cvReady && window.cv?.Mat) {
        const mat = cv.imread(cap);
        const quad = boardQuad; // schon im Loop berechnet
        let roi = quad ? warpToBoard(mat, quad) : mat.clone();
        const out = document.createElement('canvas'); out.width = roi.cols; out.height = roi.rows;
        cv.imshow(out, roi);
        blob = await new Promise(res => out.toBlob(res, 'image/jpeg', 0.9));
        mat.delete(); roi.delete();
      } else {
        blob = await new Promise(res => cap.toBlob(res, 'image/jpeg', 0.9));
      }
      return blob;
    }

    // ======= OpenCV laden (robust) =======
    function loadOpenCV() {
      if (cvReady || cvLoading) return; cvLoading = true;
      const s = document.createElement('script');
      // Stabiler Build inkl. WASM:
      s.src = 'https://cdn.jsdelivr.net/npm/@techstark/opencv-js@4.9.0-1/opencv.js';
      s.async = true; s.crossOrigin = 'anonymous';
      window.cv = window.cv || {};
      window.cv.onRuntimeInitialized = () => { cvReady = true; kvModel.textContent = 'OpenCV'; };
      s.onload = () => { if (window.cv?.Mat && !cvReady) { cvReady = true; kvModel.textContent = 'OpenCV'; } };
      s.onerror = () => { cvLoading = false; kvModel.textContent = 'OpenCV: Fehler beim Laden'; };
      document.head.appendChild(s);
    }

    // ======= (Optional) TF.js Personensegmentierung =======
    async function loadSegmentation() {
      if (segmenter) return segmenter;
      if (tfLoading) { while(!segmenter) await new Promise(r=>setTimeout(r,100)); return segmenter; }
      tfLoading = true;
      try {
        await import('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.16.0/dist/tf.min.js');
        const mod = await import('https://cdn.jsdelivr.net/npm/@tensorflow-models/body-segmentation@1.0.2/dist/body-segmentation.min.js');
        const bs = mod.bodySegmentation;
        segmenter = await bs.createSegmenter(bs.SupportedModels.MediaPipeSelfieSegmentation, {
          runtime:'tfjs', modelType:'landscape', enableSegmentationSmoothing:true
        });
        kvModel.textContent = (kvModel.textContent ? kvModel.textContent+' + ' : '') + 'SelfieSegmentation';
      } catch (e) {
        console.warn('TF load failed', e);
      }
      return segmenter;
    }
    cbPerson.addEventListener('change', () => { if (cbPerson.checked) loadSegmentation(); });

    // ======= Board-Tools (OpenCV) =======
    function orderQuad(pts){ pts.sort((a,b)=>a.y-b.y); const top=pts.slice(0,2).sort((a,b)=>a.x-b.x); const bot=pts.slice(2).sort((a,b)=>a.x-b.x); return [top[0],top[1],bot[1],bot[0]]; }
    function polygonArea(pts){ let a=0; for(let i=0;i<pts.length;i++){ const p=pts[i], q=pts[(i+1)%pts.length]; a += p.x*q.y - q.x*p.y; } return a/2; }
    function findBoardQuad(mat){
      const g = new cv.Mat(); cv.cvtColor(mat, g, cv.COLOR_RGBA2GRAY);
      cv.GaussianBlur(g, g, new cv.Size(5,5), 0);
      const e = new cv.Mat(); cv.Canny(g, e, 50, 150);
      const contours = new cv.MatVector(); const hier = new cv.Mat();
      cv.findContours(e, contours, hier, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);
      let best=null, bestArea=0;
      for (let i=0;i<contours.size();i++){
        const c = contours.get(i);
        const peri = cv.arcLength(c, true);
        const approx = new cv.Mat(); cv.approxPolyDP(c, approx, 0.02*peri, true);
        if (approx.rows===4 && cv.isContourConvex(approx)) {
          const pts=[]; for (let j=0;j<4;j++) pts.push({x: approx.intPtr(j,0)[0], y: approx.intPtr(j,0)[1]});
          const area = Math.abs(polygonArea(pts));
          if (area>bestArea){ bestArea=area; best=pts; }
        }
        c.delete();
      }
      g.delete(); e.delete(); contours.delete(); hier.delete();
      return best ? orderQuad(best) : null;
    }
    function warpToBoard(mat, quad){
      const [tl,tr,br,bl] = quad;
      const wA = Math.hypot(br.x-bl.x, br.y-bl.y), wB = Math.hypot(tr.x-tl.x, tr.y-tl.y);
      const hA = Math.hypot(tr.x-br.x, tr.y-br.y), hB = Math.hypot(tl.x-bl.x, tl.y-bl.y);
      const W = Math.max(320, Math.round(Math.max(wA,wB))), H = Math.max(240, Math.round(Math.max(hA,hB)));
      const src = cv.matFromArray(4,1,cv.CV_32FC2,[tl.x,tl.y,tr.x,tr.y,br.x,br.y,bl.x,bl.y]);
      const dst = cv.matFromArray(4,1,cv.CV_32FC2,[0,0,W,0,W,H,0,H]);
      const M = cv.getPerspectiveTransform(src,dst);
      const out = new cv.Mat(); cv.warpPerspective(mat, out, M, new cv.Size(W,H));
      src.delete(); dst.delete(); M.delete();
      return out;
    }
    function drawQuad(q){
      ctx.clearRect(0,0,overlay.width, overlay.height);
      if (!q) return;
      ctx.save();
      ctx.strokeStyle='rgba(76,201,240,0.9)'; ctx.lineWidth=3;
      ctx.beginPath(); ctx.moveTo(q[0].x,q[0].y); for(let i=1;i<4;i++) ctx.lineTo(q[i].x,q[i].y);
      ctx.closePath(); ctx.stroke(); ctx.restore();
    }

    // ======= Fallback-Tools (ohne OpenCV) =======
    function thumb64GrayFromCanvas(canvas){
      const tmp = document.createElement('canvas'); tmp.width=64; tmp.height=64;
      const tctx = tmp.getContext('2d'); tctx.drawImage(canvas, 0,0,64,64);
      const data = tctx.getImageData(0,0,64,64).data;
      const out = new Uint8Array(64*64);
      for (let i=0,j=0;i<data.length;i+=4,++j){
        out[j] = (data[i]*0.299 + data[i+1]*0.587 + data[i+2]*0.114) | 0;
      }
      return out;
    }
    function diffPercent(a,b){
      let sum=0; const n=a.length; for (let i=0;i<n;i++) sum += Math.abs(a[i]-b[i]);
      return (sum/(n*255))*100;
    }

    // ======= Main Loop =======
    async function runLoop(){
      const w = overlay.width || 1280, h = overlay.height || 720;
      const cap = document.createElement('canvas'); cap.width=w; cap.height=h; const capCtx = cap.getContext('2d');

      const tick = async () => {
        rafId = requestAnimationFrame(tick);
        if (!stream) return;

        // FPS-Anzeige
        frames++; const now = performance.now();
        if (now - lastTickT > 1000) { pillFPS.textContent = `${frames} FPS`; frames=0; lastTickT = now; }

        // alle 250ms erkennen
        const doDetect = (now - (tick.lastDetectT || 0)) > 250;
        if (!doDetect) return;
        tick.lastDetectT = now;

        capCtx.drawImage(video, 0,0,w,h);

        let changed = false;

        if (cvReady && window.cv?.Mat) {
          const mat = cv.imread(cap);
          const found = findBoardQuad(mat);
          boardQuad = found || null;
          kvBoard.textContent = found ? 'ja' : 'nein';
          drawQuad(boardQuad);

          if (cbSlide.checked) {
            const roi = boardQuad ? warpToBoard(mat, boardQuad) : mat;
            const th = (() => {
              const dst = new cv.Mat(); const size = new cv.Size(64,64);
              cv.resize(roi, dst, size, 0,0, cv.INTER_AREA);
              const gray = new cv.Mat(); cv.cvtColor(dst, gray, cv.COLOR_RGBA2GRAY);
              const out = new Uint8Array(64*64); out.set(gray.data);
              dst.delete(); gray.delete();
              return out;
            })();

            if (lastSlideThumb) {
              const dp = diffPercent(th, lastSlideThumb);
              const thr = parseFloat(slideThresh.value);
              const tStable = performance.now();
              if (dp > thr) {
                if (!tick.lastChangeT || (tStable - tick.lastChangeT) > 800) changed = true;
              } else {
                tick.lastChangeT = tStable;
              }
              document.getElementById('stateSlide').textContent = 'Folie: ' + (dp>thr ? `√Ñnderung (${dp.toFixed(1)}%)` : 'stabil');
              document.getElementById('stateSlide').className = 'pill mono ' + (dp>thr ? 'warn' : 'ok');
            } else {
              tick.lastChangeT = performance.now();
            }
            lastSlideThumb = th;
            if (roi !== mat) roi.delete();
          }
          if (mat) mat.delete();

        } else {
          // Fallback ohne OpenCV (keine Quad-Zeichnung, aber √Ñnderungs-Detect)
          kvBoard.textContent = '‚Äì';
          ctx.clearRect(0,0,overlay.width, overlay.height);

          if (cbSlide.checked) {
            const th = thumb64GrayFromCanvas(cap);
            if (lastSlideThumb) {
              const dp = diffPercent(th, lastSlideThumb);
              const thr = parseFloat(slideThresh.value);
              const tStable = performance.now();
              if (dp > thr) {
                if (!tick.lastChangeT || (tStable - tick.lastChangeT) > 800) changed = true;
              } else {
                tick.lastChangeT = tStable;
              }
              document.getElementById('stateSlide').textContent = 'Folie: ' + (dp>thr ? `√Ñnderung (${dp.toFixed(1)}%)` : 'stabil');
              document.getElementById('stateSlide').className = 'pill mono ' + (dp>thr ? 'warn' : 'ok');
            } else {
              tick.lastChangeT = performance.now();
            }
            lastSlideThumb = th;
          }
        }

        // (Optional) Personenerkennung
        if (cbPerson.checked && segmenter) {
          try {
            const seg = await segmenter.segmentPeople(video, { multiSegmentation:false });
            const any = seg && seg.length>0 && seg[0].mask;
            if (any) {
              const { data, width:mw, height:mh } = seg[0].mask;
              let cnt=0; for (let i=3;i<data.length;i+=4) if (data[i]>128) cnt++;
              const pct = (cnt/(mw*mh))*100;
              personPresent = pct > 1.5;
            } else personPresent = false;
            document.getElementById('statePerson').textContent = 'Person: ' + (personPresent?'ja':'nein');
            document.getElementById('statePerson').className = 'pill mono ' + (personPresent?'warn':'ok');
          } catch(e){ /* ignoriere */ }
        } else {
          personPresent = false;
          document.getElementById('statePerson').textContent = 'Person: unbekannt';
          document.getElementById('statePerson').className = 'pill mono';
        }

        // Auto-Foto NUR wenn gew√ºnscht
        if (cbAutoCap.checked && changed && (!cbPerson.checked || !personPresent)) {
          const blob = await captureAndRectify();
          if (blob) await saveBlob(`tafel_${ts()}.jpg`, blob);
        }
      };
      tick();
    }

    // ======= Events & Init =======
    permCam.textContent = 'Kamera: ?'; permCam.className = 'pill mono';
    permFS.textContent  = 'Dateizugriff: ?'; permFS.className = 'pill mono';

    if (!window.isSecureContext && location.hostname!=='localhost') {
      alert('Hinweis: Kamera funktioniert nur √ºber HTTPS oder http://localhost');
    }
  })();
  </script>
</body>
</html>
