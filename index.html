
<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>TafelCapture ‚Äì Android 15</title>
<style>
  :root{
    --bg:#0f1115; --fg:#e8eaf0; --muted:#9aa3b2; --accent:#4cc9f0; --ok:#2ecc71; --warn:#f1c40f; --err:#e74c3c;
    --card:#161a22; --border:#283042; --zoom:1;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:var(--bg);color:var(--fg)}
  .app{display:grid;gap:.75rem;padding:.75rem;height:100dvh}
  @media (orientation:portrait){
    .app{grid-template-rows:auto 1fr auto;grid-template-columns:1fr}
    .controls-top{grid-row:1}
    .stage{grid-row:2}
    .controls-bottom{grid-row:3}
  }
  @media (orientation:landscape){
    .app{grid-template-columns:1fr 360px;grid-template-rows:1fr auto}
    .stage{grid-column:1;grid-row:1 / span 2}
    .controls-top{grid-column:2;grid-row:1}
    .controls-bottom{grid-column:2;grid-row:2}
  }
  .card{background:var(--card);border:1px solid var(--border);border-radius:10px;padding:.75rem}
  .row{display:flex;gap:.5rem;flex-wrap:wrap;align-items:center;margin:.5rem 0}
  .btn{background:#1f2633;color:var(--fg);border:1px solid var(--border);border-radius:8px;padding:.55rem .8rem;cursor:pointer}
  .btn.primary{background:linear-gradient(180deg,#2a3446,#1e2635);border-color:#3a4a66}
  .btn:disabled{opacity:.5;cursor:not-allowed}
  .toggle{display:flex;align-items:center;gap:.4rem}
  .select{appearance:none;background:#1f2633;border:1px solid var(--border);color:var(--fg);padding:.5rem .8rem;border-radius:8px}
  .pill{display:inline-flex;align-items:center;gap:.4rem;padding:.15rem .5rem;border-radius:999px;font-size:.85rem;border:1px solid var(--border)}
  .pill.ok{color:var(--ok)} .pill.warn{color:var(--warn)} .pill.err{color:var(--err)}
  .sep{height:1px;background:var(--border);margin:.5rem 0}
  .status{display:grid;grid-template-columns:1fr 1fr;gap:.35rem;font-size:.9rem;color:var(--muted)}
  .status .kv{display:flex;justify-content:space-between;gap:.75rem;background:#11151d;border:1px solid var(--border);border-radius:8px;padding:.35rem .5rem}

  /* B√ºhne */
  .stage{position:relative;overflow:hidden;min-height:50dvh}
  video,canvas{width:100%;height:100%;object-fit:cover;border-radius:10px;touch-action:none}
  #preview{position:absolute;inset:0;z-index:0;background:#000;transform:scale(var(--zoom));transform-origin:center center}
  #overlay{position:absolute;inset:0;z-index:1;pointer-events:none;background:transparent !important;transform:scale(var(--zoom));transform-origin:center center}

  /* Zoom-Leiste */
  .zoombar{position:absolute;left:.75rem;right:.75rem;bottom:.75rem;z-index:2;
           display:flex;gap:.5rem;align-items:center;justify-content:center;
           background:rgba(0,0,0,.35);backdrop-filter:blur(2px);border-radius:10px;padding:.35rem .6rem}
  .zoombar input[type="range"]{width:220px}
  .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
</style>
</head>
<body>
<div class="app">
  <div class="stage card" id="stage">
    <video id="preview" playsinline autoplay muted></video>
    <canvas id="overlay"></canvas>

    <!-- Zoom -->
    <div class="zoombar">
      <label class="toggle" style="color:#e8eaf0">
        üîé Zoom
        <input type="range" id="zoomRange" min="1" max="5" step="0.1" value="1">
      </label>
      <span id="zoomVal" class="pill mono">1.0√ó</span>
    </div>
  </div>

  <div class="controls-top card">
    <h2 style="margin:0 0 .25rem;color:#9aa3b2">Aufnahme &amp; Ordner</h2>
    <div class="row">
      <button class="btn primary" id="btnStart">Kamera starten</button>
      <select id="lensSelect" class="select" title="Kamera w√§hlen" disabled>
        <option>‚Äì Kamera wird geladen ‚Äì</option>
      </select>
      <button class="btn" id="btnTorch" disabled>üî¶ Taschenlampe</button>
      <button class="btn" id="btnShot" disabled>üì∏ Manuell</button>
      <button class="btn" id="btnMark">üéØ Tafel manuell markieren</button>
    </div>
    <div class="row">
      <button class="btn" id="btnChooseDir">üìÅ Ordner w√§hlen</button>
      <span id="dirStatus" class="pill warn">kein Ordner</span>
      <label class="toggle"><input type="checkbox" id="cbUseDownloads"> Fallback: Downloads nutzen</label>
    </div>
    <div class="row">
      <span class="pill mono" id="permCam">Kamera: ?</span>
      <span class="pill mono" id="permFS">Dateizugriff: ?</span>
      <span class="pill mono" id="pillFPS">0 FPS</span>
    </div>

    <div class="sep"></div>
    <h2 style="margin:0 0 .25rem;color:#9aa3b2">Erkennung</h2>
    <div class="row">
      <label class="toggle"><input type="checkbox" id="cbPerson" checked> Personen auf der Tafel blockieren</label>
      <label class="toggle"><input type="checkbox" id="cbSlide" checked> Folien‚Äë√Ñnderung (nur Tafel‚ÄëROI)</label>
      <!-- NICHT voraktiviert -->
      <label class="toggle"><input type="checkbox" id="cbAutoCap"> Auto‚ÄëFoto bei Folienwechsel</label>
    </div>
    <div class="row">
      <label>Schwellwert √Ñnderung:
        <input type="range" id="slideThresh" min="5" max="40" value="12"> <span id="slideVal">12%</span>
      </label>
    </div>
    <div class="row">
      <span id="statePerson" class="pill mono">Person: unbekannt</span>
      <span id="stateSlide" class="pill mono">Folie: stabil</span>
    </div>
  </div>

  <div class="controls-bottom card">
    <h2 style="margin:0 0 .25rem;color:#9aa3b2">Status</h2>
    <div class="status">
      <div class="kv"><span>Board erkannt</span><span id="kvBoard">‚Äì</span></div>
      <div class="kv"><span>Aufl√∂sung</span><span id="kvRes">‚Äì</span></div>
      <div class="kv"><span>Modell</span><span id="kvModel">‚Äì</span></div>
      <div class="kv"><span>Gespeichert</span><span id="kvSaved">0</span></div>
    </div>
    <div class="sep"></div>
    <small>Hinweis: Kamera-Zugriff funktioniert nur √ºber <code>https://</code> oder <code>http://localhost</code>. Auf Android per Chrome empfohlen.</small>
  </div>
</div>

<script>
(function(){
  // ---------- DOM ----------
  const $ = s => document.querySelector(s);
  const stage = $('#stage');
  const video = $('#preview');
  const overlay = $('#overlay'); const ctx = overlay.getContext('2d');

  const btnStart = $('#btnStart'), lensSelect = $('#lensSelect'), btnTorch = $('#btnTorch');
  const btnShot = $('#btnShot'), btnMark = $('#btnMark'), btnChooseDir = $('#btnChooseDir');
  const cbUseDownloads = $('#cbUseDownloads');

  const cbPerson = $('#cbPerson'), cbSlide = $('#cbSlide'), cbAutoCap = $('#cbAutoCap');
  const slideThresh = $('#slideThresh'), slideVal = $('#slideVal');

  const permCam = $('#permCam'), permFS = $('#permFS'), pillFPS = $('#pillFPS');
  const kvBoard = $('#kvBoard'), kvRes = $('#kvRes'), kvModel = $('#kvModel'), kvSaved = $('#kvSaved');

  const zoomRange = $('#zoomRange'), zoomVal = $('#zoomVal');

  // ---------- State ----------
  let stream = null, videoTrack = null, torchOn = false, selectedDeviceId = null;
  let dirHandle = null, savedCount = 0;

  let cvReady = false, cvLoading = false;
  let segmenter = null, tfLoading = false;

  // boardQuad: [tl,tr,br,bl] in Video-Pixelkoordinaten
  let boardQuadAuto = null;          // von OpenCV
  let boardQuadManual = null;        // vom Nutzer
  let lastThumb = null;              // Uint8Array 64*64 (ROI)
  let lastChangeGateT = 0;
  let personOnBoard = false;

  // Perf
  let rafId = 0, fpsFrames = 0, fpsT = performance.now();

  // ---------- UI Helpers ----------
  function setZoom(z){ stage.style.setProperty('--zoom', z); zoomVal.textContent = z.toFixed(1)+'√ó'; }
  zoomRange.addEventListener('input', () => setZoom(parseFloat(zoomRange.value)||1));
  setZoom(1);

  slideVal.textContent = slideThresh.value + '%';
  slideThresh.addEventListener('input', () => slideVal.textContent = slideThresh.value + '%');

  function resizeOverlayToVideo(){
    if (video.videoWidth && video.videoHeight) {
      overlay.width = video.videoWidth;
      overlay.height= video.videoHeight;
      kvRes.textContent = `${overlay.width}√ó${overlay.height}`;
    }
  }
  window.addEventListener('resize', resizeOverlayToVideo);
  window.addEventListener('orientationchange', () => setTimeout(resizeOverlayToVideo, 150));

  // ---------- Kamera ----------
  async function startCamera(deviceId){
    stopCamera();
    video.setAttribute('playsinline',''); video.muted = true; video.autoplay = true;

    if (!navigator.mediaDevices?.getUserMedia) {
      permCam.textContent = 'Kamera: nicht unterst√ºtzt'; permCam.className = 'pill err';
      alert('getUserMedia wird nicht unterst√ºtzt.'); return;
    }

    const base = { audio:false, video:{ facingMode:{ideal:'environment'}, width:{ideal:1920}, height:{ideal:1080} } };
    if (deviceId) base.video.deviceId = { exact: deviceId };

    try { stream = await navigator.mediaDevices.getUserMedia(base); }
    catch(e1){ console.warn('preferred gUM failed', e1); stream = await navigator.mediaDevices.getUserMedia({ video:true, audio:false }); }

    video.srcObject = stream;
    videoTrack = stream.getVideoTracks()[0];

    // Kameraliste
    await populateCameras();

    // Torch & HW‚ÄëZoom
    detectTorchSupport(); setupHardwareZoom();

    const applyMeta = () => { resizeOverlayToVideo(); };
    if (video.readyState >= 1) applyMeta(); else video.addEventListener('loadedmetadata', applyMeta, { once:true });

    try { await video.play(); } catch(e){ console.warn('video.play blocked:', e); }

    btnShot.disabled = false; permCam.textContent = 'Kamera: ok'; permCam.className = 'pill ok';

    // Libs laden
    loadOpenCV(); if (cbPerson.checked) loadSegmentation();

    runLoop();
  }

  function stopCamera(){
    cancelAnimationFrame(rafId);
    if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
    videoTrack = null; btnShot.disabled = true;
    ctx.clearRect(0,0,overlay.width, overlay.height);
    boardQuadAuto = null; lastThumb = null; personOnBoard = false;
    zoomRange.value = '1'; setZoom(1);
  }

  async function populateCameras(){
    try{
      const devices = await navigator.mediaDevices.enumerateDevices();
      const cams = devices.filter(d => d.kind === 'videoinput');
      const rank = l => { const L=(l||'').toLowerCase();
        if (L.includes('tele')) return 3; if (L.includes('back')&&(L.includes('aux')||L.includes('camera 2')||L.includes('camera3'))) return 2;
        if (L.includes('ultra')||L.includes('wide')) return 1; return 0 };
      cams.sort((a,b)=>rank(b.label)-rank(a.label));
      lensSelect.innerHTML=''; cams.forEach(c=>{ const o=document.createElement('option'); o.value=c.deviceId; o.textContent=c.label||`Kamera ${lensSelect.length+1}`; lensSelect.appendChild(o); });
      lensSelect.disabled = cams.length===0;
      if (selectedDeviceId) lensSelect.value = selectedDeviceId;
    }catch(e){ console.warn('enumerateDevices', e); }
  }
  lensSelect.addEventListener('change', async ()=>{ selectedDeviceId = lensSelect.value; await startCamera(selectedDeviceId); });

  function detectTorchSupport(){
    try { const caps = videoTrack?.getCapabilities?.(); btnTorch.disabled = !(caps && 'torch' in caps); }
    catch { btnTorch.disabled = true; }
  }
  function setupHardwareZoom(){
    try {
      const caps = videoTrack?.getCapabilities?.();
      if (caps && caps.zoom && (typeof caps.zoom==='number' || caps.zoom.max)){
        const min=caps.zoom.min??1, max=caps.zoom.max??5, step=caps.zoom.step??0.1;
        zoomRange.min=String(min); zoomRange.max=String(Math.max(5,max)); zoomRange.step=String(step);
        const cur=videoTrack.getSettings?.().zoom ?? 1; zoomRange.value=String(cur); setZoom(parseFloat(zoomRange.value)||1);
        zoomRange.oninput = async ()=>{ const v=Number(zoomRange.value); setZoom(v); try{ await videoTrack.applyConstraints({ advanced:[{ zoom:v }] }); }catch(e){} };
      } else { zoomRange.min='1'; zoomRange.max='5'; zoomRange.step='0.1'; zoomRange.oninput=()=>setZoom(parseFloat(zoomRange.value)||1); }
    }catch{ zoomRange.oninput=()=>setZoom(parseFloat(zoomRange.value)||1); }
  }

  let pinchD0=0, zoom0=1;
  stage.addEventListener('touchstart',e=>{ if(e.touches.length===2){ pinchD0=dist(e.touches[0],e.touches[1]); zoom0=parseFloat(zoomRange.value)||1; }},{passive:true});
  stage.addEventListener('touchmove', e=>{ if(e.touches.length===2){ const d=dist(e.touches[0],e.touches[1]); const f=d/pinchD0; const z=Math.min(parseFloat(zoomRange.max),Math.max(parseFloat(zoomRange.min),zoom0*f)); zoomRange.value=String(z); setZoom(z);}},{passive:true});
  function dist(a,b){ const dx=a.clientX-b.clientX, dy=a.clientY-b.clientY; return Math.hypot(dx,dy); }

  btnTorch.addEventListener('click', async ()=>{ const t=videoTrack; if(!t) return; try{ torchOn=!torchOn; await t.applyConstraints({ advanced:[{ torch:torchOn }] }); btnTorch.textContent = torchOn?'üî¶ Taschenlampe AN':'üî¶ Taschenlampe'; }catch(e){ alert('Taschenlampe wird nicht unterst√ºtzt.'); } });
  btnStart.addEventListener('click', ()=>startCamera(selectedDeviceId));

  // ---------- Ordner & Speichern ----------
  btnChooseDir.addEventListener('click', chooseDirectory);
  async function chooseDirectory(){
    if (!window.showDirectoryPicker) { permFS.textContent='Dateizugriff: nicht unterst√ºtzt'; permFS.className='pill warn'; alert('Ordnerwahl nicht unterst√ºtzt. Fallback: Downloads.'); return; }
    try {
      dirHandle = await window.showDirectoryPicker({ mode:'readwrite', id:'tafel-capture' });
      const perm = await dirHandle.requestPermission({ mode:'readwrite' });
      if (perm==='granted'){ permFS.textContent='Dateizugriff: ok'; permFS.className='pill ok'; document.getElementById('dirStatus').textContent='Ordner gew√§hlt'; document.getElementById('dirStatus').className='pill ok'; }
    }catch(e){ console.warn('chooseDirectory', e); }
  }
  async function saveBlob(name, blob){
    if (dirHandle){
      try{ const fh=await dirHandle.getFileHandle(name,{create:true}); const w=await fh.createWritable(); await w.write(blob); await w.close(); kvSaved.textContent=String(++savedCount); return true; }
      catch(e){ console.warn('write failed, fallback', e); }
    }
    if (cbUseDownloads.checked || !dirHandle){ const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=name; a.click(); setTimeout(()=>URL.revokeObjectURL(url),2000); kvSaved.textContent=String(++savedCount); return true; }
    return false;
  }
  btnShot.addEventListener('click', async ()=>{ const shot=await captureAndRectify(); if (shot) await saveBlob(`tafel_${ts()}.jpg`, shot); });
  function ts(){ const d=new Date(), p=n=>String(n).padStart(2,'0'); return `${d.getFullYear()}-${p(d.getMonth()+1)}-${p(d.getDate())}_${p(d.getHours())}-${p(d.getMinutes())}-${p(d.getSeconds())}`; }

  // ---------- Manuelles Board (ohne OpenCV) ----------
  btnMark.addEventListener('click', enterManualMarkMode);
  function enterManualMarkMode(){
    // Nutzer tippt 4 Ecken im Uhrzeigersinn (TL, TR, BR, BL) ‚Äì wir sammeln im Video‚ÄëPixelraum
    const pts = [];
    const onClick = (ev)=>{
      // Koordinaten in Video-Pixel umrechnen (weil object-fit: cover)
      const rect = overlay.getBoundingClientRect();
      const xCss = ev.clientX - rect.left, yCss = ev.clientY - rect.top;
      const [sx, sy] = cssToVideoCoords(xCss, yCss);
      pts.push({x:sx, y:sy});
      drawTempPts(pts);
      if (pts.length===4){
        overlay.removeEventListener('click', onClick);
        boardQuadManual = orderQuad(pts.slice());
        boardQuadAuto = null;             // manuelle setzt auto au√üer Kraft
        drawQuad(boardQuadManual);
        kvBoard.textContent = 'ja (manuell)';
      }
    };
    overlay.addEventListener('click', onClick);
    alert('Tippe 4 Ecken der Tafel: oben‚Äëlinks ‚Üí oben‚Äërechts ‚Üí unten‚Äërechts ‚Üí unten‚Äëlinks');
  }
  function drawTempPts(pts){
    ctx.clearRect(0,0,overlay.width, overlay.height);
    ctx.fillStyle='rgba(76,201,240,.9)'; ctx.strokeStyle='rgba(76,201,240,.9)'; ctx.lineWidth=2;
    pts.forEach(p=>{ ctx.beginPath(); ctx.arc(p.x,p.y,6,0,Math.PI*2); ctx.fill(); });
    if (pts.length>1){ ctx.beginPath(); ctx.moveTo(pts[0].x,pts[0].y); for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x,pts[i].y); ctx.stroke(); }
  }

  // ---------- Capture (nur ROI Tafel) ----------
  async function captureAndRectify(){
    const quad = boardQuadManual || boardQuadAuto;
    if (!stream || !quad) return null;

    const w = overlay.width || video.videoWidth || 1280;
    const h = overlay.height|| video.videoHeight|| 720;
    // Offscreen-Frame
    const cap = document.createElement('canvas'); cap.width=w; cap.height=h;
    const capCtx = cap.getContext('2d', { willReadFrequently:true });
    drawVideoFullFrame(capCtx, w, h);

    if (cvReady && window.cv?.Mat){
      const mat = cv.imread(cap);
      const roi = warpToBoard(mat, quad);
      const out = document.createElement('canvas'); out.width=roi.cols; out.height=roi.rows;
      cv.imshow(out, roi);
      const blob = await new Promise(res=>out.toBlob(res,'image/jpeg',0.9));
      mat.delete(); roi.delete(); return blob;
    } else {
      // JS‚ÄëWarp (64*64 upscaled) ‚Äì gen√ºgt f√ºr Auto‚ÄëShots; f√ºr manuell erzeugen wir 1024px breite ROI
      const outW = 1024, outH = Math.round(outW*0.6);
      const out = document.createElement('canvas'); out.width=outW; out.height=outH;
      warpQuadCanvasNearest(capCtx, w, h, quad, out.getContext('2d'), outW, outH);
      const blob = await new Promise(res=>out.toBlob(res,'image/jpeg',0.9));
      return blob;
    }
  }

  // ---------- OpenCV laden ----------
  function loadOpenCV(){
    if (cvReady || cvLoading) return; cvLoading = true;
    const s = document.createElement('script');
    s.src = 'https://cdn.jsdelivr.net/npm/@techstark/opencv-js@4.9.0-1/opencv.js';
    s.async = true; s.crossOrigin='anonymous';
    window.cv = window.cv || {};
    window.cv.onRuntimeInitialized = () => { cvReady = true; kvModel.textContent = 'OpenCV'; };
    s.onload = () => { if (window.cv?.Mat && !cvReady){ cvReady=true; kvModel.textContent='OpenCV'; } };
    s.onerror = () => { cvLoading = false; kvModel.textContent = 'OpenCV: Ladefehler'; };
    document.head.appendChild(s);
  }

  // ---------- TF.js Personen ----------
  async function loadSegmentation(){
    if (segmenter) return segmenter;
    if (tfLoading) { while(!segmenter) await new Promise(r=>setTimeout(r,120)); return segmenter; }
    tfLoading = true;
    try {
      await import('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.16.0/dist/tf.min.js');
      const mod = await import('https://cdn.jsdelivr.net/npm/@tensorflow-models/body-segmentation@1.0.2/dist/body-segmentation.min.js');
      const bs = mod.bodySegmentation;
      segmenter = await bs.createSegmenter(bs.SupportedModels.MediaPipeSelfieSegmentation, {
        runtime:'tfjs', modelType:'landscape', enableSegmentationSmoothing:true
      });
      kvModel.textContent = (kvModel.textContent ? kvModel.textContent+' + ' : '') + 'SelfieSeg';
    } catch (e) { console.warn('TF load failed', e); }
    return segmenter;
  }
  cbPerson.addEventListener('change', ()=>{ if (cbPerson.checked) loadSegmentation(); });

  // ---------- Board‚ÄëTools (OpenCV & JS) ----------
  function orderQuad(pts){ pts.sort((a,b)=>a.y-b.y); const top=pts.slice(0,2).sort((a,b)=>a.x-b.x); const bot=pts.slice(2).sort((a,b)=>a.x-b.x); return [top[0],top[1],bot[1],bot[0]]; }
  function polygonArea(pts){ let a=0; for(let i=0;i<pts.length;i++){ const p=pts[i], q=pts[(i+1)%pts.length]; a += p.x*q.y - q.x*p.y; } return a/2; }

  function findBoardQuadCV(mat){
    const g = new cv.Mat(); cv.cvtColor(mat, g, cv.COLOR_RGBA2GRAY);
    cv.GaussianBlur(g, g, new cv.Size(5,5), 0);
    const e = new cv.Mat(); cv.Canny(g, e, 50, 150);
    const contours = new cv.MatVector(); const hier = new cv.Mat();
    cv.findContours(e, contours, hier, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);
    let best=null, bestArea=0;
    for (let i=0;i<contours.size();i++){
      const c=contours.get(i);
      const peri=cv.arcLength(c,true);
      const approx=new cv.Mat(); cv.approxPolyDP(c,approx,0.02*peri,true);
      if (approx.rows===4 && cv.isContourConvex(approx)) {
        const pts=[]; for (let j=0;j<4;j++) pts.push({x:approx.intPtr(j,0)[0], y:approx.intPtr(j,0)[1]});
        const area=Math.abs(polygonArea(pts));
        if (area>bestArea){ bestArea=area; best=pts; }
      }
      c.delete(); approx.delete();
    }
    g.delete(); e.delete(); contours.delete(); hier.delete();
    return best ? orderQuad(best) : null;
  }
  function warpToBoard(mat, quad){
    const [tl,tr,br,bl]=quad;
    const wA=Math.hypot(br.x-bl.x, br.y-bl.y), wB=Math.hypot(tr.x-tl.x, tr.y-tl.y);
    const hA=Math.hypot(tr.x-br.x, tr.y-br.y), hB=Math.hypot(tl.x-bl.x, tl.y-bl.y);
    const W=Math.max(320,Math.round(Math.max(wA,wB))), H=Math.max(240,Math.round(Math.max(hA,hB)));
    const src=cv.matFromArray(4,1,cv.CV_32FC2,[tl.x,tl.y,tr.x,tr.y,br.x,br.y,bl.x,bl.y]);
    const dst=cv.matFromArray(4,1,cv.CV_32FC2,[0,0,W,0,W,H,0,H]);
    const M=cv.getPerspectiveTransform(src,dst); const out=new cv.Mat();
    cv.warpPerspective(mat,out,M,new cv.Size(W,H));
    src.delete(); dst.delete(); M.delete(); return out;
  }
  function drawQuad(q){
    ctx.clearRect(0,0,overlay.width, overlay.height);
    if (!q) return;
    ctx.save(); ctx.strokeStyle='rgba(76,201,240,0.95)'; ctx.lineWidth=3;
    ctx.beginPath(); ctx.moveTo(q[0].x,q[0].y); for(let i=1;i<4;i++) ctx.lineTo(q[i].x,q[i].y);
    ctx.closePath(); ctx.stroke(); ctx.restore();
  }

  // ---------- JS‚ÄëFallback: ROI‚ÄëThumb & Warp ohne OpenCV ----------
  function drawVideoFullFrame(targetCtx, w, h){
    // Da CSS "cover" nutzt, zeichnen wir das gesamte Video in genau die Overlay‚ÄëGr√∂√üe
    targetCtx.drawImage(video, 0, 0, w, h);
  }
  // Map (u,v)‚àà[0,1]¬≤ -> Punkt im Quad (tl,tr,br,bl) ‚Äì bilinear
  function quadMap(quad, u, v){
    const [tl,tr,br,bl]=quad;
    const x = tl.x*(1-u)*(1-v) + tr.x*u*(1-v) + br.x*u*v + bl.x*(1-u)*v;
    const y = tl.y*(1-u)*(1-v) + tr.y*u*(1-v) + br.y*u*v + bl.y*(1-u)*v;
    return [x,y];
  }
  function sampleThumbFromQuad(ctxSrc, srcW, srcH, quad, size=64){
    const img = ctxSrc.getImageData(0,0,srcW,srcH).data;
    const thumb = new Uint8Array(size*size);
    for(let j=0;j<size;j++){
      for(let i=0;i<size;i++){
        const u=i/(size-1), v=j/(size-1);
        const [x,y]=quadMap(quad,u,v);
        const xi=Math.max(0,Math.min(srcW-1, Math.round(x)));
        const yi=Math.max(0,Math.min(srcH-1, Math.round(y)));
        const idx=(yi*srcW+xi)*4;
        const r=img[idx], g=img[idx+1], b=img[idx+2];
        thumb[j*size+i] = (0.299*r+0.587*g+0.114*b)|0;
      }
    }
    return thumb;
  }
  function warpQuadCanvasNearest(ctxSrc, srcW, srcH, quad, ctxDst, outW, outH){
    const srcImg = ctxSrc.getImageData(0,0,srcW,srcH).data;
    const out = ctxDst.createImageData(outW,outH);
    const dst = out.data;
    for(let y=0;y<outH;y++){
      const v = y/(outH-1);
      for(let x=0;x<outW;x++){
        const u = x/(outW-1);
        const [sx,sy]=quadMap(quad,u,v);
        const xi=Math.max(0,Math.min(srcW-1, Math.round(sx)));
        const yi=Math.max(0,Math.min(srcH-1, Math.round(sy)));
        const sidx=(yi*srcW+xi)*4, didx=(y*outW+x)*4;
        dst[didx]=srcImg[sidx]; dst[didx+1]=srcImg[sidx+1]; dst[didx+2]=srcImg[sidx+2]; dst[didx+3]=255;
      }
    }
    ctxDst.putImageData(out,0,0);
  }

  function diffPercent(a,b){
    let sum=0; const n=a.length; for (let i=0;i<n;i++) sum += Math.abs(a[i]-b[i]);
    return (sum/(n*255))*100;
  }

  // CSS‚ÄëKoordinate -> Video‚ÄëPixel (weil "cover")
  function cssToVideoCoords(xCss, yCss){
    const cw = overlay.clientWidth, ch = overlay.clientHeight;
    const vw = overlay.width || video.videoWidth, vh = overlay.height || video.videoHeight;
    // Bei cover: gleiche Skalierung in beide Richtungen, aber mit Zuschnitt
    const scale = Math.max(cw/vw, ch/vh);
    const scaledW = vw*scale, scaledH = vh*scale;
    const offsetX = (scaledW - cw)/2, offsetY = (scaledH - ch)/2;
    const vx = (xCss + offsetX) / scale;
    const vy = (yCss + offsetY) / scale;
    return [Math.max(0,Math.min(vw-1,vx)), Math.max(0,Math.min(vh-1,vy))];
  }

  // ---------- Main Loop ----------
  async function runLoop(){
    const tick = async ()=>{
      rafId = requestAnimationFrame(tick);
      if (!stream) return;

      // FPS
      fpsFrames++; const now=performance.now(); if (now - fpsT > 1000) { pillFPS.textContent=`${fpsFrames} FPS`; fpsFrames=0; fpsT=now; }

      // alle 300ms
      if (!tick.lastT || (now - tick.lastT) > 300){
        tick.lastT = now;

        const w = overlay.width || video.videoWidth || 1280;
        const h = overlay.height|| video.videoHeight|| 720;
        const cap = document.createElement('canvas'); cap.width=w; cap.height=h;
        const capCtx = cap.getContext('2d');
        drawVideoFullFrame(capCtx, w, h);

        let quad = boardQuadManual || null;

        if (!quad && cvReady && window.cv?.Mat){
          const mat = cv.imread(cap);
          const found = findBoardQuadCV(mat);
          if (found){ boardQuadAuto = found; kvBoard.textContent='ja'; } else { kvBoard.textContent='nein'; }
          quad = boardQuadManual || boardQuadAuto || null;
          drawQuad(quad);
          mat.delete();
        } else {
          // ohne CV nur manuelle Kontur anzeigen
          drawQuad(quad);
          if (!quad) { kvBoard.textContent = '‚Äì (keine Board‚ÄëROI)'; }
        }

        // Personen (nur grob, blockiert Auto‚ÄëFoto)
        personOnBoard = false;
        if (cbPerson.checked && segmenter){
          try {
            const seg = await segmenter.segmentPeople(video, { multiSegmentation:false });
            if (seg && seg.length>0 && seg[0].mask){
              // einfacher globaler Anteil; reicht f√ºr H√§nde/Kopf deutlich auf der Tafel
              const m=seg[0].mask; let cnt=0; for(let i=3;i<m.data.length;i+=4) if (m.data[i]>128) cnt++;
              const pct=(cnt/(m.width*m.height))*100; personOnBoard = pct>3.0;
            }
          } catch {}
        }
        document.getElementById('statePerson').textContent='Person: '+(personOnBoard?'ja':'nein');
        document.getElementById('statePerson').className='pill mono '+(personOnBoard?'warn':'ok');

        // Slide‚Äë√Ñnderung NUR auf ROI
        let changed=false;
        if (cbSlide.checked && quad){
          const thumb = cvReady && window.cv?.Mat
            ? (function(){ // 64x64 aus ROI via OpenCV
                const mat=cv.imread(cap); const roi=warpToBoard(mat, quad);
                const dst=new cv.Mat(); cv.resize(roi,dst,new cv.Size(64,64),0,0,cv.INTER_AREA);
                const gray=new cv.Mat(); cv.cvtColor(dst,gray,cv.COLOR_RGBA2GRAY);
                const out=new Uint8Array(64*64); out.set(gray.data);
                mat.delete(); roi.delete(); dst.delete(); gray.delete(); return out;
              })()
            : sampleThumbFromQuad(capCtx, w, h, quad, 64);

          if (lastThumb){
            const dp = diffPercent(thumb, lastThumb);
            const thr = parseFloat(slideThresh.value);
            document.getElementById('stateSlide').textContent = 'Folie: ' + (dp>thr ? `√Ñnderung (${dp.toFixed(1)}%)` : 'stabil');
            document.getElementById('stateSlide').className = 'pill mono ' + (dp>thr ? 'warn' : 'ok');
            if (dp>thr && (now - lastChangeGateT) > 800){ changed=true; lastChangeGateT=now; }
          } else {
            lastChangeGateT = now;
          }
          lastThumb = thumb;
        } else {
          document.getElementById('stateSlide').textContent = quad ? 'Folie: stabil' : 'Folie: ‚Äì (keine Board‚ÄëROI)';
          document.getElementById('stateSlide').className = 'pill mono';
        }

        // Auto‚ÄëFoto nur wenn explizit an, Board vorhanden, √Ñnderung in ROI, und (optional) keine Person auf Tafel
        if (cbAutoCap.checked && changed && quad && (!cbPerson.checked || !personOnBoard)){
          const blob = await captureAndRectify(); if (blob) await saveBlob(`tafel_${ts()}.jpg`, blob);
        }
      }
    };
    tick();
  }

  // ---------- Init ----------
  btnStart.disabled=false;
  permCam.textContent='Kamera: ?'; permCam.className='pill mono';
  permFS.textContent ='Dateizugriff: ?'; permFS.className='pill mono';

  if (!window.isSecureContext && location.hostname!=='localhost') {
    alert('Hinweis: Kamera funktioniert nur √ºber HTTPS oder http://localhost');
  }
})();
</script>
</body>
</html>
