<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,height=device-height,initial-scale=1,viewport-fit=cover,user-scalable=no" />
<meta name="theme-color" content="#0b0e13">
<title>TafelCapture ‚Äì PureJS</title>
<meta name="description" content="Tafel/Whiteboard automatisch erkennen und entzerrt speichern ‚Äì komplett im Browser (ohne OpenCV).">
<style>
  :root{
    color-scheme: dark;
    --bg:#0b0e13; --fg:#e9eef5; --muted:#a7b3c0; --accent:#4ea1ff;
    --ok:#11c46a; --warn:#ffb020; --bad:#ff4d6d;
    --bar:#0f131acc; --bar-border:#1a212c; --chip:#16202c;
  }
  html,body{margin:0;padding:0;background:var(--bg);color:var(--fg);
    font-family:system-ui,"Segoe UI",Roboto,Ubuntu,sans-serif;height:100%;
    -webkit-text-size-adjust:100%;
  }
  #app{display:grid;grid-template-rows:auto 1fr auto auto;min-height:100svh}
  header{
    display:flex;flex-wrap:wrap;gap:.5rem;align-items:center;
    padding:.5rem .75rem;background:#0f131a;border-bottom:1px solid var(--bar-border)
  }
  header .group{display:flex;gap:.5rem;align-items:center;flex-wrap:wrap}
  button,select,label.chip{
    background:var(--chip);color:var(--fg);border:1px solid #223041;border-radius:.55rem;
    padding:.5rem .65rem;font-size:.95rem;line-height:1;min-height:2.25rem
  }
  button.primary{background:#1a2b3f;border-color:#2a4060}
  .kpi{font-variant-numeric:tabular-nums;color:var(--muted)} .kpi b{color:var(--fg)}
  .spacer{flex:1}
  #stage{position:relative;background:#000;overflow:hidden}
  video,canvas#overlay{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;transform-origin:center}
  canvas#overlay{pointer-events:none}
  #banner{
    position:absolute;left:50%;top:calc(8px + env(safe-area-inset-top));
    transform:translateX(-50%);background:rgba(0,0,0,.85);
    border:1px solid #263445;border-radius:.5rem;padding:.5rem .7rem;font-size:.95rem;
    z-index:5;display:none
  }
  #bottomBar{
    display:flex;flex-wrap:wrap;gap:.5rem;align-items:center;
    padding:.55rem .75rem;background:#0f131a;border-top:1px solid var(--bar-border)
  }
  #zoomSlider{width:min(560px,100%)}
  #status{
    display:grid;grid-template-columns:repeat(4,auto);gap:.6rem 1rem;align-items:center;
    padding:.4rem .75rem;font-size:.9rem;color:var(--muted)
  }
  .ok{color:var(--ok)} .warn{color:var(--warn)} .bad{color:var(--bad)} .mono{font-family:ui-monospace,Menlo,Consolas,monospace}

  @media (orientation:landscape){
    #app{grid-template-rows:1fr}
    header,#bottomBar,#status{
      position:fixed;left:calc(8px + env(safe-area-inset-left));right:calc(8px + env(safe-area-inset-right));
      z-index:10;background:var(--bar);border:1px solid var(--bar-border);border-radius:.6rem
    }
    header{top:calc(8px + env(safe-area-inset-top));padding:.4rem .6rem}
    #bottomBar{bottom:calc(10px + env(safe-area-inset-bottom));padding:.45rem .6rem}
    #status{
      bottom:calc(10px + env(safe-area-inset-bottom));
      transform:translateY(calc(100% + 8px));padding:.3rem .5rem;font-size:.85rem;
      grid-template-columns:repeat(4,minmax(0,auto))
    }
    button,select,label.chip{padding:.35rem .5rem;font-size:.9rem}
  }

  button:focus,select:focus,input:focus,label.chip:has(input:focus){
    outline:2px solid var(--accent); outline-offset:2px;
  }
  label.chip{display:inline-flex;gap:.5rem;align-items:center;cursor:pointer;user-select:none}
  label.chip input{accent-color:var(--accent)}
  noscript{display:block;padding:1rem;margin:1rem;border:1px solid #512; background:#200; color:#fff}
</style>
</head>
<body>
<noscript>Diese App ben√∂tigt JavaScript (Kamera, Erkennung, Speichern). Bitte JavaScript aktivieren.</noscript>

<div id="app" aria-live="polite">
  <header>
    <div class="group">
      <button id="btnStart" class="primary" aria-label="Kamera starten">üé• Kamera starten</button>
      <select id="selCam" title="Kamera/Linse (nur R√ºckkamera)" disabled><option>‚Äî</option></select>
      <select id="selQuality" title="Qualit√§t" disabled>
        <option value="auto" selected>Auto (Max)</option>
        <option value="2160">2160p</option>
        <option value="1440">1440p</option>
        <option value="1080">1080p</option>
        <option value="720">720p</option>
      </select>
      <button id="btnSnap" aria-label="Foto machen" disabled>üì∏ Foto</button>
    </div>
    <div class="group">
      <button id="btnDir" aria-label="Speicherordner w√§hlen">üìÅ Ordner</button>
      <span id="saveMode" class="kpi">Speichern: <b>Download</b></span>
    </div>
    <div class="spacer"></div>
    <div class="group">
      <span id="kpiRes" class="kpi">Aufl√∂sung: ‚Äî</span>
    </div>
  </header>

  <div id="stage" role="region" aria-label="Live-Kamera">
    <div id="banner" role="status" aria-live="polite"></div>
    <video id="video" playsinline muted></video>
    <canvas id="overlay"></canvas>
  </div>

  <div id="bottomBar">
    <label for="zoomSlider">üîé Zoom</label>
    <input id="zoomSlider" type="range" min="1" max="10" step="0.01" value="1" disabled aria-label="Zoom">
    <span id="zoomInfo" class="kpi">Anzeige 1.00√ó | HW ‚Äî</span>
    <span class="spacer"></span>
    <label class="chip" title="Auto-Foto bei Tafel√§nderung"><input type="checkbox" id="tglAuto"> Auto Foto</label>
    <label class="chip" title="Bewegungs-Blocker gegen versehentliche Ausl√∂sung"><input type="checkbox" id="tglBlocker" checked> Objekte blockieren</label>
    <label class="chip" title="Verhindert Auto-Foto wenn Gesichter auf der Tafel sind"><input type="checkbox" id="tglFace"> Face-Blocker</label>
    <label class="chip" title="Texterkennung nach dem Speichern (deu)"><input type="checkbox" id="tglOCR"> OCR</label>
  </div>

  <div id="status">
    <div>Board erkannt: <b id="stBoard" class="bad">nein</b></div>
    <div>Auto: <b id="stAuto" class="warn">aus</b></div>
    <div>Blocker: <b id="stBlock" class="warn">‚Äî</b></div>
    <div>Modelle: <span id="stModels" class="mono">BoardJS, Motion</span></div>
  </div>
</div>

<script>
/* ===== Utilities ===== */
const $=s=>document.querySelector(s), on=(el,ev,fn,o)=>el.addEventListener(ev,fn,o);
const clamp=(v,l,h)=>Math.max(l,Math.min(h,v)), fmt=(n,d=2)=>Number(n).toFixed(d);
const banner=$('#banner');
function showBanner(t,cls='warn',ms=3000){
  banner.textContent=t; banner.style.display='block';
  banner.style.borderColor=cls==='bad'?'#7a2a2a':cls==='ok'?'#2f6a45':'#263445';
  clearTimeout(showBanner._t); showBanner._t=setTimeout(()=>banner.style.display='none',ms);
}
function saveLocal(k,v){ try{ localStorage.setItem(k,JSON.stringify(v)); }catch{} }
function loadLocal(k,d){ try{ const v=localStorage.getItem(k); return v?JSON.parse(v):d; }catch{ return d; } }

/* ===== Elements ===== */
const video=$('#video'), overlay=$('#overlay'), ctxOv=overlay.getContext('2d',{willReadFrequently:true});
const btnStart=$('#btnStart'), selCam=$('#selCam'), selQuality=$('#selQuality'), btnSnap=$('#btnSnap');
const btnDir=$('#btnDir'), saveMode=$('#saveMode');
const tglAuto=$('#tglAuto'), tglBlocker=$('#tglBlocker'), tglFace=$('#tglFace'), tglOCR=$('#tglOCR');
const kpiRes=$('#kpiRes'), stBoard=$('#stBoard'), stAuto=$('#stAuto'), stBlock=$('#stBlock'), stModels=$('#stModels');
const zoomSlider=$('#zoomSlider'), zoomInfo=$('#zoomInfo');

/* ===== State ===== */
let mediaStream=null, track=null, caps=null, sets=null;
let hardwareZoom=false, hwMin=1, hwMax=1, displayZoom=1;
let dirHandle=null, haveFSAccess=('showDirectoryPicker' in window);
let loopRunning=false, boardQuadOverlay=null, boardQuadVideo=null, boardFound=false;
let targetW=1600, targetH=900;
let prevThumb=null, lastChangeTs=0; const CHANGE_THRESH=0.09, STABLE_MS=800, COOLDOWN_MS=3500;

/* ===== Layout & Zoom ===== */
function resizeOverlay(){
  const r=video.getBoundingClientRect();
  overlay.width=Math.max(2,Math.round(r.width||overlay.clientWidth||2));
  overlay.height=Math.max(2,Math.round(r.height||overlay.clientHeight||2));
}
new (window.ResizeObserver||class{observe(){}})(resizeOverlay).observe($('#stage'));
window.addEventListener('resize',resizeOverlay,{passive:true});

function applyDisplayTransform(){ const t=`scale(${displayZoom})`; video.style.transform=t; overlay.style.transform=t; }
on(zoomSlider,'input',()=>applyZoom(parseFloat(zoomSlider.value)));
async function applyZoom(total){
  let hw=1, disp=total;
  if (hardwareZoom){
    hw = clamp(total, hwMin, hwMax);
    try{ await track.applyConstraints({advanced:[{zoom:hw}]}); }catch(e){ hw=1; disp=total; }
    disp = total / hw;
  }
  displayZoom = clamp(disp, 1, 10);
  applyDisplayTransform();
  zoomInfo.textContent=`Anzeige ${fmt(displayZoom,2)}√ó | HW ${hardwareZoom?fmt(hw,2)+'√ó':'‚Äî'}`;
  saveLocal('zoom', displayZoom);
}

/* ===== FS Access ===== */
async function chooseDirectory(){
  if (!haveFSAccess){ showBanner('FS Access API nicht unterst√ºtzt ‚Äì nutze Downloads','warn',4000); return; }
  try{
    dirHandle=await window.showDirectoryPicker({mode:'readwrite'});
    saveMode.innerHTML='Speichern: <b>Ordner</b>'; saveLocal('saveMode','folder');
  }catch{}
}
async function saveImage(blob, base='Tafel'){
  const t=new Date(), p=s=>String(s).padStart(2,'0');
  const name=`${base}_${t.getFullYear()}${p(t.getMonth()+1)}${p(t.getDate())}_${p(t.getHours())}${p(t.getMinutes())}${p(t.getSeconds())}.png`;
  if (dirHandle && haveFSAccess){
    try{
      const perm=await dirHandle.requestPermission?.({mode:'readwrite'});
      if (perm==='granted'){
        const fh=await dirHandle.getFileHandle(name,{create:true});
        const w=await fh.createWritable(); await w.write(blob); await w.close();
        return {mode:'folder',name};
      }
    }catch{}
  }
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=name; document.body.appendChild(a); a.click(); URL.revokeObjectURL(a.href); a.remove();
  return {mode:'download',name};
}

/* ===== Frame helpers ===== */
function frameCanvasOverlay(){
  const c=document.createElement('canvas'); c.width=overlay.width; c.height=overlay.height;
  c.getContext('2d',{willReadFrequently:true}).drawImage(video,0,0,c.width,c.height); return c;
}
function frameCanvasSensor(){
  const vw=video.videoWidth||overlay.width, vh=video.videoHeight||overlay.height;
  const c=document.createElement('canvas'); c.width=vw; c.height=vh;
  c.getContext('2d',{willReadFrequently:true}).drawImage(video,0,0,c.width,c.height); return c;
}
function grayThumb(srcCanvas,tw=128,th=72){
  const c=document.createElement('canvas'); c.width=tw; c.height=th;
  const x=c.getContext('2d',{willReadFrequently:true}); x.drawImage(srcCanvas,0,0,tw,th);
  const id=x.getImageData(0,0,tw,th).data; const out=new Float32Array(tw*th);
  for(let i=0,j=0;i<id.length;i+=4,j++) out[j]=(0.299*id[i]+0.587*id[i+1]+0.114*id[i+2])/255;
  return {data:out,w:tw,h:th};
}
function mse(a,b){ if(!a||!b||a.data.length!==b.data.length) return 1; let s=0; for(let i=0;i<a.data.length;i++){ const d=a.data[i]-b.data[i]; s+=d*d; } return s/a.data.length; }

/* ===== Pure-JS Board Detection ===== */
/* Sobel Edges */
function sobelGray(gray,w,h){
  const gx=new Float32Array(w*h), gy=new Float32Array(w*h), mag=new Float32Array(w*h);
  const idx=(x,y)=>y*w+x;
  for(let y=1;y<h-1;y++){
    for(let x=1;x<w-1;x++){
      const a=gray[idx(x-1,y-1)], b=gray[idx(x,y-1)], c=gray[idx(x+1,y-1)];
      const d=gray[idx(x-1,y)],   e=gray[idx(x,y)],   f=gray[idx(x+1,y)];
      const g=gray[idx(x-1,y+1)], h1=gray[idx(x,y+1)], i=gray[idx(x+1,y+1)];
      const sx = (-1*a + 1*c) + (-2*d + 2*f) + (-1*g + 1*i);
      const sy = (-1*a -2*b -1*c) + (1*g +2*h1 +1*i);
      const m = Math.hypot(sx, sy);
      gx[idx(x,y)]=sx; gy[idx(x,y)]=sy; mag[idx(x,y)]=m;
    }
  }
  return {gx,gy,mag};
}
/* Threshold edges by mean+K*std */
function thresholdEdges(mag,w,h){
  let sum=0,sum2=0,n=w*h;
  for(let i=0;i<n;i++){ const v=mag[i]; sum+=v; sum2+=v*v; }
  const mean=sum/n, std=Math.sqrt(Math.max(0,sum2/n-mean*mean));
  const t=mean + 0.8*std;
  const pts=[];
  for(let y=1;y<h-1;y++){
    for(let x=1;x<w-1;x++){
      const v=mag[y*w+x];
      if (v>t) pts.push({x,y});
    }
  }
  return pts;
}
/* Convex Hull (Monotone Chain) */
function convexHull(points){
  if (points.length<3) return [];
  const pts=points.slice().sort((a,b)=>a.x===b.x? a.y-b.y : a.x-b.x);
  const cross=(o,a,b)=>(a.x-o.x)*(b.y-o.y)-(a.y-o.y)*(b.x-o.x);
  const lower=[]; for(const p of pts){ while(lower.length>=2 && cross(lower[lower.length-2], lower[lower.length-1], p)<=0) lower.pop(); lower.push(p); }
  const upper=[]; for(let i=pts.length-1;i>=0;i--){ const p=pts[i]; while(upper.length>=2 && cross(upper[upper.length-2], upper[upper.length-1], p)<=0) upper.pop(); upper.push(p); }
  upper.pop(); lower.pop();
  return lower.concat(upper);
}
/* Minimum-Area Rectangle on Convex Hull */
function minAreaRect(hull){
  if (hull.length<3) return null;
  let best=null, bestArea=Infinity;
  for (let i=0;i<hull.length;i++){
    const p0=hull[i], p1=hull[(i+1)%hull.length];
    const dx=p1.x-p0.x, dy=p1.y-p0.y;
    const len=Math.hypot(dx,dy)||1;
    const ux=dx/len, uy=dy/len;      // axis u
    const vx=-uy, vy=ux;             // axis v (perp)
    let umin=Infinity, umax=-Infinity, vmin=Infinity, vmax=-Infinity;
    for (const p of hull){
      const u=p.x*ux + p.y*uy;
      const v=p.x*vx + p.y*vy;
      if (u<umin) umin=u; if (u>umax) umax=u;
      if (v<vmin) vmin=v; if (v>vmax) vmax=v;
    }
    const area=(umax-umin)*(vmax-vmin);
    if (area<bestArea){
      bestArea=area;
      // corners back to image space
      const c00={x: ux*umin + vx*vmin, y: uy*umin + vy*vmin};
      const c10={x: ux*umax + vx*vmin, y: uy*umax + vy*vmin};
      const c11={x: ux*umax + vx*vmax, y: uy*umax + vy*vmax};
      const c01={x: ux*umin + vx*vmax, y: uy*umin + vy*vmax};
      best=[c00,c10,c11,c01];
    }
  }
  return best;
}
/* Order TL,TR,BR,BL */
function orderTLTRBRBL(pts){
  const bySum=pts.slice().sort((a,b)=>(a.x+a.y)-(b.x+b.y));
  const byDiff=pts.slice().sort((a,b)=>(a.x-a.y)-(b.x-b.y));
  const tl=bySum[0], br=bySum[bySum.length-1], tr=byDiff[byDiff.length-1], bl=byDiff[0];
  return [tl,tr,br,bl];
}
/* Board detection (overlay space) */
function detectBoardQuadOverlayJS(frameCanvas){
  const w=frameCanvas.width, h=frameCanvas.height;
  const tw=Math.max(160, Math.round(w*0.35)), th=Math.max(90, Math.round(h*0.35));
  // downscale + gray
  const tmp=document.createElement('canvas'); tmp.width=tw; tmp.height=th;
  const tx=tmp.getContext('2d',{willReadFrequently:true});
  tx.drawImage(frameCanvas,0,0,tw,th);
  const id=tx.getImageData(0,0,tw,th).data; const gray=new Float32Array(tw*th);
  for(let i=0,j=0;i<id.length;i+=4,j++) gray[j]=(0.299*id[i]+0.587*id[i+1]+0.114*id[i+2])/255;

  const {mag}=sobelGray(gray,tw,th);
  const edges=thresholdEdges(mag,tw,th);
  if (edges.length< (tw*th*0.01)) return null; // zu wenige Kanten

  const hull=convexHull(edges);
  if (hull.length<3) return null;
  const rect=minAreaRect(hull);
  if (!rect) return null;

  // Hochskalieren in Overlay-Koordinaten
  const sx=w/tw, sy=h/th;
  const rectScaled=rect.map(p=>({x:p.x*sx, y:p.y*sy}));
  const q=orderTLTRBRBL(rectScaled);

  // Plausibilit√§tschecks
  const areaPoly = Math.abs( (q[0].x*q[1].y - q[1].x*q[0].y) + (q[1].x*q[2].y - q[2].x*q[1].y) + (q[2].x*q[3].y - q[3].x*q[2].y) + (q[3].x*q[0].y - q[0].x*q[3].y) )/2;
  const areaFrac = areaPoly/(w*h);
  if (areaFrac < 0.10 || areaFrac > 0.95) return null;

  const wTop=Math.hypot(q[1].x-q[0].x,q[1].y-q[0].y), wBot=Math.hypot(q[2].x-q[3].x,q[2].y-q[3].y);
  const hL=Math.hypot(q[3].x-q[0].x,q[3].y-q[0].y), hR=Math.hypot(q[2].x-q[1].x,q[2].y-q[1].y);
  const wA=(wTop+wBot)/2, hA=(hL+hR)/2, asp=wA/Math.max(1,hA);
  if (asp<0.7 || asp>2.5) return null;

  return q;
}

/* ===== Overlay <-> Video mapping (object-fit: cover) ===== */
function overlayToVideoPoint(pt){
  const ow=overlay.width, oh=overlay.height;
  const vw=video.videoWidth||ow, vh=video.videoHeight||oh;
  if (!vw||!vh) return {x:pt.x, y:pt.y};
  const s=Math.max(ow/vw, oh/vh);
  const dw=vw*s, dh=vh*s;
  const dx=(ow - dw)/2, dy=(oh - dh)/2;
  const x=(pt.x - dx)/s, y=(pt.y - dy)/s;
  return { x: clamp(x,0,vw-1), y: clamp(y,0,vh-1) };
}
function mapQuadOverlayToVideo(q){ return q.map(p=>overlayToVideoPoint(p)); }

/* ===== Homography (DLT) & 3x3 helpers ===== */
function computeHomography(srcPts, dstPts){
  // srcPts[i] -> dstPts[i], i=0..3 ; solve 8 unknowns (h33=1)
  const A=new Array(8).fill(0).map(()=>new Float64Array(8));
  const b=new Float64Array(8);
  for(let i=0;i<4;i++){
    const x=srcPts[i].x, y=srcPts[i].y, X=dstPts[i].x, Y=dstPts[i].y;
    const r0=i*2, r1=i*2+1;
    // Row for X
    A[r0][0]=x; A[r0][1]=y; A[r0][2]=1; A[r0][3]=0; A[r0][4]=0; A[r0][5]=0; A[r0][6]=-x*X; A[r0][7]=-y*X; b[r0]=X;
    // Row for Y
    A[r1][0]=0; A[r1][1]=0; A[r1][2]=0; A[r1][3]=x; A[r1][4]=y; A[r1][5]=1; A[r1][6]=-x*Y; A[r1][7]=-y*Y; b[r1]=Y;
  }
  const h=gaussSolve(A,b); // length 8
  if (!h) return null;
  const H=[
    [h[0],h[1],h[2]],
    [h[3],h[4],h[5]],
    [h[6],h[7],1   ],
  ];
  return H;
}
function gaussSolve(A,b){
  const n=8;
  // Augment
  for(let i=0;i<n;i++){ A[i]=Float64Array.from([...A[i], b[i]]); }
  // Elimination
  for(let col=0; col<n; col++){
    // pivot
    let piv=col;
    for(let r=col+1;r<n;r++) if (Math.abs(A[r][col])>Math.abs(A[piv][col])) piv=r;
    if (Math.abs(A[piv][col])<1e-12) return null;
    if (piv!==col){ const tmp=A[col]; A[col]=A[piv]; A[piv]=tmp; }
    // normalize
    const div=A[col][col];
    for(let c=col;c<=n;c++) A[col][c]/=div;
    // eliminate others
    for(let r=0;r<n;r++){
      if (r===col) continue;
      const factor=A[r][col];
      if (factor===0) continue;
      for(let c=col;c<=n;c++) A[r][c]-=factor*A[col][c];
    }
  }
  const x=new Float64Array(n);
  for(let i=0;i<n;i++) x[i]=A[i][n];
  return x;
}
function mat3MulVec(H, v){ // 3x3 * 3x1
  return [
    H[0][0]*v[0] + H[0][1]*v[1] + H[0][2]*v[2],
    H[1][0]*v[0] + H[1][1]*v[1] + H[1][2]*v[2],
    H[2][0]*v[0] + H[2][1]*v[1] + H[2][2]*v[2],
  ];
}
function mat3Inv(m){
  const a=m[0][0], b=m[0][1], c=m[0][2];
  const d=m[1][0], e=m[1][1], f=m[1][2];
  const g=m[2][0], h=m[2][1], i=m[2][2];
  const A=e*i - f*h, B=-(d*i - f*g), C=d*h - e*g;
  const D=-(b*i - c*h), E=a*i - c*g, F=-(a*h - b*g);
  const G=b*f - c*e, H=-(a*f - c*d), I=a*e - b*d;
  const det=a*A + b*B + c*C;
  if (Math.abs(det)<1e-12) return null;
  const inv=[[A,B,C],[D,E,F],[G,H,I]];
  for(let r=0;r<3;r++) for(let s=0;s<3;s++) inv[r][s]/=det;
  return inv;
}

/* ===== WebGL Warp (projective, shader) ===== */
function warpBoardWebGL(srcCanvas, srcQuad, outW, outH){
  const glCanvas=document.createElement('canvas'); glCanvas.width=outW; glCanvas.height=outH;
  const gl=glCanvas.getContext('webgl',{preserveDrawingBuffer:true});
  if(!gl) return null;

  // Build H (src -> dst rect), then Hinv (dst->src)
  const dstQuad=[{x:0,y:0},{x:outW,y:0},{x:outW,y:outH},{x:0,y:outH}];
  const H=computeHomography(srcQuad, dstQuad); if(!H) return null;
  const Hinv=mat3Inv(H); if(!Hinv) return null;

  const vs=`attribute vec2 aPos;
  varying vec2 vPos;
  void main(){
    vPos = aPos*0.5 + 0.5; // from [-1,1] to [0,1]
    gl_Position = vec4(aPos,0.0,1.0);
  }`;
  const fs=`precision mediump float;
  varying vec2 vPos; // in [0,1] dest
  uniform sampler2D uTex;
  uniform vec2 uSrcSize;
  uniform mat3 uHinv;
  void main(){
    vec3 d = vec3(vPos.x*${outW.toFixed(1)}, vPos.y*${outH.toFixed(1)}, 1.0);
    vec3 s = uHinv * d;
    float sx = s.x / s.z;
    float sy = s.y / s.z;
    vec2 uv = vec2(sx / uSrcSize.x, sy / uSrcSize.y);
    // clamp sampling
    if (uv.x<0.0 || uv.x>1.0 || uv.y<0.0 || uv.y>1.0){ discard; }
    gl_FragColor = texture2D(uTex, uv);
  }`;
  function compile(type,src){
    const sh=gl.createShader(type); gl.shaderSource(sh,src); gl.compileShader(sh);
    if(!gl.getShaderParameter(sh,gl.COMPILE_STATUS)){ console.error(gl.getShaderInfoLog(sh)); return null; }
    return sh;
  }
  const prog=gl.createProgram();
  const vsh=compile(gl.VERTEX_SHADER,vs), fsh=compile(gl.FRAGMENT_SHADER,fs);
  if(!vsh||!fsh) return null;
  gl.attachShader(prog,vsh); gl.attachShader(prog,fsh); gl.linkProgram(prog);
  if(!gl.getProgramParameter(prog,gl.LINK_STATUS)){ console.error(gl.getProgramInfoLog(prog)); return null; }
  gl.useProgram(prog);

  // Quad [-1,1]
  const pos=new Float32Array([ -1,-1,  1,-1,  -1,1,  1,1 ]);
  const vbo=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER,vbo); gl.bufferData(gl.ARRAY_BUFFER,pos,gl.STATIC_DRAW);
  const loc=gl.getAttribLocation(prog,'aPos'); gl.enableVertexAttribArray(loc); gl.vertexAttribPointer(loc,2,gl.FLOAT,false,0,0);

  // Texture from srcCanvas
  const tex=gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D,tex);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);
  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
  gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,srcCanvas);

  // Uniforms
  const uTex=gl.getUniformLocation(prog,'uTex'); gl.uniform1i(uTex,0);
  const uSrcSize=gl.getUniformLocation(prog,'uSrcSize'); gl.uniform2f(uSrcSize, srcCanvas.width, srcCanvas.height);
  const uHinv=gl.getUniformLocation(prog,'uHinv');
  const HinvFlat=new Float32Array([Hinv[0][0],Hinv[0][1],Hinv[0][2], Hinv[1][0],Hinv[1][1],Hinv[1][2], Hinv[2][0],Hinv[2][1],Hinv[2][2]]);
  gl.uniformMatrix3fv(uHinv,false,HinvFlat);

  gl.viewport(0,0,outW,outH);
  gl.clearColor(0,0,0,0); gl.clear(gl.COLOR_BUFFER_BIT);
  gl.drawArrays(gl.TRIANGLE_STRIP,0,4);

  return glCanvas;
}

/* ===== Face & OCR (lazy) ===== */
let faceModel=null, tfLoaded=false, blazeLoaded=false, tessLoaded=false;
function loadScript(src){
  return new Promise((res,rej)=>{
    const s=document.createElement('script');
    s.src=src; s.async=true; s.crossOrigin='anonymous'; s.referrerPolicy='no-referrer';
    s.onload=()=>res(); s.onerror=e=>rej(e); document.head.appendChild(s);
  });
}
async function ensureFace(){
  if (!tglFace.checked) return false;
  if (!tfLoaded){ try{ await loadScript('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js'); tfLoaded=true; }catch{ try{ await loadScript('https://unpkg.com/@tensorflow/tfjs@4.22.0/dist/tf.min.js'); tfLoaded=true; }catch(e){} } }
  if (!blazeLoaded){ try{ await loadScript('https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface@0.1.2/dist/blazeface.min.js'); blazeLoaded=true; }catch{ try{ await loadScript('https://unpkg.com/@tensorflow-models/blazeface@0.1.2/dist/blazeface.min.js'); blazeLoaded=true; }catch(e){} } }
  if (window.blazeface && !faceModel){ try{ faceModel=await blazeface.load(); if(!stModels.textContent.includes('BlazeFace')) stModels.textContent+=', BlazeFace'; }catch(e){} }
  return !!faceModel;
}
function triArea(a,b,c){ return Math.abs((a.x*(b.y-c.y)+b.x*(c.y-a.y)+c.x*(a.y-b.y))/2); }
function polyArea(q){ return triArea(q[0],q[1],q[2])+triArea(q[0],q[2],q[3]); }
function pointInQuad(p,q){ const A=polyArea(q); const s=triArea(p,q[0],q[1])+triArea(p,q[1],q[2])+triArea(p,q[2],q[3])+triArea(p,q[3],q[0]); return Math.abs(s-A)<1e-1*A; }
async function faceBlockVerdict(canvasOverlay){
  if (!tglFace.checked || !boardQuadOverlay) return false;
  try{ const ok=await ensureFace(); if(!ok) return false;
    const preds=await faceModel.estimateFaces(canvasOverlay,false); if(!preds?.length) return false;
    for (const p of preds){ if(!p.topLeft||!p.bottomRight) continue; const cx=(p.topLeft[0]+p.bottomRight[0])/2, cy=(p.topLeft[1]+p.bottomRight[1])/2; if (pointInQuad({x:cx,y:cy}, boardQuadOverlay)) return true; }
  }catch(e){}
  return false;
}
async function ensureOCR(){
  if (!tglOCR.checked) return false;
  if (!tessLoaded){
    try{ await loadScript('https://cdn.jsdelivr.net/npm/tesseract.js@5.1.1/dist/tesseract.min.js'); tessLoaded=true; }
    catch{ try{ await loadScript('https://unpkg.com/tesseract.js@5.1.1/dist/tesseract.min.js'); tessLoaded=true; }catch(e){} }
    if (tessLoaded && !stModels.textContent.includes('OCR')) stModels.textContent+=', OCR';
  }
  return tessLoaded;
}
async function runOCR(canvas){
  try{ const ok=await ensureOCR(); if(!ok) return; const worker=await Tesseract.createWorker('deu');
    const {data:{text}}=await worker.recognize(canvas); await worker.terminate(); console.log('OCR (deu):',text);
  }catch(e){}
}

/* ===== Kamera & Qualit√§t (Back-Facing bevorzugt) ===== */
async function listCameras(){
  const devs=await navigator.mediaDevices.enumerateDevices();
  const cams=devs.filter(d=>d.kind==='videoinput');
  const isBack = l=>{
    l=(l||'').toLowerCase();
    return l.includes('back')||l.includes('rear')||l.includes('environment')||l.includes('r√ºck')||l.includes('world');
  };
  const backCams = cams.filter(c=>isBack(c.label));
  const list = backCams.length? backCams : cams;
  selCam.innerHTML='';
  list.forEach(c=>{
    const o=document.createElement('option'); o.value=c.deviceId;
    const lab=c.label||`Kamera ${c.deviceId.slice(0,6)}`;
    o.textContent = (backCams.length? lab : `${lab} (kein Back-Hinweis)`);
    selCam.appendChild(o);
  });
  selCam.disabled=list.length===0;
}
async function restartStreamWithConstraints(cons){
  if (mediaStream){ mediaStream.getTracks().forEach(t=>t.stop()); mediaStream=null; }
  mediaStream=await navigator.mediaDevices.getUserMedia(cons);
  video.srcObject=mediaStream; await video.play().catch(()=>{});
  track=mediaStream.getVideoTracks()[0]; caps=track.getCapabilities?.()||{}; sets=track.getSettings?.()||{};
  hardwareZoom='zoom' in (caps||{}); if (hardwareZoom){ hwMin=caps.zoom.min??1; hwMax=caps.zoom.max??1; }
  await new Promise(r=> video.onloadedmetadata ? (video.onloadedmetadata=()=>r()) : setTimeout(r,120));
  resizeOverlay(); applyDisplayTransform();
  kpiRes.textContent=`Aufl√∂sung: ${sets.width||video.videoWidth||'‚Äî'}√ó${sets.height||video.videoHeight||'‚Äî'}`;
}
async function startCamera(deviceId=null){
  try{
    btnStart.disabled=true;
    if (!navigator.mediaDevices?.getUserMedia){ showBanner('getUserMedia nicht verf√ºgbar (HTTPS/Browser pr√ºfen)','bad',7000); btnStart.disabled=false; return; }
    let cons = deviceId
      ? {video:{deviceId:{exact:deviceId}, facingMode:{ideal:'environment'}}, audio:false}
      : {video:{facingMode:{exact:'environment'}, width:{ideal:1920}, height:{ideal:1080}, frameRate:{ideal:30,max:60}}, audio:false};
    try{ await restartStreamWithConstraints(cons); }
    catch(e1){
      try{ await restartStreamWithConstraints({video:{facingMode:{ideal:'environment'}}, audio:false}); }
      catch(e2){
        await restartStreamWithConstraints({video:true, audio:false});
        showBanner('Keine R√ºckkamera erkennbar ‚Äì nutze verf√ºgbare Kamera', 'warn', 5000);
      }
    }
    await listCameras(); selQuality.disabled=false; btnSnap.disabled=false; zoomSlider.disabled=false;

    try{ await track.applyConstraints({advanced:[{focusMode:'continuous'},{exposureMode:'continuous'},{whiteBalanceMode:'continuous'}]}); }catch{}

    if (selQuality.value==='auto') await setMaxResolution(); else await applyQualityPreset(selQuality.value);
    sets=track.getSettings?.()||sets; kpiRes.textContent=`Aufl√∂sung: ${sets.width||'‚Äî'}√ó${sets.height||'‚Äî'}`;
    if (!loopRunning){ loopRunning=true; processingLoop(); }
    showBanner('Kamera l√§uft','ok',1500);
    saveLocal('camId', track.getSettings?.().deviceId||null);
  }catch(err){
    let msg=err.name+': '+err.message;
    if (err.name==='NotAllowedError') msg='Kamera-Zugriff verweigert';
    if (err.name==='NotFoundError') msg='Keine Kamera gefunden';
    if (err.name==='NotReadableError') msg='Kamera belegt';
    if (err.name==='OverconstrainedError') msg='Constraint nicht erf√ºllbar';
    showBanner('Kamera-Fehler: '+msg,'bad',7000);
    btnStart.disabled=false;
  }
}
async function setMaxResolution(){
  if (!track?.getCapabilities) return false;
  const c=track.getCapabilities(); const wMax=c.width&&c.width.max, hMax=c.height&&c.height.max, fpsMax=c.frameRate&&c.frameRate.max;
  if (wMax&&hMax){
    try{
      const adv = c.resizeMode? [{resizeMode:'none'}] : [];
      await track.applyConstraints({ width:{exact:wMax}, height:{exact:hMax}, ...(fpsMax?{frameRate:{ideal:Math.min(60,fpsMax)}}:{}), ...(adv.length?{advanced:adv}:{}) });
      await new Promise(r=>setTimeout(r,120));
      const s=track.getSettings?.(); if (s && s.width===wMax && s.height===hMax) return true;
    }catch{}
  }
  const deviceId = track?.getSettings?.().deviceId;
  const cons = deviceId? { video:{ deviceId:{exact:deviceId}, width:{exact:wMax||3840}, height:{exact:hMax||2160} }, audio:false } :
                         { video:{ facingMode:{ideal:'environment'}, width:{exact:wMax||3840}, height:{exact:hMax||2160} }, audio:false };
  try{ await restartStreamWithConstraints(cons); return true; }catch{}
  const ladder=[{w:3840,h:2160},{w:2560,h:1440},{w:1920,h:1080},{w:1280,h:720}];
  for (const p of ladder){
    const lc = deviceId? { video:{ deviceId:{exact:deviceId}, width:{exact:p.w}, height:{exact:p.h} }, audio:false }
                       : { video:{ facingMode:{ideal:'environment'}, width:{exact:p.w}, height:{exact:p.h} }, audio:false };
    try{ await restartStreamWithConstraints(lc); return true; }catch{}
  }
  return false;
}
async function applyQualityPreset(q){
  if (!track) return;
  const map={ '2160':{w:3840,h:2160}, '1440':{w:2560,h:1440}, '1080':{w:1920,h:1080}, '720':{w:1280,h:720} };
  const p=map[q]; if (!p) return;
  const deviceId = track?.getSettings?.().deviceId;
  const cons = deviceId? { video:{ deviceId:{exact:deviceId}, width:{exact:p.w}, height:{exact:p.h} }, audio:false }
                       : { video:{ facingMode:{ideal:'environment'}, width:{exact:p.w}, height:{exact:p.h} }, audio:false };
  try{ await restartStreamWithConstraints(cons); }catch(e){ /* ignore */ }
}
on(selQuality,'change',async()=>{ if (selQuality.value==='auto') await setMaxResolution(); else await applyQualityPreset(selQuality.value); });
on(selCam,'change',()=>startCamera(selCam.value));

/* ===== Live Loop ===== */
function drawOverlayQuad(q){
  const ow=overlay.width, oh=overlay.height;
  ctxOv.clearRect(0,0,ow,oh);
  if (!q) return;
  ctxOv.lineWidth=3.5; ctxOv.strokeStyle='rgba(78,161,255,1.0)'; ctxOv.fillStyle='rgba(78,161,255,0.15)';
  ctxOv.beginPath(); ctxOv.moveTo(q[0].x,q[0].y); for(let i=1;i<4;i++) ctxOv.lineTo(q[i].x,q[i].y); ctxOv.closePath(); ctxOv.stroke(); ctxOv.fill();
}
async function processingLoop(){
  let frameIdx=0, lastMotion=null; const MOTION_T=0.18, MOTION_FRAC=0.035;
  const step = async ()=>{
    if (!mediaStream){ loopRunning=false; return; }
    const ow=overlay.width, oh=overlay.height;
    if (ow>2 && oh>2){
      const frameOverlay=frameCanvasOverlay();
      try{
        // Alle 8 Frames neu evaluieren (Balance)
        if (!boardFound || (frameIdx%8===0)){
          const q=detectBoardQuadOverlayJS(frameOverlay);
          if (q){
            boardQuadOverlay=q;
            boardQuadVideo=mapQuadOverlayToVideo(boardQuadOverlay);
            boardFound=true;
            // Zielgr√∂√üe aus Seitenverh√§ltnis ableiten
            const wTop=Math.hypot(q[1].x-q[0].x,q[1].y-q[0].y);
            const wBot=Math.hypot(q[2].x-q[3].x,q[2].y-q[3].y);
            const hL=Math.hypot(q[3].x-q[0].x,q[3].y-q[0].y);
            const hR=Math.hypot(q[2].x-q[1].x,q[2].y-q[1].y);
            const wA=(wTop+wBot)/2, hA=(hL+hR)/2, asp=wA/Math.max(1,hA);
            targetW=1600; targetH=Math.round(targetW/asp);
          } else {
            boardFound=false; boardQuadOverlay=null; boardQuadVideo=null;
          }
        }
        drawOverlayQuad(boardQuadOverlay);
        stBoard.textContent=boardFound?'ja':'nein'; stBoard.className=boardFound?'ok':'bad';

        // Change/Auto nur wenn Board
        if (boardFound){
          const warpedForDiff = frameOverlay; // leichte Approximation
          const thumb=grayThumb(warpedForDiff,128,72);
          const diffVal=prevThumb?mse(thumb,prevThumb):null; prevThumb=thumb;

          if (!lastMotion) lastMotion=grayThumb(warpedForDiff,128,72);
          const cur=grayThumb(warpedForDiff,128,72);
          let ch=0; for(let i=0;i<cur.data.length;i++) if (Math.abs(cur.data[i]-lastMotion.data[i])>MOTION_T) ch++;
          const frac=ch/cur.data.length, motionBlock=frac>MOTION_FRAC; lastMotion=cur;

          stBlock.textContent=tglBlocker.checked?(motionBlock?'blockiert':'frei'):'aus';
          stBlock.className=tglBlocker.checked?(motionBlock?'bad':'ok'):'warn';

          const now=performance.now(), stable=(now-lastChangeTs)>STABLE_MS;
          if (tglAuto.checked && diffVal!==null && diffVal>CHANGE_THRESH && stable){
            const cooldown=(now-(processingLoop._lastCap||0))>COOLDOWN_MS;
            const blockOk=tglBlocker.checked?!motionBlock:true;
            const faceOk=!(await faceBlockVerdict(frameOverlay));
            if (cooldown && blockOk && faceOk){ await captureAndSave('Auto'); processingLoop._lastCap=performance.now(); lastChangeTs=now; }
          }
        } else { drawOverlayQuad(null); }
      }catch(e){
        console.error(e);
        boardFound=false; boardQuadOverlay=null; boardQuadVideo=null; drawOverlayQuad(null);
      }
    }
    frameIdx++; requestAnimationFrame(step);
  };
  requestAnimationFrame(step);
}

/* ===== Capture & Warp ===== */
function canvasToBlob(canvas, type='image/png', quality=0.95){
  return new Promise(res=>{
    if (canvas.toBlob) canvas.toBlob(b=>res(b), type, quality);
    else { const dataURL=canvas.toDataURL(type, quality);
      const bstr=atob(dataURL.split(',')[1]); let n=bstr.length; const u8=new Uint8Array(n);
      while(n--) u8[n]=bstr.charCodeAt(n); res(new Blob([u8],{type}));
    }
  });
}
async function captureAndSave(prefix='Tafel'){
  try{
    let out=null;
    const frameSensor=frameCanvasSensor(); // volle Sensor-Aufl√∂sung
    if (boardFound && boardQuadVideo){
      const warped=warpBoardWebGL(frameSensor, boardQuadVideo, targetW, targetH);
      if (warped) out=warped; else out=frameSensor; // Fallback: volles Bild
    } else {
      out = frameSensor;
    }
    const blob=await canvasToBlob(out,'image/png',0.95);
    const r=await saveImage(blob,prefix); showBanner(`Foto gespeichert (${r.mode})`,'ok',1600);
    if (tglOCR.checked) runOCR(out);
  }catch(e){ console.error(e); showBanner('Fehler beim Speichern','bad',4000); }
}

/* ===== Events ===== */
on(btnStart,'click',()=>startCamera(loadLocal('camId',null)));
on(btnSnap,'click',()=>captureAndSave('Manuell'));
on(btnDir,'click',chooseDirectory);
on(tglAuto,'change',()=>{ stAuto.textContent=tglAuto.checked?'an':'aus'; stAuto.className=tglAuto.checked?'ok':'warn'; saveLocal('tglAuto', tglAuto.checked); });
on(tglBlocker,'change',()=>saveLocal('tglBlocker', tglBlocker.checked));
on(tglFace,'change',()=>saveLocal('tglFace', tglFace.checked));
on(tglOCR,'change',()=>saveLocal('tglOCR', tglOCR.checked));

/* ===== Init ===== */
(function init(){
  tglAuto.checked = loadLocal('tglAuto', false);
  tglBlocker.checked = loadLocal('tglBlocker', true);
  tglFace.checked = loadLocal('tglFace', false);
  tglOCR.checked = loadLocal('tglOCR', false);
  const z=loadLocal('zoom', 1); zoomSlider.value=z; displayZoom=z; applyDisplayTransform();
  stAuto.textContent=tglAuto.checked?'an':'aus'; stAuto.className=tglAuto.checked?'ok':'warn';
  saveMode.innerHTML = haveFSAccess ? 'Speichern: <b>Download / Ordner</b>' : 'Speichern: <b>Download</b>';
  zoomInfo.textContent=`Anzeige ${fmt(displayZoom,2)}√ó | HW ‚Äî`;

  navigator.mediaDevices?.enumerateDevices?.().then(()=>listCameras()).catch(()=>{});
  resizeOverlay();

  window.addEventListener('error',e=>{ console.error(e.error||e.message); showBanner('Unerwarteter Fehler ‚Äì versuche weiterzuarbeiten','warn',4000); }, {once:false});
  window.addEventListener('unhandledrejection',e=>{ console.error(e.reason); showBanner('Fehler in Hintergrundaufgabe','warn',3000); });
})();
</script>
</body>
</html>
