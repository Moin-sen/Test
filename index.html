<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,height=device-height,initial-scale=1,viewport-fit=cover,user-scalable=no" />
<meta name="theme-color" content="#0b0e13">
<title>TafelCapture ‚Äì PureJS Hough (Stabil+ROI)</title>
<meta name="description" content="Tafel/Whiteboard automatisch erkennen, stabil tracken und entzerrt speichern ‚Äì komplett im Browser, ohne OpenCV.">
<style>
  :root{
    color-scheme: dark;
    --bg:#0b0e13; --fg:#e9eef5; --muted:#a7b3c0; --accent:#4ea1ff;
    --ok:#11c46a; --warn:#ffb020; --bad:#ff4d6d;
    --bar:#0f131acc; --bar-border:#1a212c; --chip:#16202c;
  }
  html,body{margin:0;padding:0;background:var(--bg);color:var(--fg);
    font-family:system-ui,"Segoe UI",Roboto,Ubuntu,sans-serif;height:100%;
    -webkit-text-size-adjust:100%;
  }
  #app{display:grid;grid-template-rows:auto 1fr auto auto;min-height:100svh}
  header{
    display:flex;flex-wrap:wrap;gap:.5rem;align-items:center;
    padding:.5rem .75rem;background:#0f131a;border-bottom:1px solid var(--bar-border)
  }
  header .group{display:flex;gap:.5rem;align-items:center;flex-wrap:wrap}
  button,select,label.chip{
    background:var(--chip);color:var(--fg);border:1px solid #223041;border-radius:.55rem;
    padding:.5rem .65rem;font-size:.95rem;line-height:1;min-height:2.25rem
  }
  button.primary{background:#1a2b3f;border-color:#2a4060}
  .kpi{font-variant-numeric:tabular-nums;color:var(--muted)} .kpi b{color:var(--fg)}
  .spacer{flex:1}
  #stage{position:relative;background:#000;overflow:hidden}
  video,canvas#overlay{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;transform-origin:center}
  canvas#overlay{pointer-events:none}
  #banner{
    position:absolute;left:50%;top:calc(8px + env(safe-area-inset-top));
    transform:translateX(-50%);background:rgba(0,0,0,.85);
    border:1px solid #263445;border-radius:.5rem;padding:.5rem .7rem;font-size:.95rem;
    z-index:5;display:none
  }
  #bottomBar{
    display:flex;flex-wrap:wrap;gap:.5rem;align-items:center;
    padding:.55rem .75rem;background:#0f131a;border-top:1px solid var(--bar-border)
  }
  #zoomSlider{width:min(560px,100%)}
  #status{
    display:grid;grid-template-columns:repeat(4,auto);gap:.6rem 1rem;align-items:center;
    padding:.4rem .75rem;font-size:.9rem;color:var(--muted)
  }
  .ok{color:var(--ok)} .warn{color:var(--warn)} .bad{color:var(--bad)} .mono{font-family:ui-monospace,Menlo,Consolas,monospace}

  @media (orientation:landscape){
    #app{grid-template-rows:1fr}
    header,#bottomBar,#status{
      position:fixed;left:calc(8px + env(safe-area-inset-left));right:calc(8px + env(safe-area-inset-right));
      z-index:10;background:var(--bar);border:1px solid var(--bar-border);border-radius:.6rem
    }
    header{top:calc(8px + env(safe-area-inset-top));padding:.4rem .6rem}
    #bottomBar{bottom:calc(10px + env(safe-area-inset-bottom));padding:.45rem .6rem}
    #status{
      bottom:calc(10px + env(safe-area-inset-bottom));
      transform:translateY(calc(100% + 8px));padding:.3rem .5rem;font-size:.85rem;
      grid-template-columns:repeat(4,minmax(0,auto))
    }
    button,select,label.chip{padding:.35rem .5rem;font-size:.9rem}
  }

  button:focus,select:focus,input:focus,label.chip:has(input:focus){
    outline:2px solid var(--accent); outline-offset:2px;
  }
  label.chip{display:inline-flex;gap:.5rem;align-items:center;cursor:pointer;user-select:none}
  label.chip input{accent-color:var(--accent)}
  noscript{display:block;padding:1rem;margin:1rem;border:1px solid #512; background:#200; color:#fff}
</style>
</head>
<body>
<noscript>Diese App ben√∂tigt JavaScript (Kamera, Erkennung, Speichern). Bitte JavaScript aktivieren.</noscript>

<div id="app" aria-live="polite">
  <header>
    <div class="group">
      <button id="btnStart" class="primary" aria-label="Kamera starten">üé• Kamera starten</button>
      <select id="selCam" title="Kamera/Linse (nur R√ºckkamera)" disabled><option>‚Äî</option></select>
      <select id="selQuality" title="Qualit√§t" disabled>
        <option value="auto" selected>Auto (Max)</option>
        <option value="2160">2160p</option>
        <option value="1440">1440p</option>
        <option value="1080">1080p</option>
        <option value="720">720p</option>
      </select>
      <button id="btnSnap" aria-label="Foto machen" disabled>üì∏ Foto</button>
    </div>
    <div class="group">
      <button id="btnDir" aria-label="Speicherordner w√§hlen">üìÅ Ordner</button>
      <span id="saveMode" class="kpi">Speichern: <b>Download</b></span>
    </div>
    <div class="spacer"></div>
    <div class="group">
      <span id="kpiRes" class="kpi">Aufl√∂sung: ‚Äî</span>
    </div>
  </header>

  <div id="stage" role="region" aria-label="Live-Kamera">
    <div id="banner" role="status" aria-live="polite"></div>
    <video id="video" playsinline muted></video>
    <canvas id="overlay"></canvas>
  </div>

  <div id="bottomBar">
    <label for="zoomSlider">üîé Zoom</label>
    <input id="zoomSlider" type="range" min="1" max="10" step="0.01" value="1" disabled aria-label="Zoom">
    <span id="zoomInfo" class="kpi">Anzeige 1.00√ó | HW ‚Äî</span>
    <span class="spacer"></span>
    <label class="chip" title="Auto-Foto bei Tafel√§nderung"><input type="checkbox" id="tglAuto"> Auto Foto</label>
    <label class="chip" title="Bewegungs-Blocker gegen versehentliche Ausl√∂sung"><input type="checkbox" id="tglBlocker" checked> Objekte blockieren</label>
    <label class="chip" title="Verhindert Auto-Foto wenn Gesichter auf der Tafel sind"><input type="checkbox" id="tglFace"> Face-Blocker</label>
    <label class="chip" title="Texterkennung nach dem Speichern (deu)"><input type="checkbox" id="tglOCR"> OCR</label>
  </div>

  <div id="status">
    <div>Board erkannt: <b id="stBoard" class="bad">nein</b></div>
    <div>Auto: <b id="stAuto" class="warn">aus</b></div>
    <div>Blocker: <b id="stBlock" class="warn">‚Äî</b></div>
    <div>Modelle: <span id="stModels" class="mono">BoardJS(Hough+ROI+Lock), Motion</span></div>
  </div>
</div>

<script>
/* ====== Konfiguration ====== */
const DETECT = {
  // Mehrskalige Global-Detektion
  scale1: 0.50,
  scale2: 0.34,
  // Canny
  borderPct: 0.02,
  cannyK: 0.65,
  cannyLowRel: 0.45,
  // Hough
  thetaBins: 180,
  minLinesPerGroup: 2,
  angleTolDeg: 20,
  // Plausibilit√§t
  areaMin: 0.05,
  areaMax: 0.88,
  alignMin: 0.48,
  rightMin: 0.46,
  scoreCut: 0.55,
  // Kontrastbewertung
  contrastInside: 2.0, // px nach innen
  contrastOutside: 3.0, // px nach au√üen
  contrastScale: 0.12,  // Skala f√ºr Normierung
  // Lock/Hysterese
  acquireHigh: 0.62,
  acquireFrames: 2,
  keepLow: 0.44,
  maxMiss: 24,
  // ROI-Erkennung
  roiPad: 0.20,   // 20% Padding um die alte Box
  roiMax: 520,    // max ROI-Breite
  // Edge-Snapping
  snapRel: 0.06,
  snapSteps: 11
};

/* ===== Short helpers ===== */
const $=s=>document.querySelector(s), on=(el,ev,fn,o)=>el.addEventListener(ev,fn,o);
const clamp=(v,l,h)=>Math.max(l,Math.min(h,v)), fmt=(n,d=2)=>Number(n).toFixed(d);
const banner=$('#banner');
function showBanner(t,cls='warn',ms=3000){
  banner.textContent=t; banner.style.display='block';
  banner.style.borderColor=cls==='bad'?'#7a2a2a':cls==='ok'?'#2f6a45':'#263445';
  clearTimeout(showBanner._t); showBanner._t=setTimeout(()=>banner.style.display='none',ms);
}
function saveLocal(k,v){ try{ localStorage.setItem(k,JSON.stringify(v)); }catch{} }
function loadLocal(k,d){ try{ const v=localStorage.getItem(k); return v?JSON.parse(v):d; }catch{ return d; } }

/* ===== Elements ===== */
const video=$('#video'), overlay=$('#overlay'), ctxOv=overlay.getContext('2d',{willReadFrequently:true});
const btnStart=$('#btnStart'), selCam=$('#selCam'), selQuality=$('#selQuality'), btnSnap=$('#btnSnap');
const btnDir=$('#btnDir'), saveMode=$('#saveMode');
const tglAuto=$('#tglAuto'), tglBlocker=$('#tglBlocker'), tglFace=$('#tglFace'), tglOCR=$('#tglOCR');
const kpiRes=$('#kpiRes'), stBoard=$('#stBoard'), stAuto=$('#stAuto'), stBlock=$('#stBlock'), stModels=$('#stModels');
const zoomSlider=$('#zoomSlider'), zoomInfo=$('#zoomInfo');

/* ===== State ===== */
let mediaStream=null, track=null, caps=null, sets=null;
let hardwareZoom=false, hwMin=1, hwMax=1, displayZoom=1;
let dirHandle=null, haveFSAccess=('showDirectoryPicker' in window);
let loopRunning=false;
let targetW=1600, targetH=900;
let prevThumb=null, lastChangeTs=0; const CHANGE_THRESH=0.09, STABLE_MS=800, COOLDOWN_MS=3500;

/* Tracking/Lock State */
const lockState = {
  locked: false,
  hit: 0, miss: 0,
  quad: null,         // Overlay-Quad (hart, f√ºr Capture)
  smooth: null,       // √úberblendung f√ºr Overlay-Darstellung
  score: 0,
  angles: null        // [thetaA, thetaB] der letzten Box
};

/* ===== Layout & Zoom ===== */
function resizeOverlay(){
  const r=video.getBoundingClientRect();
  overlay.width=Math.max(2,Math.round(r.width||overlay.clientWidth||2));
  overlay.height=Math.max(2,Math.round(r.height||overlay.clientHeight||2));
}
new (window.ResizeObserver||class{observe(){}})(resizeOverlay).observe($('#stage'));
window.addEventListener('resize',resizeOverlay,{passive:true});

function applyDisplayTransform(){ const t=`scale(${displayZoom})`; video.style.transform=t; overlay.style.transform=t; }
on(zoomSlider,'input',()=>applyZoom(parseFloat(zoomSlider.value)));
async function applyZoom(total){
  let hw=1, disp=total;
  if (hardwareZoom){
    hw = clamp(total, hwMin, hwMax);
    try{ await track.applyConstraints({advanced:[{zoom:hw}]}); }catch(e){ hw=1; disp=total; }
    disp = total / hw;
  }
  displayZoom = clamp(disp, 1, 10);
  applyDisplayTransform();
  zoomInfo.textContent=`Anzeige ${fmt(displayZoom,2)}√ó | HW ${hardwareZoom?fmt(hw,2)+'√ó':'‚Äî'}`;
  saveLocal('zoom', displayZoom);
}

/* ===== FS Access ===== */
async function chooseDirectory(){
  if (!haveFSAccess){ showBanner('FS Access API nicht unterst√ºtzt ‚Äì nutze Downloads','warn',4000); return; }
  try{
    dirHandle=await window.showDirectoryPicker({mode:'readwrite'});
    saveMode.innerHTML='Speichern: <b>Ordner</b>'; saveLocal('saveMode','folder');
  }catch{}
}
async function saveImage(blob, base='Tafel'){
  const t=new Date(), p=s=>String(s).padStart(2,'0');
  const name=`${base}_${t.getFullYear()}${p(t.getMonth()+1)}${p(t.getDate())}_${p(t.getHours())}${p(t.getMinutes())}${p(t.getSeconds())}.png`;
  if (dirHandle && haveFSAccess){
    try{
      const perm=await dirHandle.requestPermission?.({mode:'readwrite'});
      if (perm==='granted'){
        const fh=await dirHandle.getFileHandle(name,{create:true});
        const w=await fh.createWritable(); await w.write(blob); await w.close();
        return {mode:'folder',name};
      }
    }catch{}
  }
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=name; document.body.appendChild(a); a.click(); URL.revokeObjectURL(a.href); a.remove();
  return {mode:'download',name};
}

/* ===== Frame helpers ===== */
function frameCanvasOverlay(){
  const c=document.createElement('canvas'); c.width=overlay.width; c.height=overlay.height;
  c.getContext('2d',{willReadFrequently:true}).drawImage(video,0,0,c.width,c.height); return c;
}
function frameCanvasSensor(){
  const vw=video.videoWidth||overlay.width, vh=video.videoHeight||overlay.height;
  const c=document.createElement('canvas'); c.width=vw; c.height=vh;
  c.getContext('2d',{willReadFrequently:true}).drawImage(video,0,0,c.width,c.height); return c;
}
function grayFromCanvas(srcCanvas, tw, th){
  const c=document.createElement('canvas'); c.width=tw; c.height=th;
  const x=c.getContext('2d',{willReadFrequently:true});
  x.filter='blur(0.3px)'; x.drawImage(srcCanvas,0,0,tw,th); x.filter='none';
  const id=x.getImageData(0,0,tw,th).data; const g=new Float32Array(tw*th);
  for(let i=0,j=0;i<id.length;i+=4,j++) g[j]=(0.299*id[i]+0.587*id[i+1]+0.114*id[i+2])/255;
  return {g,w:tw,h:th};
}
function mse(a,b){ if(!a||!b||a.length!==b.length) return 1; let s=0; for(let i=0;i<a.length;i++){ const d=a[i]-b[i]; s+=d*d; } return s/a.length; }

/* ===== Math helpers ===== */
function dot(ax,ay,bx,by){ return ax*bx+ay*by; }
function norm(x,y){ return Math.hypot(x,y)||1; }
function angleBetween(ax,ay,bx,by){
  const n1=norm(ax,ay), n2=norm(bx,by);
  const cos=clamp(dot(ax,ay,bx,by)/(n1*n2),-1,1);
  return Math.acos(cos);
}
function lerp(a,b,t){ return a+(b-a)*t; }

/* ===== Canny (Sobel + NMS + Hysteresis) ===== */
function sobel(gray,w,h){
  const gx=new Float32Array(w*h), gy=new Float32Array(w*h), mag=new Float32Array(w*h), ang=new Float32Array(w*h);
  const idx=(x,y)=>y*w+x;
  for(let y=1;y<h-1;y++){
    for(let x=1;x<w-1;x++){
      const a=gray[idx(x-1,y-1)], b=gray[idx(x,y-1)], c=gray[idx(x+1,y-1)];
      const d=gray[idx(x-1,y)],   e=gray[idx(x,y)],   f=gray[idx(x+1,y)];
      const g=gray[idx(x-1,y+1)], h1=gray[idx(x,y+1)], i=gray[idx(x+1,y+1)];
      const sx = (-1*a + 1*c) + (-2*d + 2*f) + (-1*g + 1*i);
      const sy = (-1*a -2*b -1*c) + (1*g +2*h1 +1*i);
      const m = Math.hypot(sx, sy);
      gx[idx(x,y)]=sx; gy[idx(x,y)]=sy; mag[idx(x,y)]=m; ang[idx(x,y)]=Math.atan2(sy,sx);
    }
  }
  return {gx,gy,mag,ang};
}
function nonMaxSuppression(mag,ang,w,h){
  const out=new Float32Array(w*h), idx=(x,y)=>y*w+x;
  for(let y=1;y<h-1;y++){
    for(let x=1;x<w-1;x++){
      const a=ang[idx(x,y)], m=mag[idx(x,y)];
      const deg=((a*180/Math.PI)+180)%180;
      let dir=0;
      if (deg<22.5 || deg>=157.5) dir=0;
      else if (deg<67.5) dir=45;
      else if (deg<112.5) dir=90;
      else dir=135;
      let m1=0,m2=0;
      if (dir===0){ m1=mag[idx(x-1,y)]; m2=mag[idx(x+1,y)]; }
      else if (dir===45){ m1=mag[idx(x-1,y-1)]; m2=mag[idx(x+1,y+1)]; }
      else if (dir===90){ m1=mag[idx(x,y-1)]; m2=mag[idx(x,y+1)]; }
      else { m1=mag[idx(x-1,y+1)]; m2=mag[idx(x+1,y-1)]; }
      out[idx(x,y)] = (m>=m1 && m>=m2) ? m : 0;
    }
  }
  return out;
}
function hysteresis(nms,w,h,k=DETECT.cannyK,lowRel=DETECT.cannyLowRel,borderPct=DETECT.borderPct){
  const n=w*h;
  let sum=0,sum2=0,count=0;
  for(let i=0;i<n;i++){ const v=nms[i]; if (v>0){ sum+=v; sum2+=v*v; count++; } }
  if (!count) return {edgeMap:new Uint8Array(n), edges:[]};
  const mean=sum/count, std=Math.sqrt(Math.max(0,sum2/count-mean*mean));
  const high=mean + k*std, low=lowRel*high;
  const strong=new Uint8Array(n), weak=new Uint8Array(n);
  for(let i=0;i<n;i++){ const v=nms[i]; if (v>=high) strong[i]=1; else if (v>=low) weak[i]=1; }
  const edgeMap=new Uint8Array(n);
  const idx=(x,y)=>y*w+x;
  const stack=[];
  const mB = Math.round(Math.min(w,h)*borderPct);
  for(let y=1;y<h-1;y++){
    for(let x=1;x<w-1;x++){
      if (x<mB||y<mB||x>=w-mB||y>=h-mB) continue;
      const i=idx(x,y); if (strong[i] && !edgeMap[i]){ edgeMap[i]=1; stack.push(i); }
      while(stack.length){
        const s=stack.pop(); const sx=s%w, sy=(s/w)|0;
        for(let dy=-1;dy<=1;dy++) for(let dx=-1;dx<=1;dx++){
          if(!dx&&!dy) continue;
          const nx=sx+dx, ny=sy+dy;
          if (nx<=0||ny<=0||nx>=w-1||ny>=h-1) continue;
          const ni=idx(nx,ny);
          if (!edgeMap[ni] && weak[ni]){ edgeMap[ni]=1; stack.push(ni); }
        }
      }
    }
  }
  const edges=[];
  for(let y=1;y<h-1;y++) for(let x=1;x<w-1;x++) if (edgeMap[idx(x,y)]) edges.push({x,y});
  return {edgeMap, edges, high, low};
}

/* ===== Hough + Gruppierung ===== */
function houghLines(edges,w,h,thetaBins=DETECT.thetaBins, thetaGate=null){
  const diag=Math.hypot(w,h);
  const rhoBins=Math.max(1, Math.ceil(diag*2));
  const acc=new Uint32Array(thetaBins*rhoBins);
  const cos=new Float32Array(thetaBins), sin=new Float32Array(thetaBins);
  for(let t=0;t<thetaBins;t++){ const th=t*Math.PI/thetaBins; cos[t]=Math.cos(th); sin[t]=Math.sin(th); }
  const allowTheta = (th)=>{
    if (!thetaGate) return true;
    for(const g of thetaGate){
      let d=Math.abs(th-g.center); d=Math.min(d, Math.PI - d);
      if (d<=g.width) return true;
    }
    return false;
  };
  for(const p of edges){
    for(let t=0;t<thetaBins;t++){
      const th=t*Math.PI/thetaBins;
      if (!allowTheta(th)) continue;
      const rho=p.x*cos[t]+p.y*sin[t];
      const rIndex=Math.round(rho+diag);
      acc[t*rhoBins + rIndex]++;
    }
  }
  const peaks=[];
  const winT=3, winR=8;
  const total=edges.length||1;
  for(let t=0;t<thetaBins;t++){
    for(let r=0;r<rhoBins;r++){
      const v=acc[t*rhoBins+r];
      if (v < Math.max(12, total*0.01)) continue;
      let isMax=true;
      for(let dt=-winT;dt<=winT && isMax;dt++){
        for(let dr=-winR;dr<=winR;dr++){
          if (!dt && !dr) continue;
          let tt=t+dt; if (tt<0) tt+=thetaBins; if (tt>=thetaBins) tt-=thetaBins;
          const rr=r+dr; if (rr<0||rr>=rhoBins) continue;
          if (acc[tt*rhoBins+rr] > v){ isMax=false; break; }
        }
      }
      if (isMax){
        peaks.push({thetaIndex:t, rhoIndex:r, votes:v, theta:t*Math.PI/thetaBins, rho:r-diag});
      }
    }
  }
  peaks.sort((a,b)=>b.votes-a.votes);
  // Merge nahe Peaks
  const merged=[];
  const tolTheta=(Math.PI/thetaBins)*3, tolRho=6;
  for(const p of peaks){
    let mergedInto=false;
    for(const q of merged){
      if (Math.abs(p.theta-q.theta)<tolTheta && Math.abs(p.rho-q.rho)<tolRho){
        if (p.votes>q.votes){ Object.assign(q,p); }
        mergedInto=true; break;
      }
    }
    if (!mergedInto) merged.push(p);
    if (merged.length>24) break;
  }
  return merged;
}
function linesToGroups(lines){
  const degTol = DETECT.angleTolDeg * Math.PI/180;
  const cand=lines.slice(0,16);
  let best=null;
  for(let i=0;i<cand.length;i++){
    for(let j=i+1;j<cand.length;j++){
      let d = Math.abs(cand[i].theta - cand[j].theta);
      d = Math.min(d, Math.PI - d);
      if (Math.abs(d - Math.PI/2) <= degTol){
        const near=(base)=>(l)=>Math.min(Math.abs(l.theta-base), Math.PI-Math.abs(l.theta-base)) < degTol;
        const grpA = lines.filter(near(cand[i].theta));
        const grpB = lines.filter(near(cand[j].theta));
        if (grpA.length>=DETECT.minLinesPerGroup && grpB.length>=DETECT.minLinesPerGroup){
          const chooseTwo=(arr)=>{
            let a=null,b=null,maxd=-1;
            for(let m=0;m<arr.length;m++)for(let n=m+1;n<arr.length;n++){
              const d=Math.abs(arr[m].rho - arr[n].rho);
              if (d>maxd){maxd=d; a=arr[m]; b=arr[n];}
            }
            return a&&b? [a,b] : arr.slice(0,2);
          };
          const twoA=chooseTwo(grpA), twoB=chooseTwo(grpB);
          if (twoA.length===2 && twoB.length===2){
            const candScore = cand[i].votes + cand[j].votes + (twoA[0].votes+twoA[1].votes+twoB[0].votes+twoB[1].votes)*0.25;
            if (!best || candScore > best.score) best={A:twoA,B:twoB,score:candScore, thetaA:cand[i].theta, thetaB:cand[j].theta};
          }
        }
      }
    }
  }
  return best;
}
function intersectLines(l1,l2){
  const a1=Math.cos(l1.theta), b1=Math.sin(l1.theta), c1=l1.rho;
  const a2=Math.cos(l2.theta), b2=Math.sin(l2.theta), c2=l2.rho;
  const det=a1*b2 - a2*b1;
  if (Math.abs(det)<1e-6) return null;
  const x=(c1*b2 - c2*b1)/det;
  const y=(a1*c2 - a2*c1)/det;
  return {x,y};
}
function orderTLTRBRBL(pts){
  const bySum=pts.slice().sort((a,b)=>(a.x+a.y)-(b.x+b.y));
  const byDiff=pts.slice().sort((a,b)=>(a.x-a.y)-(b.x-b.y));
  const tl=bySum[0], br=bySum[bySum.length-1], tr=byDiff[byDiff.length-1], bl=byDiff[0];
  return [tl,tr,br,bl];
}
function quadAngles(q){
  const t1=Math.atan2(q[1].y-q[0].y, q[1].x-q[0].x);
  const t2=Math.atan2(q[3].y-q[0].y, q[3].x-q[0].x);
  const nrm=(a)=>{ let x=a%(Math.PI); if (x<0) x+=Math.PI; return x; };
  return [nrm(t1), nrm(t2)];
}

/* Linien-Support auf Bin√§r-Kanten */
function lineSupport(edgeMap,w,h,p0,p1){
  const N=Math.max(10, Math.round(Math.hypot(p1.x-p0.x,p1.y-p0.y)));
  let hit=0, tot=0;
  for(let i=0;i<=N;i++){
    const t=i/N;
    const x=p0.x*(1-t)+p1.x*t, y=p0.y*(1-t)+p1.y*t;
    const xi=Math.round(x), yi=Math.round(y);
    let ok=false;
    for(let dy=-1;dy<=1;dy++) for(let dx=-1;dx<=1;dx++){
      const xx=xi+dx, yy=yi+dy;
      if (xx>=0&&yy>=0&&xx<w&&yy<h && edgeMap[yy*w+xx]){ ok=true; break; }
    }
    if (ok) hit++;
    tot++;
  }
  return hit/Math.max(1,tot);
}

/* Kontrast-Score entlang der Kanten (innen vs. au√üen) */
function edgeContrastScore(gray,w,h,q,insidePx=DETECT.contrastInside,outsidePx=DETECT.contrastOutside){
  const sampleEdge=(p0,p1)=>{
    const dx=p1.x-p0.x, dy=p1.y-p0.y, len=Math.hypot(dx,dy)||1;
    const nx=-(dy/len), ny=(dx/len);
    const N=Math.max(10, Math.round(len));
    let s=0, cnt=0;
    for(let i=0;i<=N;i++){
      const t=i/N; const x=p0.x*(1-t)+p1.x*t, y=p0.y*(1-t)+p1.y*t;
      const xi=Math.round(x), yi=Math.round(y);
      const inx=Math.round(xi - nx*insidePx), iny=Math.round(yi - ny*insidePx);
      const outx=Math.round(xi + nx*outsidePx), outy=Math.round(yi + ny*outsidePx);
      if (inx>=1&&iny>=1&&inx<w-1&&iny<h-1 && outx>=1&&outy>=1&&outx<w-1&&outy<h-1){
        const gi = gray[iny*w+inx], go = gray[outy*w+outx];
        s += Math.abs(gi - go); cnt++;
      }
    }
    return cnt? s/cnt : 0;
  };
  const c = (sampleEdge(q[0],q[1])+sampleEdge(q[1],q[2])+sampleEdge(q[2],q[3])+sampleEdge(q[3],q[0]))/4;
  const score = clamp((c - 0.03)/DETECT.contrastScale, 0, 1); // 0.03 Baseline
  return score;
}

/* Score eines Rechtecks */
function scoreQuad(q, gray, edgeMap, w, h){
  if (!q) return {ok:false, score:0, meta:{}};
  const wTop=Math.hypot(q[1].x-q[0].x,q[1].y-q[0].y), wBot=Math.hypot(q[2].x-q[3].x,q[2].y-q[3].y);
  const hL=Math.hypot(q[3].x-q[0].x,q[3].y-q[0].y), hR=Math.hypot(q[2].x-q[1].x,q[2].y-q[1].y);
  const wA=(wTop+wBot)/2, hA=(hL+hR)/2, asp=wA/Math.max(1,hA);
  const areaPoly=Math.abs( (q[0].x*q[1].y - q[1].x*q[0].y) + (q[1].x*q[2].y - q[2].x*q[1].y) + (q[2].x*q[3].y - q[3].x*q[2].y) + (q[3].x*q[0].y - q[0].x*q[3].y) )/2;
  const areaFrac=areaPoly/(w*h);
  if (areaFrac < DETECT.areaMin || areaFrac > DETECT.areaMax) return {ok:false, score:0, meta:{}};
  if (asp<0.52 || asp>2.20) return {ok:false, score:0, meta:{}};

  const mB = 0.01;
  const minX=Math.min(q[0].x,q[1].x,q[2].x,q[3].x), maxX=Math.max(q[0].x,q[1].x,q[2].x,q[3].x);
  const minY=Math.min(q[0].y,q[1].y,q[2].y,q[3].y), maxY=Math.max(q[0].y,q[1].y,q[2].y,q[3].y);
  let touch=0;
  if (minX <= w*mB) touch++;
  if (minY <= h*mB) touch++;
  if (maxX >= w*(1-mB)) touch++;
  if (maxY >= h*(1-mB)) touch++;
  if (touch>=3) return {ok:false, score:0, meta:{}};

  const a0=angleBetween(q[1].x-q[0].x,q[1].y-q[0].y, q[3].x-q[0].x,q[3].y-q[0].y);
  const a1=angleBetween(q[2].x-q[1].x,q[2].y-q[1].y, q[0].x-q[1].x,q[0].y-q[1].y);
  const d0=Math.abs(a0*180/Math.PI-90), d1=Math.abs(a1*180/Math.PI-90);
  const rightness = 1 - clamp((d0+d1)/60, 0, 1);

  const s01=lineSupport(edgeMap,w,h,q[0],q[1]);
  const s12=lineSupport(edgeMap,w,h,q[1],q[2]);
  const s23=lineSupport(edgeMap,w,h,q[2],q[3]);
  const s30=lineSupport(edgeMap,w,h,q[3],q[0]);
  const align=(s01+s12+s23+s30)/4;

  const contrast = edgeContrastScore(gray,w,h,q);
  const areaCenter = 1 - Math.abs(areaFrac - 0.30)/0.30;

  const score = clamp( 0.20*areaCenter + 0.30*align + 0.25*rightness + 0.25*contrast , 0, 1);
  const ok = (align>=DETECT.alignMin) && (rightness>=DETECT.rightMin) && (score>=DETECT.scoreCut);
  return {ok, score, meta:{areaFrac,align,rightness,contrast,asp}};
}

/* Edge-Snapping (lokale Optimierung) */
function edgeSnapQuad(q, edgeMap, w, h){
  if (!q) return q;
  const shortSide = Math.min(
    Math.hypot(q[1].x-q[0].x,q[1].y-q[0].y),
    Math.hypot(q[2].x-q[1].x,q[2].y-q[1].y),
    Math.hypot(q[3].x-q[2].x,q[3].y-q[2].y),
    Math.hypot(q[0].x-q[3].x,q[0].y-q[3].y)
  );
  const radius = Math.max(1, Math.round(shortSide*DETECT.snapRel));
  const steps = DETECT.snapSteps;
  const refineEdge=(p0,p1)=>{
    const dx=p1.x-p0.x, dy=p1.y-p0.y;
    const len=Math.hypot(dx,dy)||1;
    const nx=-(dy/len), ny=(dx/len);
    let bestT=0, bestScore=-1;
    for(let s=-steps;s<=steps;s++){
      const t = (s/steps)*radius;
      const a={x:p0.x+nx*t, y:p0.y+ny*t}, b={x:p1.x+nx*t, y:p1.y+ny*t};
      const sup=lineSupport(edgeMap,w,h,a,b);
      if (sup>bestScore){ bestScore=sup; bestT=t; }
    }
    return {p0:{x:p0.x+nx*bestT,y:p0.y+ny*bestT}, p1:{x:p1.x+nx*bestT,y:p1.y+ny*bestT}};
  };
  const e01=refineEdge(q[0],q[1]);
  const e12=refineEdge(q[1],q[2]);
  const e23=refineEdge(q[2],q[3]);
  const e30=refineEdge(q[3],q[0]);
  return orderTLTRBRBL([e01.p0, e01.p1, e23.p0, e23.p1]);
}

/* ===== Detection primitives ===== */
function detectOnCanvas(frameCanvas, priorAngles=null){
  const scales=[DETECT.scale1, DETECT.scale2];
  let best=null, bestScore=-1, bestScale={sx:1,sy:1};

  for (const sc of scales){
    const w=Math.max(180, Math.round(frameCanvas.width*sc));
    const h=Math.max(100, Math.round(frameCanvas.height*sc));
    const {g, w:tw, h:th} = grayFromCanvas(frameCanvas, w, h);
    const {mag,ang} = sobel(g,tw,th);
    const nms = nonMaxSuppression(mag,ang,tw,th);
    const {edgeMap, edges} = hysteresis(nms,tw,th,DETECT.cannyK,DETECT.cannyLowRel,DETECT.borderPct);
    if (edges.length < (tw*th*0.0035)) continue;

    // Winkelgate
    let gate=null;
    if (priorAngles){
      const wAng = (DETECT.angleTolDeg*Math.PI/180)*1.25;
      gate = [{center:priorAngles[0], width:wAng},{center:priorAngles[1], width:wAng}];
    }

    const lines = houghLines(edges, tw, th, DETECT.thetaBins, gate);
    if (lines.length < 4) continue;
    const groups = linesToGroups(lines);
    if (!groups) continue;

    const L = [groups.A[0], groups.A[1], groups.B[0], groups.B[1]];
    const p0=intersectLines(L[0],L[2]), p1=intersectLines(L[1],L[2]);
    const p2=intersectLines(L[1],L[3]), p3=intersectLines(L[0],L[3]);
    if (!p0||!p1||!p2||!p3) continue;
    let quad=orderTLTRBRBL([p0,p1,p2,p3]);
    quad = edgeSnapQuad(quad, edgeMap, tw, th);

    const s = scoreQuad(quad, g, edgeMap, tw, th);
    if (s.ok && s.score>bestScore){
      bestScore=s.score; best=quad; bestScale={sx:frameCanvas.width/tw, sy:frameCanvas.height/th};
    }
  }

  if (!best) return null;
  return {quad: best.map(p=>({x:p.x*bestScale.sx, y:p.y*bestScale.sy})), score: bestScore};
}

/* ROI-Helfer */
function quadBounds(q){
  const minX=Math.min(...q.map(p=>p.x)), maxX=Math.max(...q.map(p=>p.x));
  const minY=Math.min(...q.map(p=>p.y)), maxY=Math.max(...q.map(p=>p.y));
  return {x:minX, y:minY, w:maxX-minX, h:maxY-minY};
}
function extractROI(canvas, quad, padFrac=DETECT.roiPad){
  const b=quadBounds(quad);
  const pad = Math.max(b.w, b.h)*padFrac;
  const x=Math.max(0, Math.round(b.x - pad));
  const y=Math.max(0, Math.round(b.y - pad));
  const w=Math.min(canvas.width - x, Math.round(b.w + 2*pad));
  const h=Math.min(canvas.height - y, Math.round(b.h + 2*pad));
  // ggf. auf ROI-Max herunter skalieren
  const scale = w>DETECT.roiMax ? (DETECT.roiMax / w) : 1;
  const rw=Math.max(20, Math.round(w*scale)), rh=Math.max(20, Math.round(h*scale));
  const roi=document.createElement('canvas'); roi.width=rw; roi.height=rh;
  roi.getContext('2d',{willReadFrequently:true}).drawImage(canvas, x,y,w,h, 0,0,rw,rh);
  return {roi, x, y, w, h, scale};
}
function mapRoiQuadToOverlay(quadRoi, roiInfo){
  const sx = roiInfo.w/roiInfo.roi.width;
  const sy = roiInfo.h/roiInfo.roi.height;
  return quadRoi.map(p=>({ x: roiInfo.x + p.x*sx, y: roiInfo.y + p.y*sy }));
}

/* ===== Haupt-Erkennung (Global + ROI) ===== */
function detectBoardGlobal(frameCanvas, priorAngles=null){
  return detectOnCanvas(frameCanvas, priorAngles);
}
function detectBoardInROI(frameCanvas, overlayQuad, priorAngles=null){
  const roiInfo = extractROI(frameCanvas, overlayQuad, DETECT.roiPad);
  const res = detectOnCanvas(roiInfo.roi, priorAngles);
  if (!res) return null;
  return {quad: mapRoiQuadToOverlay(res.quad, roiInfo), score: res.score};
}

/* ===== Overlay <-> Video mapping (object-fit: cover) ===== */
function overlayToVideoPoint(pt){
  const ow=overlay.width, oh=overlay.height;
  const vw=video.videoWidth||ow, vh=video.videoHeight||oh;
  if (!vw||!vh) return {x:pt.x, y:pt.y};
  const s=Math.max(ow/vw, oh/vh);
  const dw=vw*s, dh=vh*s;
  const dx=(ow - dw)/2, dy=(oh - dh)/2;
  const x=(pt.x - dx)/s, y=(pt.y - dy)/s;
  return { x: clamp(x,0,vw-1), y: clamp(y,0,vh-1) };
}
function mapQuadOverlayToVideo(q){ return q.map(p=>overlayToVideoPoint(p)); }

/* ===== Homographie + WebGL Warp ===== */
function computeHomography(srcPts, dstPts){
  const A=new Array(8).fill(0).map(()=>new Float64Array(8));
  const b=new Float64Array(8);
  for(let i=0;i<4;i++){
    const x=srcPts[i].x, y=srcPts[i].y, X=dstPts[i].x, Y=dstPts[i].y;
    const r0=i*2, r1=i*2+1;
    A[r0][0]=x; A[r0][1]=y; A[r0][2]=1; A[r0][3]=0; A[r0][4]=0; A[r0][5]=0; A[r0][6]=-x*X; A[r0][7]=-y*X; b[r0]=X;
    A[r1][0]=0; A[r1][1]=0; A[r1][2]=0; A[r1][3]=x; A[r1][4]=y; A[r1][5]=1; A[r1][6]=-x*Y; A[r1][7]=-y*Y; b[r1]=Y;
  }
  const h=gaussSolve(A,b); if (!h) return null;
  return [[h[0],h[1],h[2]],[h[3],h[4],h[5]],[h[6],h[7],1]];
}
function gaussSolve(A,b){
  const n=8;
  for(let i=0;i<n;i++){ A[i]=Float64Array.from([...A[i], b[i]]); }
  for(let col=0; col<n; col++){
    let piv=col;
    for(let r=col+1;r<n;r++) if (Math.abs(A[r][col])>Math.abs(A[piv][col])) piv=r;
    if (Math.abs(A[piv][col])<1e-12) return null;
    if (piv!==col){ const tmp=A[col]; A[col]=A[piv]; A[piv]=tmp; }
    const div=A[col][col];
    for(let c=col;c<=n;c++) A[col][c]/=div;
    for(let r=0;r<n;r++){
      if (r===col) continue;
      const factor=A[r][col]; if (factor===0) continue;
      for(let c=col;c<=n;c++) A[r][c]-=factor*A[col][c];
    }
  }
  const x=new Float64Array(n);
  for(let i=0;i<n;i++) x[i]=A[i][n];
  return x;
}
function mat3Inv(m){
  const a=m[0][0], b=m[0][1], c=m[0][2];
  const d=m[1][0], e=m[1][1], f=m[1][2];
  const g=m[2][0], h=m[2][1], i=m[2][2];
  const A=e*i - f*h, B=-(d*i - f*g), C=d*h - e*g;
  const D=-(b*i - c*h), E=a*i - c*g, F=-(a*h - b*g);
  const G=b*f - c*e, H=-(a*f - c*d), I=a*e - b*d;
  const det=a*A + b*B + c*C;
  if (Math.abs(det)<1e-12) return null;
  const inv=[[A,B,C],[D,E,F],[G,H,I]];
  for(let r=0;r<3;r++) for(let s=0;s<3;s++) inv[r][s]/=det;
  return inv;
}
function warpBoardWebGL(srcCanvas, srcQuad, outW, outH){
  const glCanvas=document.createElement('canvas'); glCanvas.width=outW; glCanvas.height=outH;
  const gl=glCanvas.getContext('webgl',{preserveDrawingBuffer:true});
  if(!gl) return null;

  const dstQuad=[{x:0,y:0},{x:outW,y:0},{x:outW,y:outH},{x:0,y:outH}];
  const H=computeHomography(srcQuad, dstQuad); if(!H) return null;
  const Hinv=mat3Inv(H); if(!Hinv) return null;

  const vs=`attribute vec2 aPos; varying vec2 vPos; void main(){ vPos=aPos*0.5+0.5; gl_Position=vec4(aPos,0.0,1.0); }`;
  const fs=`precision mediump float; varying vec2 vPos; uniform sampler2D uTex; uniform vec2 uSrcSize; uniform mat3 uHinv;
    void main(){
      vec3 d = vec3(vPos.x*${outW.toFixed(1)}, vPos.y*${outH.toFixed(1)}, 1.0);
      vec3 s = uHinv * d;
      float sx = s.x / s.z; float sy = s.y / s.z;
      vec2 uv = vec2(sx / uSrcSize.x, sy / uSrcSize.y);
      if (uv.x<0.0 || uv.x>1.0 || uv.y<0.0 || uv.y>1.0) discard;
      gl_FragColor = texture2D(uTex, uv);
    }`;
  function compile(type,src){
    const sh=gl.createShader(type); gl.shaderSource(sh,src); gl.compileShader(sh);
    if(!gl.getShaderParameter(sh,gl.COMPILE_STATUS)){ console.error(gl.getShaderInfoLog(sh)); return null; }
    return sh;
  }
  const prog=gl.createProgram();
  const vsh=compile(gl.VERTEX_SHADER,vs), fsh=compile(gl.FRAGMENT_SHADER,fs);
  if(!vsh||!fsh) return null;
  gl.attachShader(prog,vsh); gl.attachShader(prog,fsh); gl.linkProgram(prog);
  if(!gl.getProgramParameter(prog, gl.LINK_STATUS)){ console.error(gl.getProgramInfoLog(prog)); return null; }
  gl.useProgram(prog);

  const pos=new Float32Array([ -1,-1,  1,-1,  -1,1,  1,1 ]);
  const vbo=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER,vbo); gl.bufferData(gl.ARRAY_BUFFER,pos,gl.STATIC_DRAW);
  const loc=gl.getAttribLocation(prog,'aPos'); gl.enableVertexAttribArray(loc); gl.vertexAttribPointer(loc,2,gl.FLOAT,false,0,0);

  const tex=gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D,tex);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);
  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
  gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,srcCanvas);

  const uTex=gl.getUniformLocation(prog,'uTex'); gl.uniform1i(uTex,0);
  const uSrcSize=gl.getUniformLocation(prog,'uSrcSize'); gl.uniform2f(uSrcSize, srcCanvas.width, srcCanvas.height);
  const uHinv=gl.getUniformLocation(prog,'uHinv');
  const HinvFlat=new Float32Array([Hinv[0][0],Hinv[0][1],Hinv[0][2], Hinv[1][0],Hinv[1][1],Hinv[1][2], Hinv[2][0],Hinv[2][1],Hinv[2][2]]);
  gl.uniformMatrix3fv(uHinv,false,HinvFlat);

  gl.viewport(0,0,outW,outH);
  gl.clearColor(0,0,0,0); gl.clear(gl.COLOR_BUFFER_BIT);
  gl.drawArrays(gl.TRIANGLE_STRIP,0,4);

  return glCanvas;
}

/* ===== Face & OCR (lazy) ===== */
let faceModel=null, tfLoaded=false, blazeLoaded=false, tessLoaded=false;
function loadScript(src){
  return new Promise((res,rej)=>{
    const s=document.createElement('script');
    s.src=src; s.async=true; s.crossOrigin='anonymous'; s.referrerPolicy='no-referrer';
    s.onload=()=>res(); s.onerror=e=>rej(e); document.head.appendChild(s);
  });
}
async function ensureFace(){
  if (!tglFace.checked) return false;
  if (!tfLoaded){ try{ await loadScript('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js'); tfLoaded=true; }catch{ try{ await loadScript('https://unpkg.com/@tensorflow/tfjs@4.22.0/dist/tf.min.js'); tfLoaded=true; }catch(e){} } }
  if (!blazeLoaded){ try{ await loadScript('https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface@0.1.2/dist/blazeface.min.js'); blazeLoaded=true; }catch{ try{ await loadScript('https://unpkg.com/@tensorflow-models/blazeface@0.1.2/dist/blazeface.min.js'); blazeLoaded=true; }catch(e){} } }
  if (window.blazeface && !faceModel){ try{ faceModel=await blazeface.load(); if(!stModels.textContent.includes('BlazeFace')) stModels.textContent+=', BlazeFace'; }catch(e){} }
  return !!faceModel;
}
function triArea(a,b,c){ return Math.abs((a.x*(b.y-c.y)+b.x*(c.y-a.y)+c.x*(a.y-b.y))/2); }
function polyArea(q){ return triArea(q[0],q[1],q[2])+triArea(q[0],q[2],q[3]); }
function pointInQuad(p,q){ const A=polyArea(q); const s=triArea(p,q[0],q[1])+triArea(p,q[1],q[2])+triArea(p,q[2],q[3])+triArea(p,q[3],q[0]); return Math.abs(s-A)<1e-1*A; }
async function faceBlockVerdict(canvasOverlay){
  if (!tglFace.checked || !lockState.locked) return false;
  try{ const ok=await ensureFace(); if(!ok) return false;
    const preds=await faceModel.estimateFaces(canvasOverlay,false); if(!preds?.length) return false;
    for (const p of preds){ if(!p.topLeft||!p.bottomRight) continue; const cx=(p.topLeft[0]+p.bottomRight[0])/2, cy=(p.topLeft[1]+p.bottomRight[1])/2; if (pointInQuad({x:cx,y:cy}, lockState.quad)) return true; }
  }catch(e){}
  return false;
}
async function ensureOCR(){
  if (!tglOCR.checked) return false;
  if (!tessLoaded){
    try{ await loadScript('https://cdn.jsdelivr.net/npm/tesseract.js@5.1.1/dist/tesseract.min.js'); tessLoaded=true; }
    catch{ try{ await loadScript('https://unpkg.com/tesseract.js@5.1.1/dist/tesseract.min.js'); tessLoaded=true; }catch(e){} }
    if (tessLoaded && !stModels.textContent.includes('OCR')) stModels.textContent+=', OCR';
  }
  return tessLoaded;
}
async function runOCR(canvas){
  try{ const ok=await ensureOCR(); if(!ok) return; const worker=await Tesseract.createWorker('deu');
    const {data:{text}}=await worker.recognize(canvas); await worker.terminate(); console.log('OCR (deu):',text);
  }catch(e){}
}

/* ===== Kamera & Qualit√§t (Back-Facing bevorzugt) ===== */
async function listCameras(){
  const devs=await navigator.mediaDevices.enumerateDevices();
  const cams=devs.filter(d=>d.kind==='videoinput');
  const isBack = l=>{
    l=(l||'').toLowerCase();
    return l.includes('back')||l.includes('rear')||l.includes('environment')||l.includes('r√ºck')||l.includes('world');
  };
  const backCams = cams.filter(c=>isBack(c.label));
  const list = backCams.length? backCams : cams;
  selCam.innerHTML='';
  list.forEach(c=>{
    const o=document.createElement('option'); o.value=c.deviceId;
    const lab=c.label||`Kamera ${c.deviceId.slice(0,6)}`;
    o.textContent = (backCams.length? lab : `${lab} (kein Back-Hinweis)`);
    selCam.appendChild(o);
  });
  selCam.disabled=list.length===0;
}
async function restartStreamWithConstraints(cons){
  if (mediaStream){ mediaStream.getTracks().forEach(t=>t.stop()); mediaStream=null; }
  mediaStream=await navigator.mediaDevices.getUserMedia(cons);
  video.srcObject=mediaStream; await video.play().catch(()=>{});
  track=mediaStream.getVideoTracks()[0]; caps=track.getCapabilities?.()||{}; sets=track.getSettings?.()||{};
  hardwareZoom='zoom' in (caps||{}); if (hardwareZoom){ hwMin=caps.zoom.min??1; hwMax=caps.zoom.max??1; }
  await new Promise(r=> video.onloadedmetadata ? (video.onloadedmetadata=()=>r()) : setTimeout(r,120));
  resizeOverlay(); applyDisplayTransform();
  kpiRes.textContent=`Aufl√∂sung: ${sets.width||video.videoWidth||'‚Äî'}√ó${sets.height||video.videoHeight||'‚Äî'}`;
}
async function startCamera(deviceId=null){
  try{
    btnStart.disabled=true;
    if (!navigator.mediaDevices?.getUserMedia){ showBanner('getUserMedia nicht verf√ºgbar (HTTPS/Browser pr√ºfen)','bad',7000); btnStart.disabled=false; return; }
    let cons = deviceId
      ? {video:{deviceId:{exact:deviceId}, facingMode:{ideal:'environment'}}, audio:false}
      : {video:{facingMode:{exact:'environment'}, width:{ideal:1920}, height:{ideal:1080}, frameRate:{ideal:30,max:60}}, audio:false};
    try{ await restartStreamWithConstraints(cons); }
    catch(e1){
      try{ await restartStreamWithConstraints({video:{facingMode:{ideal:'environment'}}, audio:false}); }
      catch(e2){
        await restartStreamWithConstraints({video:true, audio:false});
        showBanner('Keine R√ºckkamera erkennbar ‚Äì nutze verf√ºgbare Kamera', 'warn', 5000);
      }
    }
    await listCameras(); selQuality.disabled=false; btnSnap.disabled=false; zoomSlider.disabled=false;

    try{ await track.applyConstraints({advanced:[{focusMode:'continuous'},{exposureMode:'continuous'},{whiteBalanceMode:'continuous'}]}); }catch{}

    if (selQuality.value==='auto') await setMaxResolution(); else await applyQualityPreset(selQuality.value);
    sets=track.getSettings?.()||sets; kpiRes.textContent=`Aufl√∂sung: ${sets.width||'‚Äî'}√ó${sets.height||'‚Äî'}`;
    if (!loopRunning){ loopRunning=true; processingLoop(); }
    showBanner('Kamera l√§uft','ok',1500);
    saveLocal('camId', track.getSettings?.().deviceId||null);
  }catch(err){
    let msg=err.name+': '+err.message;
    if (err.name==='NotAllowedError') msg='Kamera-Zugriff verweigert';
    if (err.name==='NotFoundError') msg='Keine Kamera gefunden';
    if (err.name==='NotReadableError') msg='Kamera belegt';
    if (err.name==='OverconstrainedError') msg='Constraint nicht erf√ºllbar';
    showBanner('Kamera-Fehler: '+msg,'bad',7000);
    btnStart.disabled=false;
  }
}
async function setMaxResolution(){
  if (!track?.getCapabilities) return false;
  const c=track.getCapabilities(); const wMax=c.width&&c.width.max, hMax=c.height&&c.height.max, fpsMax=c.frameRate&&c.frameRate.max;
  if (wMax&&hMax){
    try{
      const adv = c.resizeMode? [{resizeMode:'none'}] : [];
      await track.applyConstraints({ width:{exact:wMax}, height:{exact:hMax}, ...(fpsMax?{frameRate:{ideal:Math.min(60,fpsMax)}}:{}), ...(adv.length?{advanced:adv}:{}) });
      await new Promise(r=>setTimeout(r,120));
      const s=track.getSettings?.(); if (s && s.width===wMax && s.height===hMax) return true;
    }catch{}
  }
  const deviceId = track?.getSettings?.().deviceId;
  const cons = deviceId? { video:{ deviceId:{exact:deviceId}, width:{exact:wMax||3840}, height:{exact:hMax||2160} }, audio:false } :
                         { video:{ facingMode:{ideal:'environment'}, width:{exact:wMax||3840}, height:{exact:hMax||2160} }, audio:false };
  try{ await restartStreamWithConstraints(cons); return true; }catch{}
  const ladder=[{w:3840,h:2160},{w:2560,h:1440},{w:1920,h:1080},{w:1280,h:720}];
  for (const p of ladder){
    const lc = deviceId? { video:{ deviceId:{exact:deviceId}, width:{exact:p.w}, height:{exact:p.h} }, audio:false }
                       : { video:{ facingMode:{ideal:'environment'}, width:{exact:p.w}, height:{exact:p.h} }, audio:false };
    try{ await restartStreamWithConstraints(lc); return true; }catch{}
  }
  return false;
}
async function applyQualityPreset(q){
  if (!track) return;
  const map={ '2160':{w:3840,h:2160}, '1440':{w:2560,h:1440}, '1080':{w:1920,h:1080}, '720':{w:1280,h:720} };
  const p=map[q]; if (!p) return;
  const deviceId = track?.getSettings?.().deviceId;
  const cons = deviceId? { video:{ deviceId:{exact:deviceId}, width:{exact:p.w}, height:{exact:p.h} }, audio:false }
                       : { video:{ facingMode:{ideal:'environment'}, width:{exact:p.w}, height:{exact:p.h} }, audio:false };
  try{ await restartStreamWithConstraints(cons); }catch(e){ /* ignore */ }
}
on(selQuality,'change',async()=>{ if (selQuality.value==='auto') await setMaxResolution(); else await applyQualityPreset(selQuality.value); });
on(selCam,'change',()=>startCamera(selCam.value));

/* ===== Live Loop (Global + ROI + Lock) ===== */
function drawOverlayQuad(q){
  const ow=overlay.width, oh=overlay.height;
  ctxOv.clearRect(0,0,ow,oh);
  if (!q) return;
  ctxOv.lineWidth=3.5; ctxOv.strokeStyle='rgba(78,161,255,1.0)'; ctxOv.fillStyle='rgba(78,161,255,0.15)';
  ctxOv.beginPath(); ctxOv.moveTo(q[0].x,q[0].y); for(let i=1;i<4;i++) ctxOv.lineTo(q[i].x,q[i].y); ctxOv.closePath(); ctxOv.stroke(); ctxOv.fill();
}
function emwaQuad(prev,cur,alpha=0.35){
  if (!prev) return cur;
  return cur.map((p,i)=>({x:lerp(prev[i].x,p.x,alpha), y:lerp(prev[i].y,p.y,alpha)}));
}
async function processingLoop(){
  let frameIdx=0, lastMotion=null; const MOTION_T=0.18, MOTION_FRAC=0.035;
  let prevGray=null;

  const step = async ()=>{
    if (!mediaStream){ loopRunning=false; return; }
    const ow=overlay.width, oh=overlay.height;
    if (ow>2 && oh>2){
      const frameOverlay=frameCanvasOverlay();
      try{
        let det=null;

        if (lockState.locked){
          // 1) ROI-Re-Detect um die alte Box (engen Winkel-Gate)
          det = detectBoardInROI(frameOverlay, lockState.quad, lockState.angles);
          // 2) Wenn das zu schwach ist, nur Snapping-basierter Erhalt
          if (!det){
            const sc=0.40, w=Math.max(180, Math.round(frameOverlay.width*sc)), h=Math.max(100, Math.round(frameOverlay.height*sc));
            const {g, w:tw, h:th} = grayFromCanvas(frameOverlay, w, h);
            const {mag,ang} = sobel(g,tw,th);
            const nms = nonMaxSuppression(mag,ang,tw,th);
            const {edgeMap} = hysteresis(nms,tw,th,DETECT.cannyK,DETECT.cannyLowRel,DETECT.borderPct);
            const ds=(p)=>({x:p.x*(tw/frameOverlay.width), y:p.y*(th/frameOverlay.height)});
            const qPrev = lockState.quad.map(ds);
            const qSnap = edgeSnapQuad(orderTLTRBRBL(qPrev), edgeMap, tw, th);
            const s = scoreQuad(qSnap, g, edgeMap, tw, th);
            if (s.ok){
              const us=(p)=>({x:p.x*(frameOverlay.width/tw), y:p.y*(frameOverlay.height/th)});
              det = {quad: qSnap.map(us), score: s.score};
            }
          }
          // 3) Falls schon mehrere Misses: Global-Detekt als Recovery
          if (!det && lockState.miss>Math.floor(DETECT.maxMiss/3)){
            det = detectBoardGlobal(frameOverlay, lockState.angles);
          }
        } else {
          // Nicht gelockt -> Global Detect, leicht h√§ufiger
          if (frameIdx%2===0) det = detectBoardGlobal(frameOverlay, null);
        }

        if (det){
          // Zielgr√∂√üe aktualisieren
          const q=det.quad;
          const wTop=Math.hypot(q[1].x-q[0].x,q[1].y-q[0].y);
          const wBot=Math.hypot(q[2].x-q[3].x,q[2].y-q[3].y);
          const hL=Math.hypot(q[3].x-q[0].x,q[3].y-q[0].y);
          const hR=Math.hypot(q[2].x-q[1].x,q[2].y-q[1].y);
          const wA=(wTop+wBot)/2, hA=(hL+hR)/2, asp=wA/Math.max(1,hA);
          targetW=1600; targetH=Math.round(targetW/asp);

          // Lock/Hysterese
          lockState.score = det.score;
          if (!lockState.locked){
            if (det.score >= DETECT.acquireHigh){
              lockState.hit++;
              if (lockState.hit >= DETECT.acquireFrames){
                lockState.locked = true; lockState.quad = det.quad; lockState.miss=0; lockState.angles=quadAngles(det.quad);
              }
            } else lockState.hit = 0;
          } else {
            if (det.score >= DETECT.keepLow){
              lockState.quad = det.quad; lockState.miss = 0; lockState.angles=quadAngles(det.quad);
            } else {
              lockState.miss++;
            }
          }
        } else {
          if (lockState.locked) lockState.miss++;
          else lockState.hit=0;
        }

        // Lock verlieren nur bei vielen Misses
        if (lockState.locked && lockState.miss >= DETECT.maxMiss){
          lockState.locked=false; lockState.hit=0; lockState.miss=0; lockState.angles=null; lockState.quad=null; lockState.smooth=null;
        }

        // Zeichnen
        lockState.smooth = lockState.locked && lockState.quad ? emwaQuad(lockState.smooth, lockState.quad, 0.35) : null;
        drawOverlayQuad(lockState.smooth);
        stBoard.textContent=lockState.locked?'ja':'nein'; stBoard.className=lockState.locked?'ok':'bad';

        // Change/Auto (nur wenn locked)
        if (lockState.locked){
          const {g:wgray} = grayFromCanvas(frameOverlay,128,72);
          const diffVal=prevThumb?mse(wgray,prevThumb):null; prevThumb=wgray;

          if (!lastMotion){ const {g:m0} = grayFromCanvas(frameOverlay,128,72); lastMotion=m0; }
          const {g:cur} = grayFromCanvas(frameOverlay,128,72);
          let ch=0; for(let i=0;i<cur.length;i++) if (Math.abs(cur[i]-lastMotion[i])>MOTION_T) ch++;
          const frac=ch/cur.length, motionBlock=frac>MOTION_FRAC; lastMotion=cur.slice(0);

          stBlock.textContent=tglBlocker.checked?(motionBlock?'blockiert':'frei'):'aus';
          stBlock.className=tglBlocker.checked?(motionBlock?'bad':'ok'):'warn';

          const now=performance.now(), stable=(now-lastChangeTs)>STABLE_MS;
          if (tglAuto.checked && diffVal!==null && diffVal>CHANGE_THRESH && stable){
            const cooldown=(now-(processingLoop._lastCap||0))>COOLDOWN_MS;
            const blockOk=tglBlocker.checked?!motionBlock:true;
            const faceOk=!(await faceBlockVerdict(frameOverlay));
            if (cooldown && blockOk && faceOk){ await captureAndSave('Auto'); processingLoop._lastCap=performance.now(); lastChangeTs=now; }
          }
        }
      }catch(e){
        console.error(e);
        lockState.miss++;
        if (lockState.miss >= DETECT.maxMiss){
          lockState.locked=false; lockState.hit=0; lockState.miss=0; lockState.angles=null; lockState.quad=null; lockState.smooth=null;
        }
        drawOverlayQuad(lockState.smooth);
      }
    }
    frameIdx++; requestAnimationFrame(step);
  };
  requestAnimationFrame(step);
}

/* ===== Capture & Warp ===== */
function canvasToBlob(canvas, type='image/png', quality=0.95){
  return new Promise(res=>{
    if (canvas.toBlob) canvas.toBlob(b=>res(b), type, quality);
    else { const dataURL=canvas.toDataURL(type, quality);
      const bstr=atob(dataURL.split(',')[1]); let n=bstr.length; const u8=new Uint8Array(n);
      while(n--) u8[n]=bstr.charCodeAt(n); res(new Blob([u8],{type}));
    }
  });
}
async function captureAndSave(prefix='Tafel'){
  try{
    let out=null;
    const frameSensor=frameCanvasSensor(); // volle Sensor-Aufl√∂sung
    if (lockState.locked && lockState.quad){
      const quadVideo = mapQuadOverlayToVideo(lockState.quad);
      const warped=warpBoardWebGL(frameSensor, quadVideo, targetW, targetH);
      out = warped || frameSensor;
    } else {
      out = frameSensor;
    }
    const blob=await canvasToBlob(out,'image/png',0.95);
    const r=await saveImage(blob,prefix); showBanner(`Foto gespeichert (${r.mode})`,'ok',1600);
    if (tglOCR.checked) runOCR(out);
  }catch(e){ console.error(e); showBanner('Fehler beim Speichern','bad',4000); }
}

/* ===== Events ===== */
on(btnStart,'click',()=>startCamera(loadLocal('camId',null)));
on(btnSnap,'click',()=>captureAndSave('Manuell'));
on(btnDir,'click',chooseDirectory);
on(tglAuto,'change',()=>{ stAuto.textContent=tglAuto.checked?'an':'aus'; stAuto.className=tglAuto.checked?'ok':'warn'; saveLocal('tglAuto', tglAuto.checked); });
on(tglBlocker,'change',()=>saveLocal('tglBlocker', tglBlocker.checked));
on(tglFace,'change',()=>saveLocal('tglFace', tglFace.checked));
on(tglOCR,'change',()=>saveLocal('tglOCR', tglOCR.checked));

/* ===== Init ===== */
(function init(){
  tglAuto.checked = loadLocal('tglAuto', false);
  tglBlocker.checked = loadLocal('tglBlocker', true);
  tglFace.checked = loadLocal('tglFace', false);
  tglOCR.checked = loadLocal('tglOCR', false);
  const z=loadLocal('zoom', 1); zoomSlider.value=z; displayZoom=z; applyDisplayTransform();
  stAuto.textContent=tglAuto.checked?'an':'aus'; stAuto.className=tglAuto.checked?'ok':'warn';
  saveMode.innerHTML = haveFSAccess ? 'Speichern: <b>Download / Ordner</b>' : 'Speichern: <b>Download</b>';
  zoomInfo.textContent=`Anzeige ${fmt(displayZoom,2)}√ó | HW ‚Äî`;

  navigator.mediaDevices?.enumerateDevices?.().then(()=>listCameras()).catch(()=>{});
  resizeOverlay();

  window.addEventListener('error',e=>{ console.error(e.error||e.message); showBanner('Unerwarteter Fehler ‚Äì versuche weiterzuarbeiten','warn',4000); }, {once:false});
  window.addEventListener('unhandledrejection',e=>{ console.error(e.reason); showBanner('Fehler in Hintergrundaufgabe','warn',3000); });
})();
</script>
</body>
</html>
