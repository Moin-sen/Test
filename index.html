<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,height=device-height,initial-scale=1,viewport-fit=cover,user-scalable=no" />
<meta name="theme-color" content="#0b0e13">
<title>TafelCapture ‚Äì Universal</title>
<meta name="description" content="Tafel/Whiteboard automatisch erfassen: Erkennung, entzerrt speichern, optional OCR. L√§uft komplett im Browser.">
<meta property="og:title" content="TafelCapture" />
<meta property="og:description" content="Tafel/Whiteboard automatisch erfassen ‚Äì direkt im Browser." />
<meta property="og:type" content="website" />
<style>
  :root{
    color-scheme: dark;
    --bg:#0b0e13; --fg:#e9eef5; --muted:#a7b3c0; --accent:#4ea1ff;
    --ok:#11c46a; --warn:#ffb020; --bad:#ff4d6d;
    --bar:#0f131acc; --bar-border:#1a212c; --chip:#16202c;
  }
  html,body{margin:0;padding:0;background:var(--bg);color:var(--fg);
    font-family:system-ui,"Segoe UI",Roboto,Ubuntu,sans-serif;height:100%;
    -webkit-text-size-adjust:100%;
  }
  #app{display:grid;grid-template-rows:auto 1fr auto auto;min-height:100svh}
  header{
    display:flex;flex-wrap:wrap;gap:.5rem;align-items:center;
    padding:.5rem .75rem;background:#0f131a;border-bottom:1px solid var(--bar-border)
  }
  header .group{display:flex;gap:.5rem;align-items:center;flex-wrap:wrap}
  button,select,label.chip{
    background:var(--chip);color:var(--fg);border:1px solid #223041;border-radius:.55rem;
    padding:.5rem .65rem;font-size:.95rem;line-height:1;min-height:2.25rem
  }
  button.primary{background:#1a2b3f;border-color:#2a4060}
  .kpi{font-variant-numeric:tabular-nums;color:var(--muted)} .kpi b{color:var(--fg)}
  .spacer{flex:1}
  #stage{position:relative;background:#000;overflow:hidden}
  video,canvas#overlay{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;transform-origin:center}
  canvas#overlay{pointer-events:none}
  #banner{
    position:absolute;left:50%;top:calc(8px + env(safe-area-inset-top));
    transform:translateX(-50%);background:rgba(0,0,0,.85);
    border:1px solid #263445;border-radius:.5rem;padding:.5rem .7rem;font-size:.95rem;
    z-index:5;display:none
  }
  #bottomBar{
    display:flex;flex-wrap:wrap;gap:.5rem;align-items:center;
    padding:.55rem .75rem;background:#0f131a;border-top:1px solid var(--bar-border)
  }
  #zoomSlider{width:min(560px,100%)}
  #status{
    display:grid;grid-template-columns:repeat(4,auto);gap:.6rem 1rem;align-items:center;
    padding:.4rem .75rem;font-size:.9rem;color:var(--muted)
  }
  .ok{color:var(--ok)} .warn{color:var(--warn)} .bad{color:var(--bad)} .mono{font-family:ui-monospace,Menlo,Consolas,monospace}

  /* Querformat-Optimierung: kompakte Floating-Bars */
  @media (orientation:landscape){
    #app{grid-template-rows:1fr}
    header,#bottomBar,#status{
      position:fixed;left:calc(8px + env(safe-area-inset-left));right:calc(8px + env(safe-area-inset-right));
      z-index:10;background:var(--bar);border:1px solid var(--bar-border);border-radius:.6rem
    }
    header{top:calc(8px + env(safe-area-inset-top));padding:.4rem .6rem}
    #bottomBar{bottom:calc(10px + env(safe-area-inset-bottom));padding:.45rem .6rem}
    #status{
      bottom:calc(10px + env(safe-area-inset-bottom));
      transform:translateY(calc(100% + 8px));padding:.3rem .5rem;font-size:.85rem;
      grid-template-columns:repeat(4,minmax(0,auto))
    }
    button,select,label.chip{padding:.35rem .5rem;font-size:.9rem}
  }

  /* Kontrast/Fokus */
  button:focus,select:focus,input:focus,label.chip:has(input:focus){
    outline:2px solid var(--accent); outline-offset:2px;
  }
  label.chip{display:inline-flex;gap:.5rem;align-items:center;cursor:pointer;user-select:none}
  label.chip input{accent-color:var(--accent)}

  /* Overlay-Stil der Tafel */
  .board-stroke{ /* nur semantischer Marker; Styles werden im Canvas umgesetzt */ }

  @media (prefers-reduced-motion: no-preference){
    /* leichte, performante Akzente ohne starke Animationen */
  }
  /* noscript Hinweis */
  noscript{display:block;padding:1rem;margin:1rem;border:1px solid #512; background:#200; color:#fff}
</style>
</head>
<body>
<noscript>Diese App ben√∂tigt JavaScript (Kamera, Erkennung, Speichern). Bitte JavaScript aktivieren.</noscript>

<div id="app" aria-live="polite">
  <header>
    <div class="group">
      <button id="btnStart" class="primary" aria-label="Kamera starten">üé• Kamera starten</button>
      <select id="selCam" title="Kamera/Linse (nur R√ºckkamera)" disabled>
        <option>‚Äî</option>
      </select>
      <select id="selQuality" title="Qualit√§t" disabled>
        <option value="auto" selected>Auto (Max)</option>
        <option value="2160">2160p</option>
        <option value="1440">1440p</option>
        <option value="1080">1080p</option>
        <option value="720">720p</option>
      </select>
      <button id="btnSnap" aria-label="Foto machen" disabled>üì∏ Foto</button>
    </div>
    <div class="group">
      <button id="btnDir" aria-label="Speicherordner w√§hlen">üìÅ Ordner</button>
      <span id="saveMode" class="kpi">Speichern: <b>Download</b></span>
    </div>
    <div class="spacer"></div>
    <div class="group">
      <span id="kpiRes" class="kpi">Aufl√∂sung: ‚Äî</span>
    </div>
  </header>

  <div id="stage" role="region" aria-label="Live-Kamera">
    <div id="banner" role="status" aria-live="polite"></div>
    <video id="video" playsinline muted></video>
    <canvas id="overlay" class="board-stroke"></canvas>
  </div>

  <div id="bottomBar">
    <label for="zoomSlider">üîé Zoom</label>
    <input id="zoomSlider" type="range" min="1" max="10" step="0.01" value="1" disabled aria-label="Zoom">
    <span id="zoomInfo" class="kpi">Anzeige 1.00√ó | HW ‚Äî</span>
    <span class="spacer"></span>
    <label class="chip" title="Auto-Foto bei Tafel√§nderung"><input type="checkbox" id="tglAuto"> Auto Foto</label>
    <label class="chip" title="Bewegungs-Blocker gegen versehentliche Ausl√∂sung"><input type="checkbox" id="tglBlocker" checked> Objekte blockieren</label>
    <label class="chip" title="Verhindert Auto-Foto wenn Gesichter auf der Tafel sind"><input type="checkbox" id="tglFace"> Face-Blocker</label>
    <label class="chip" title="Texterkennung nach dem Speichern (deu)"><input type="checkbox" id="tglOCR"> OCR</label>
  </div>

  <div id="status">
    <div>Board erkannt: <b id="stBoard" class="bad">nein</b></div>
    <div>Auto: <b id="stAuto" class="warn">aus</b></div>
    <div>Blocker: <b id="stBlock" class="warn">‚Äî</b></div>
    <div>Modelle: <span id="stModels" class="mono">‚Äî</span></div>
  </div>
</div>

<script>
/* ===== Short helpers ===== */
const $=s=>document.querySelector(s), on=(el,ev,fn,o)=>el.addEventListener(ev,fn,o);
const clamp=(v,l,h)=>Math.max(l,Math.min(h,v)), fmt=(n,d=2)=>Number(n).toFixed(d);
const banner=$('#banner');
function showBanner(t,cls='warn',ms=3000){
  banner.textContent=t; banner.style.display='block';
  banner.style.borderColor=cls==='bad'?'#7a2a2a':cls==='ok'?'#2f6a45':'#263445';
  clearTimeout(showBanner._t); showBanner._t=setTimeout(()=>banner.style.display='none',ms);
}
function saveLocal(key,val){ try{ localStorage.setItem(key,JSON.stringify(val)); }catch{} }
function loadLocal(key,def){ try{ const v=localStorage.getItem(key); return v?JSON.parse(v):def; }catch{ return def; } }

/* ===== Elements ===== */
const video=$('#video'), overlay=$('#overlay'), ctxOv=overlay.getContext('2d',{willReadFrequently:true});
const btnStart=$('#btnStart'), selCam=$('#selCam'), selQuality=$('#selQuality'), btnSnap=$('#btnSnap');
const btnDir=$('#btnDir'), saveMode=$('#saveMode');
const tglAuto=$('#tglAuto'), tglBlocker=$('#tglBlocker'), tglFace=$('#tglFace'), tglOCR=$('#tglOCR');
const kpiRes=$('#kpiRes'), stBoard=$('#stBoard'), stAuto=$('#stAuto'), stBlock=$('#stBlock'), stModels=$('#stModels');
const zoomSlider=$('#zoomSlider'), zoomInfo=$('#zoomInfo');

/* ===== State ===== */
let mediaStream=null, track=null, caps=null, sets=null;
let hardwareZoom=false, hwMin=1, hwMax=1, displayZoom=1;
let dirHandle=null, haveFSAccess=('showDirectoryPicker' in window);
let cvReady=false, cvFailed=false, loadingCV=false;
let loopRunning=false, boardQuadOverlay=null, boardQuadVideo=null, boardFound=false, H_video=null;
let targetW=1600, targetH=900;
let prevThumb=null, lastChangeTs=0; const CHANGE_THRESH=0.09, STABLE_MS=800, COOLDOWN_MS=3500;

/* ===== Layout & Zoom ===== */
function resizeOverlay(){
  // Fallback, falls getBoundingClientRect 0 liefert
  const r=video.getBoundingClientRect();
  overlay.width=Math.max(2,Math.round(r.width||overlay.clientWidth||2));
  overlay.height=Math.max(2,Math.round(r.height||overlay.clientHeight||2));
}
new (window.ResizeObserver||class{observe(){}})(resizeOverlay).observe($('#stage'));
window.addEventListener('resize',resizeOverlay,{passive:true});
function applyDisplayTransform(){ const t=`scale(${displayZoom})`; video.style.transform=t; overlay.style.transform=t; }
on(zoomSlider,'input',()=>applyZoom(parseFloat(zoomSlider.value)));
async function applyZoom(total){
  let hw=1, disp=total;
  if (hardwareZoom){
    hw = clamp(total, hwMin, hwMax);
    try{ await track.applyConstraints({advanced:[{zoom:hw}]}); }catch(e){ hw=1; disp=total; }
    disp = total / hw;
  }
  displayZoom = clamp(disp, 1, 10);
  applyDisplayTransform();
  zoomInfo.textContent=`Anzeige ${fmt(displayZoom,2)}√ó | HW ${hardwareZoom?fmt(hw,2)+'√ó':'‚Äî'}`;
  saveLocal('zoom', displayZoom);
}

/* ===== FS Access ===== */
async function chooseDirectory(){
  if (!haveFSAccess){ showBanner('FS Access API nicht unterst√ºtzt ‚Äì nutze Downloads','warn',4000); return; }
  try{
    dirHandle=await window.showDirectoryPicker({mode:'readwrite'});
    saveMode.innerHTML='Speichern: <b>Ordner</b>'; saveLocal('saveMode','folder');
  }catch{}
}
async function saveImage(blob, base='Tafel'){
  const t=new Date(), p=s=>String(s).padStart(2,'0');
  const name=`${base}_${t.getFullYear()}${p(t.getMonth()+1)}${p(t.getDate())}_${p(t.getHours())}${p(t.getMinutes())}${p(t.getSeconds())}.png`;
  if (dirHandle && haveFSAccess){
    try{
      const perm=await dirHandle.requestPermission?.({mode:'readwrite'});
      if (perm==='granted'){
        const fh=await dirHandle.getFileHandle(name,{create:true});
        const w=await fh.createWritable(); await w.write(blob); await w.close();
        return {mode:'folder',name};
      }
    }catch{}
  }
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=name; document.body.appendChild(a); a.click(); URL.revokeObjectURL(a.href); a.remove();
  return {mode:'download',name};
}

/* ===== Script loader & OpenCV redundant ===== */
function loadScript(src){
  return new Promise((res,rej)=>{
    const s=document.createElement('script');
    s.src=src; s.async=true; s.crossOrigin='anonymous'; s.referrerPolicy='no-referrer';
    s.onload=()=>res(); s.onerror=e=>rej(e); document.head.appendChild(s);
  });
}
async function loadOpenCV(){
  if (cvReady||cvFailed||loadingCV) return cvReady;
  loadingCV=true;
  const sources=[
    'https://docs.opencv.org/4.x/opencv.js',
    'https://cdn.jsdelivr.net/npm/@techstark/opencv-js@4.10.0/opencv.js',
    'https://cdn.jsdelivr.net/gh/opencv/opencv@4.x/build_js/bin/opencv.js'
  ];
  for (const src of sources){
    try{
      const base=src.substring(0,src.lastIndexOf('/')+1);
      window.Module={ locateFile:(p)=> base+p };
      await loadScript(src);
      await new Promise((res,rej)=>{
        const t0=performance.now();
        (function wait(){
          if (typeof cv!=='undefined'&&cv?.Mat) return res();
          if (performance.now()-t0>12000) return rej(new Error('OpenCV timeout'));
          requestAnimationFrame(wait);
        })();
      });
      cvReady=true; stModels.textContent='OpenCV, Motion'; loadingCV=false; return true;
    }catch(e){ /* try next */ }
  }
  cvFailed=true; loadingCV=false; stModels.textContent='(ohne OpenCV)'; showBanner('OpenCV nicht geladen ‚Äì Erkennung eingeschr√§nkt','warn',5000); return false;
}

/* ===== Mapping: Overlay -> Video (object-fit: cover) ===== */
function overlayToVideoPoint(pt){
  const ow=overlay.width, oh=overlay.height;
  const vw=video.videoWidth||ow, vh=video.videoHeight||oh;
  if (!vw||!vh) return {x:pt.x, y:pt.y};
  const s=Math.max(ow/vw, oh/vh); const dw=vw*s, dh=vh*s;
  const dx=(ow - dw)/2, dy=(oh - dh)/2;
  const x=(pt.x - dx)/s, y=(pt.y - dy)/s;
  return { x: clamp(x,0,vw-1), y: clamp(y,0,vh-1) };
}
function mapQuadOverlayToVideo(q){ return q.map(p=>overlayToVideoPoint(p)); }

/* ===== OpenCV utils ===== */
function orderTLTRBRBL(pts){
  const bySum=pts.slice().sort((a,b)=>(a.x+a.y)-(b.x+b.y));
  const byDiff=pts.slice().sort((a,b)=>(a.x-a.y)-(b.x-b.y));
  const tl=bySum[0], br=bySum[bySum.length-1], tr=byDiff[byDiff.length-1], bl=byDiff[0];
  return [tl,tr,br,bl];
}
function detectBoardQuadOverlay(frameCanvas){
  const w=frameCanvas.width, h=frameCanvas.height;
  const sw=Math.max(360,Math.round(w*0.5)), sh=Math.max(200,Math.round(h*0.5));
  const src=cv.imread(frameCanvas);
  const resized=new cv.Mat(); cv.resize(src,resized,new cv.Size(sw,sh),0,0,cv.INTER_AREA);
  const gray=new cv.Mat(); cv.cvtColor(resized,gray,cv.COLOR_RGBA2GRAY);
  try{ if (cv.createCLAHE){ const clahe=cv.createCLAHE(2.0,new cv.Size(8,8)); clahe.apply(gray,gray); clahe.delete(); } else { cv.equalizeHist(gray,gray); } }catch{}
  cv.GaussianBlur(gray,gray,new cv.Size(5,5),0);

  let best=null,bestScore=-1;
  const passes=[ {adaptive:false,canny:[60,150],close:3}, {adaptive:true,canny:[40,120],close:5} ];
  for (const pass of passes){
    let edges=new cv.Mat();
    if (pass.adaptive){ let thr=new cv.Mat(); cv.adaptiveThreshold(gray,thr,255,cv.ADAPTIVE_THRESH_GAUSSIAN_C,cv.THRESH_BINARY,11,2); edges=thr; }
    else { cv.Canny(gray,edges,pass.canny[0],pass.canny[1]); }
    const kernel=cv.Mat.ones(pass.close,pass.close,cv.CV_8U); cv.morphologyEx(edges,edges,cv.MORPH_CLOSE,kernel);
    const contours=new cv.MatVector(), hierarchy=new cv.Mat();
    cv.findContours(edges,contours,hierarchy,cv.RETR_LIST,cv.CHAIN_APPROX_SIMPLE);

    for (let i=0;i<contours.size();i++){
      const cnt=contours.get(i), peri=cv.arcLength(cnt,true);
      const approx=new cv.Mat(); cv.approxPolyDP(cnt,approx,0.02*peri,true);
      const area=cv.contourArea(cnt);
      if (approx.rows===4 && cv.isContourConvex(approx) && area>(sw*sh*0.10)){
        const d=approx.data32S, pts=[]; for(let j=0;j<d.length;j+=2) pts.push({x:d[j],y:d[j+1]});
        const ord=orderTLTRBRBL(pts);
        const w1=Math.hypot(ord[1].x-ord[0].x,ord[1].y-ord[0].y), w2=Math.hypot(ord[2].x-ord[3].x,ord[2].y-ord[3].y);
        const h1=Math.hypot(ord[3].x-ord[0].x,ord[3].y-ord[0].y), h2=Math.hypot(ord[2].x-ord[1].x,ord[2].y-ord[1].y);
        const wA=(w1+w2)/2, hA=(h1+h2)/2;
        const rectScore=1 - Math.abs(w1-w2)/Math.max(1,wA) - Math.abs(h1-h2)/Math.max(1,hA);
        const ar=wA/Math.max(1,hA); const arScore=(ar>0.7 && ar<2.5)?0.5:0;
        const score=(area/(sw*sh))+rectScore+arScore;
        if (score>bestScore){ bestScore=score; best=ord.map(p=>({x:p.x*(w/sw), y:p.y*(h/sh)})); }
      }
      approx.delete();
    }

    if (!best){
      let maxArea=0, maxCnt=null;
      for (let i=0;i<contours.size();i++){ const a=cv.contourArea(contours.get(i)); if (a>maxArea){ maxArea=a; maxCnt=contours.get(i);} }
      if (maxCnt && maxArea>(sw*sh*0.15)){
        const rect=cv.minAreaRect(maxCnt);
        const box=cv.RotatedRect.points(rect);
        let pts=[];
        if (Array.isArray(box)){
          pts = [box[0],box[1],box[2],box[3]].map(p=>({x:p.x*(w/sw), y:p.y*(h/sh)}));
        } else {
          const data = (box.data32F && box.data32F.length)? box.data32F : box.data32S;
          for (let k=0;k<data.length;k+=2){ pts.push({x:data[k]*(w/sw), y:data[k+1]*(h/sh)}); }
          box.delete && box.delete();
        }
        best = orderTLTRBRBL(pts);
        bestScore = maxArea/(sw*sh);
      }
    }

    edges.delete(); kernel.delete(); contours.delete(); hierarchy.delete();
    if (best) break;
  }
  src.delete(); resized.delete(); gray.delete();
  return best;
}
function computeHomographyVideo(qVideo){
  const [tl,tr,br,bl]=orderTLTRBRBL(qVideo);
  const wTop=Math.hypot(tr.x-tl.x,tr.y-tl.y), wBot=Math.hypot(br.x-bl.x,br.y-bl.y);
  const hL=Math.hypot(bl.x-tl.x,bl.y-tl.y), hR=Math.hypot(br.x-tr.x,br.y-tr.y);
  const wA=(wTop+wBot)/2, hA=(hL+hR)/2, asp=clamp(wA/Math.max(1,hA),0.7,2.5);
  targetW=1600; targetH=Math.round(targetW/asp);
  const srcTri=cv.matFromArray(4,1,cv.CV_32FC2,[ tl.x,tl.y,tr.x,tr.y,br.x,br.y,bl.x,bl.y ]);
  const dstTri=cv.matFromArray(4,1,cv.CV_32FC2,[ 0,0, targetW,0, targetW,targetH, 0,targetH ]);
  const H=cv.getPerspectiveTransform(srcTri, dstTri);
  srcTri.delete(); dstTri.delete();
  return H;
}
function warpBoardVideo(frameCanvasSensor, H){
  const src=cv.imread(frameCanvasSensor), dst=new cv.Mat();
  cv.warpPerspective(src,dst,new cv.Size(targetW,targetH),cv.INTER_LINEAR,cv.BORDER_REPLICATE);
  const out=document.createElement('canvas'); out.width=targetW; out.height=targetH; cv.imshow(out,dst);
  src.delete(); dst.delete();
  return out;
}

/* ===== Frame helpers ===== */
function frameCanvasOverlay(){
  const c=document.createElement('canvas'); c.width=overlay.width; c.height=overlay.height;
  c.getContext('2d',{willReadFrequently:true}).drawImage(video,0,0,c.width,c.height); return c;
}
function frameCanvasSensor(){
  const vw=video.videoWidth||overlay.width, vh=video.videoHeight||overlay.height;
  const c=document.createElement('canvas'); c.width=vw; c.height=vh;
  c.getContext('2d',{willReadFrequently:true}).drawImage(video,0,0,c.width,c.height); return c;
}
function grayThumb(srcCanvas,tw=128,th=72){
  const c=document.createElement('canvas'); c.width=tw; c.height=th;
  const x=c.getContext('2d',{willReadFrequently:true}); x.drawImage(srcCanvas,0,0,tw,th);
  const id=x.getImageData(0,0,tw,th).data; const out=new Float32Array(tw*th);
  for(let i=0,j=0;i<id.length;i+=4,j++) out[j]=(0.299*id[i]+0.587*id[i+1]+0.114*id[i+2])/255;
  return {data:out,w:tw,h:th};
}
function mse(a,b){ if(!a||!b||a.data.length!==b.data.length) return 1; let s=0; for(let i=0;i<a.data.length;i++){ const d=a.data[i]-b.data[i]; s+=d*d; } return s/a.data.length; }

/* ===== Face & OCR (optional; lazy) ===== */
let faceModel=null, tfLoaded=false, blazeLoaded=false, tessLoaded=false;
async function ensureFace(){
  if (!tglFace.checked) return false;
  if (!tfLoaded){ try{ await loadScript('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js'); tfLoaded=true; }catch{ try{ await loadScript('https://unpkg.com/@tensorflow/tfjs@4.22.0/dist/tf.min.js'); tfLoaded=true; }catch(e){} } }
  if (!blazeLoaded){ try{ await loadScript('https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface@0.1.2/dist/blazeface.min.js'); blazeLoaded=true; }catch{ try{ await loadScript('https://unpkg.com/@tensorflow-models/blazeface@0.1.2/dist/blazeface.min.js'); blazeLoaded=true; }catch(e){} } }
  if (window.blazeface && !faceModel){ try{ faceModel=await blazeface.load(); stModels.textContent+=(stModels.textContent.includes('BlazeFace')?'':', BlazeFace'); }catch(e){} }
  return !!faceModel;
}
function triArea(a,b,c){ return Math.abs((a.x*(b.y-c.y)+b.x*(c.y-a.y)+c.x*(a.y-b.y))/2); }
function polyArea(q){ return triArea(q[0],q[1],q[2])+triArea(q[0],q[2],q[3]); }
function pointInQuad(p,q){ const A=polyArea(q); const s=triArea(p,q[0],q[1])+triArea(p,q[1],q[2])+triArea(p,q[2],q[3])+triArea(p,q[3],q[0]); return Math.abs(s-A)<1e-1*A; }
async function faceBlockVerdict(canvasOverlay){
  if (!tglFace.checked || !boardQuadOverlay) return false;
  try{ const ok=await ensureFace(); if(!ok) return false;
    const preds=await faceModel.estimateFaces(canvasOverlay,false); if(!preds?.length) return false;
    for (const p of preds){ if(!p.topLeft||!p.bottomRight) continue; const cx=(p.topLeft[0]+p.bottomRight[0])/2, cy=(p.topLeft[1]+p.bottomRight[1])/2; if (pointInQuad({x:cx,y:cy}, boardQuadOverlay)) return true; }
  }catch(e){}
  return false;
}
async function ensureOCR(){
  if (!tglOCR.checked) return false;
  if (!tessLoaded){
    try{ await loadScript('https://cdn.jsdelivr.net/npm/tesseract.js@5.1.1/dist/tesseract.min.js'); tessLoaded=true; }
    catch{ try{ await loadScript('https://unpkg.com/tesseract.js@5.1.1/dist/tesseract.min.js'); tessLoaded=true; }catch(e){} }
    if (tessLoaded) stModels.textContent+=(stModels.textContent.includes('OCR')?'':', OCR');
  }
  return tessLoaded;
}
async function runOCR(canvas){
  try{ const ok=await ensureOCR(); if(!ok) return; const worker=await Tesseract.createWorker('deu');
    const {data:{text}}=await worker.recognize(canvas); await worker.terminate(); console.log('OCR (deu):',text);
  }catch(e){}
}

/* ===== Kamera & Aufl√∂sung (Back-Facing priorisiert) ===== */
async function listCameras(){
  const devs=await navigator.mediaDevices.enumerateDevices();
  const cams=devs.filter(d=>d.kind==='videoinput');
  // Heuristik: nur Back/Environment/Rear
  const isBack = l=>{
    l=(l||'').toLowerCase();
    return l.includes('back')||l.includes('rear')||l.includes('environment')||l.includes('r√ºck')||l.includes('world');
  };
  const backCams = cams.filter(c=>isBack(c.label));
  const list = backCams.length? backCams : cams; // Fallback: alle, aber wir kennzeichnen
  selCam.innerHTML='';
  list.forEach(c=>{
    const o=document.createElement('option'); o.value=c.deviceId;
    const lab=c.label||`Kamera ${c.deviceId.slice(0,6)}`;
    o.textContent = (backCams.length? lab : `${lab} (kein Back-Hinweis)`);
    selCam.appendChild(o);
  });
  selCam.disabled=list.length===0;
}
async function restartStreamWithConstraints(cons){
  if (mediaStream){ mediaStream.getTracks().forEach(t=>t.stop()); mediaStream=null; }
  mediaStream=await navigator.mediaDevices.getUserMedia(cons);
  video.srcObject=mediaStream; await video.play().catch(()=>{});
  track=mediaStream.getVideoTracks()[0]; caps=track.getCapabilities?.()||{}; sets=track.getSettings?.()||{};
  hardwareZoom='zoom' in (caps||{}); if (hardwareZoom){ hwMin=caps.zoom.min??1; hwMax=caps.zoom.max??1; }
  await new Promise(r=> video.onloadedmetadata ? (video.onloadedmetadata=()=>r()) : setTimeout(r,120));
  resizeOverlay(); applyDisplayTransform();
  kpiRes.textContent=`Aufl√∂sung: ${sets.width||video.videoWidth||'‚Äî'}√ó${sets.height||video.videoHeight||'‚Äî'}`;
}
async function startCamera(deviceId=null){
  try{
    btnStart.disabled=true;
    if (!navigator.mediaDevices?.getUserMedia){ showBanner('getUserMedia nicht verf√ºgbar (HTTPS/Browser pr√ºfen)','bad',7000); btnStart.disabled=false; return; }
    // Strict Back-Facing bevorzugen
    let cons = deviceId
      ? {video:{deviceId:{exact:deviceId}, facingMode:{ideal:'environment'}}, audio:false}
      : {video:{facingMode:{exact:'environment'}, width:{ideal:1920}, height:{ideal:1080}, frameRate:{ideal:30,max:60}}, audio:false};
    try{ await restartStreamWithConstraints(cons); }
    catch(e1){
      // Lockerer Versuch: environment ideal
      try{ await restartStreamWithConstraints({video:{facingMode:{ideal:'environment'}}, audio:false}); }
      catch(e2){
        // Letzter Fallback: irgendeine Kamera, aber deutlicher Hinweis
        await restartStreamWithConstraints({video:true, audio:false});
        showBanner('Keine R√ºckkamera erkennbar ‚Äì nutze verf√ºgbare Kamera', 'warn', 5000);
      }
    }

    await listCameras(); selQuality.disabled=false; btnSnap.disabled=false; zoomSlider.disabled=false;
    // AF/AE/AWB Best Effort
    try{ await track.applyConstraints({advanced:[{focusMode:'continuous'},{exposureMode:'continuous'},{whiteBalanceMode:'continuous'}]}); }catch{}

    // Auto Max oder Preset
    if (selQuality.value==='auto') await setMaxResolution();
    else await applyQualityPreset(selQuality.value);

    sets=track.getSettings?.()||sets; kpiRes.textContent=`Aufl√∂sung: ${sets.width||'‚Äî'}√ó${sets.height||'‚Äî'}`;
    if (!loopRunning){ loopRunning=true; processingLoop(); }
    showBanner('Kamera l√§uft','ok',1500);
    saveLocal('camId', track.getSettings?.().deviceId||null);
  }catch(err){
    let msg=err.name+': '+err.message;
    if (err.name==='NotAllowedError') msg='Kamera-Zugriff verweigert';
    if (err.name==='NotFoundError') msg='Keine Kamera gefunden';
    if (err.name==='NotReadableError') msg='Kamera belegt';
    if (err.name==='OverconstrainedError') msg='Constraint nicht erf√ºllbar';
    showBanner('Kamera-Fehler: '+msg,'bad',7000);
    btnStart.disabled=false;
  }
}
async function setMaxResolution(){
  if (!track?.getCapabilities) return false;
  const c=track.getCapabilities(); const wMax=c.width&&c.width.max, hMax=c.height&&c.height.max, fpsMax=c.frameRate&&c.frameRate.max;
  if (wMax&&hMax){
    try{
      const adv = c.resizeMode? [{resizeMode:'none'}] : [];
      await track.applyConstraints({ width:{exact:wMax}, height:{exact:hMax}, ...(fpsMax?{frameRate:{ideal:Math.min(60,fpsMax)}}:{}), ...(adv.length?{advanced:adv}:{}) });
      await new Promise(r=>setTimeout(r,120));
      const s=track.getSettings?.(); if (s && s.width===wMax && s.height===hMax) return true;
    }catch{}
  }
  const deviceId = track?.getSettings?.().deviceId;
  const cons = deviceId? { video:{ deviceId:{exact:deviceId}, width:{exact:wMax||3840}, height:{exact:hMax||2160} }, audio:false } :
                         { video:{ facingMode:{ideal:'environment'}, width:{exact:wMax||3840}, height:{exact:hMax||2160} }, audio:false };
  try{ await restartStreamWithConstraints(cons); return true; }catch{}
  const ladder=[{w:3840,h:2160},{w:2560,h:1440},{w:1920,h:1080},{w:1280,h:720}];
  for (const p of ladder){
    const lc = deviceId? { video:{ deviceId:{exact:deviceId}, width:{exact:p.w}, height:{exact:p.h} }, audio:false }
                       : { video:{ facingMode:{ideal:'environment'}, width:{exact:p.w}, height:{exact:p.h} }, audio:false };
    try{ await restartStreamWithConstraints(lc); return true; }catch{}
  }
  return false;
}
async function applyQualityPreset(q){
  if (!track) return;
  const map={ '2160':{w:3840,h:2160}, '1440':{w:2560,h:1440}, '1080':{w:1920,h:1080}, '720':{w:1280,h:720} };
  const p=map[q]; if (!p) return;
  const deviceId = track?.getSettings?.().deviceId;
  const cons = deviceId? { video:{ deviceId:{exact:deviceId}, width:{exact:p.w}, height:{exact:p.h} }, audio:false }
                       : { video:{ facingMode:{ideal:'environment'}, width:{exact:p.w}, height:{exact:p.h} }, audio:false };
  try{ await restartStreamWithConstraints(cons); }catch(e){ /* ignore */ }
}
on(selQuality,'change',async()=>{ if (selQuality.value==='auto') await setMaxResolution(); else await applyQualityPreset(selQuality.value); });
on(selCam,'change',()=>startCamera(selCam.value));

/* ===== Loop & Logik ===== */
function drawOverlayQuad(q){
  const ow=overlay.width, oh=overlay.height;
  ctxOv.clearRect(0,0,ow,oh);
  if (!q) return;
  // markant & sichtbar
  ctxOv.lineWidth=3.5; ctxOv.strokeStyle='rgba(78,161,255,1.0)'; ctxOv.fillStyle='rgba(78,161,255,0.15)';
  ctxOv.beginPath(); ctxOv.moveTo(q[0].x,q[0].y); for(let i=1;i<4;i++) ctxOv.lineTo(q[i].x,q[i].y); ctxOv.closePath(); ctxOv.stroke(); ctxOv.fill();
}
async function processingLoop(){
  const cvOk = await loadOpenCV(); // App l√§uft weiter, wenn false
  let frameIdx=0, lastMotion=null; const MOTION_T=0.18, MOTION_FRAC=0.035;

  const step = async ()=>{
    if (!mediaStream){ loopRunning=false; return; }

    const ow=overlay.width, oh=overlay.height;
    if (ow>2 && oh>2){
      const frameOverlay=frameCanvasOverlay();

      if (cvOk && !cvFailed){
        try{
          // Regelm√§√üig neu evaluieren
          if (!boardFound || (frameIdx%8===0)){
            const q=detectBoardQuadOverlay(frameOverlay);
            if (q){
              boardQuadOverlay=q;
              boardQuadVideo=mapQuadOverlayToVideo(boardQuadOverlay);
              boardFound=true;
              if (H_video) H_video.delete();
              H_video=computeHomographyVideo(boardQuadVideo);
            } else {
              boardFound=false; boardQuadOverlay=null; boardQuadVideo=null;
              if (H_video){ H_video.delete(); H_video=null; }
            }
          }
          drawOverlayQuad(boardQuadOverlay);
          stBoard.textContent=boardFound?'ja':'nein'; stBoard.className=boardFound?'ok':'bad';

          // Change/Auto nur wenn Board
          if (boardFound && H_video){
            const warpedForDiff = frameOverlay; // leichtgewichtige Approximation
            const thumb=grayThumb(warpedForDiff,128,72);
            const diffVal=prevThumb?mse(thumb,prevThumb):null; prevThumb=thumb;

            // Motion-Blocker (Overlay-Approx)
            if (!lastMotion) lastMotion=grayThumb(warpedForDiff,128,72);
            const cur=grayThumb(warpedForDiff,128,72);
            let ch=0; for(let i=0;i<cur.data.length;i++) if (Math.abs(cur.data[i]-lastMotion.data[i])>MOTION_T) ch++;
            const frac=ch/cur.data.length, motionBlock=frac>MOTION_FRAC; lastMotion=cur;

            stBlock.textContent=tglBlocker.checked?(motionBlock?'blockiert':'frei'):'aus';
            stBlock.className=tglBlocker.checked?(motionBlock?'bad':'ok'):'warn';

            const now=performance.now(), stable=(now-lastChangeTs)>STABLE_MS;
            if (tglAuto.checked && diffVal!==null && diffVal>CHANGE_THRESH && stable){
              const cooldown=(now-(processingLoop._lastCap||0))>COOLDOWN_MS;
              const blockOk=tglBlocker.checked?!motionBlock:true;
              const faceOk=!(await faceBlockVerdict(frameOverlay));
              if (cooldown && blockOk && faceOk){ await captureAndSave('Auto'); processingLoop._lastCap=performance.now(); lastChangeTs=now; }
            }
          } else { drawOverlayQuad(null); }
        }catch(e){
          stModels.textContent='(ohne OpenCV)'; cvFailed=true; boardFound=false; boardQuadOverlay=null; boardQuadVideo=null; if (H_video){ H_video.delete(); H_video=null; }
          drawOverlayQuad(null);
        }
      } else {
        // Ohne OpenCV: kein Overlay, App bleibt nutzbar
        drawOverlayQuad(null);
        stBoard.textContent='nein'; stBoard.className='bad';
      }
    }
    frameIdx++; requestAnimationFrame(step);
  };
  requestAnimationFrame(step);
}

/* ===== Capture (EXPORT in Sensor-Aufl√∂sung!) ===== */
function canvasToBlob(canvas, type='image/png', quality=0.95){
  return new Promise(res=>{
    if (canvas.toBlob) canvas.toBlob(b=>res(b), type, quality);
    else { // Fallback (sehr alt): dataURL
      const dataURL=canvas.toDataURL(type, quality);
      // Daten-URL zu Blob
      const bstr=atob(dataURL.split(',')[1]); let n=bstr.length; const u8arr=new Uint8Array(n);
      while(n--) u8arr[n]=bstr.charCodeAt(n); res(new Blob([u8arr],{type}));
    }
  });
}
async function captureAndSave(prefix='Tafel'){
  try{
    let out=null;
    if (boardFound && H_video && cvReady && !cvFailed){
      const frameSensor=frameCanvasSensor();               // volle Sensor-Aufl√∂sung
      out = warpBoardVideo(frameSensor, H_video);          // Entzerrt in hoher Qualit√§t
    } else {
      out = frameCanvasSensor();                           // Fallback: volles Sensor-Bild
    }
    const blob=await canvasToBlob(out,'image/png',0.95);
    const r=await saveImage(blob,prefix); showBanner(`Foto gespeichert (${r.mode})`,'ok',1600);
    if (tglOCR.checked) runOCR(out);
  }catch(e){ showBanner('Fehler beim Speichern','bad',4000); }
}

/* ===== Events ===== */
on(btnStart,'click',()=>startCamera(loadLocal('camId',null)));
on(btnSnap,'click',()=>captureAndSave('Manuell'));
on(btnDir,'click',chooseDirectory);
on(tglAuto,'change',()=>{ stAuto.textContent=tglAuto.checked?'an':'aus'; stAuto.className=tglAuto.checked?'ok':'warn'; saveLocal('tglAuto', tglAuto.checked); });
on(tglBlocker,'change',()=>saveLocal('tglBlocker', tglBlocker.checked));
on(tglFace,'change',()=>saveLocal('tglFace', tglFace.checked));
on(tglOCR,'change',()=>saveLocal('tglOCR', tglOCR.checked));

/* ===== Init ===== */
(function init(){
  // Restore simple prefs
  tglAuto.checked = loadLocal('tglAuto', false);
  tglBlocker.checked = loadLocal('tglBlocker', true);
  tglFace.checked = loadLocal('tglFace', false);
  tglOCR.checked = loadLocal('tglOCR', false);
  const z=loadLocal('zoom', 1); zoomSlider.value=z; displayZoom=z; applyDisplayTransform();
  stAuto.textContent=tglAuto.checked?'an':'aus'; stAuto.className=tglAuto.checked?'ok':'warn';
  saveMode.innerHTML = haveFSAccess ? 'Speichern: <b>Download / Ordner</b>' : 'Speichern: <b>Download</b>';
  zoomInfo.textContent=`Anzeige ${fmt(displayZoom,2)}√ó | HW ‚Äî`;

  // Preload: Kamera-Liste (soweit m√∂glich ohne Permission)
  navigator.mediaDevices?.enumerateDevices?.().then(()=>listCameras()).catch(()=>{});

  // Nicht blockierend OpenCV vorw√§rmen
  loadOpenCV();

  // Fehlerfang
  window.addEventListener('error',e=>{ console.error(e.error||e.message); showBanner('Unerwarteter Fehler ‚Äì versuche weiterzuarbeiten','warn',4000); }, {once:false});
  window.addEventListener('unhandledrejection',e=>{ console.error(e.reason); showBanner('Fehler in Hintergrundaufgabe','warn',3000); });

  // Overlay initial
  resizeOverlay();
})();
</script>
</body>
</html>
