
<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TafelCapture ‚Äì Android 15</title>
  <style>
    :root {
      --bg:#0f1115; --fg:#e8eaf0; --muted:#9aa3b2; --accent:#4cc9f0; --ok:#2ecc71; --warn:#f1c40f; --err:#e74c3c;
      --card:#161a22; --border:#283042; --zoom:1;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:var(--bg);color:var(--fg)}
    .app{display:grid;gap:.75rem;padding:.75rem;height:100dvh} /* 100dvh f√ºr Mobile-Viewport */
    @media (orientation:portrait){
      .app{grid-template-rows:auto 1fr auto;grid-template-columns:1fr}
      .controls-top{grid-row:1}
      .stage{grid-row:2}
      .controls-bottom{grid-row:3}
    }
    @media (orientation:landscape){
      .app{grid-template-columns:1fr 360px;grid-template-rows:1fr auto}
      .stage{grid-column:1;grid-row:1 / span 2}
      .controls-top{grid-column:2;grid-row:1}
      .controls-bottom{grid-column:2;grid-row:2}
    }
    .card{background:var(--card);border:1px solid var(--border);border-radius:10px;padding:.75rem}
    .row{display:flex;gap:.5rem;flex-wrap:wrap;align-items:center;margin:.5rem 0}
    .btn{background:#1f2633;color:var(--fg);border:1px solid var(--border);border-radius:8px;padding:.55rem .8rem;cursor:pointer}
    .btn.primary{background:linear-gradient(180deg,#2a3446,#1e2635);border-color:#3a4a66}
    .btn:disabled{opacity:.5;cursor:not-allowed}
    .toggle{display:flex;align-items:center;gap:.4rem}
    .select{appearance:none;background:#1f2633;border:1px solid var(--border);color:var(--fg);padding:.5rem .8rem;border-radius:8px}
    .pill{display:inline-flex;align-items:center;gap:.4rem;padding:.15rem .5rem;border-radius:999px;font-size:.85rem;border:1px solid var(--border)}
    .pill.ok{color:var(--ok)} .pill.warn{color:var(--warn)} .pill.err{color:var(--err)}
    .sep{height:1px;background:var(--border);margin:.5rem 0}
    .status{display:grid;grid-template-columns:1fr 1fr;gap:.35rem;font-size:.9rem;color:var(--muted)}
    .status .kv{display:flex;justify-content:space-between;gap:.75rem;background:#11151d;border:1px solid var(--border);border-radius:8px;padding:.35rem .5rem}

    /* B√ºhne mit Livebild & Overlay */
    .stage{position:relative;overflow:hidden;min-height:50dvh}
    video,canvas{width:100%;height:100%;object-fit:contain;border-radius:10px;touch-action:none}
    #preview{position:absolute;inset:0;z-index:0;background:#000;transform:scale(var(--zoom));transform-origin:center center}
    #overlay{position:absolute;inset:0;z-index:1;pointer-events:none;background:transparent !important;transform:scale(var(--zoom));transform-origin:center center}

    /* Zoom-Leiste unten auf dem Livebild */
    .zoombar{position:absolute;left:.75rem;right:.75rem;bottom:.75rem;z-index:2;
             display:flex;gap:.5rem;align-items:center;justify-content:center;
             background:rgba(0,0,0,.35);backdrop-filter:blur(2px);border-radius:10px;padding:.35rem .6rem}
    .zoombar input[type="range"]{width:220px}
    .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
  </style>
</head>
<body>
  <div class="app">
    <div class="stage card" id="stage">
      <video id="preview" playsinline autoplay muted></video>
      <canvas id="overlay"></canvas>

      <!-- Zoom -->
      <div class="zoombar">
        <label class="toggle" style="color:#e8eaf0">
          üîé Zoom
          <input type="range" id="zoomRange" min="1" max="5" step="0.1" value="1">
        </label>
        <span id="zoomVal" class="pill mono">1.0√ó</span>
      </div>
    </div>

    <div class="controls-top card">
      <h2 style="margin:0 0 .25rem;color:#9aa3b2">Aufnahme &amp; Ordner</h2>
      <div class="row">
        <button class="btn primary" id="btnStart">Kamera starten</button>
        <select id="lensSelect" class="select" title="Kamera w√§hlen" disabled>
          <option>‚Äì Kamera wird geladen ‚Äì</option>
        </select>
        <button class="btn" id="btnTorch" disabled>üî¶ Taschenlampe</button>
        <button class="btn" id="btnShot" disabled>üì∏ Manuell</button>
      </div>
      <div class="row">
        <button class="btn" id="btnChooseDir">üìÅ Ordner w√§hlen</button>
        <span id="dirStatus" class="pill warn">kein Ordner</span>
        <label class="toggle"><input type="checkbox" id="cbUseDownloads"> Fallback: Downloads nutzen</label>
      </div>
      <div class="row">
        <span class="pill mono" id="permCam">Kamera: ?</span>
        <span class="pill mono" id="permFS">Dateizugriff: ?</span>
        <span class="pill mono" id="pillFPS">0 FPS</span>
      </div>

      <div class="sep"></div>
      <h2 style="margin:0 0 .25rem;color:#9aa3b2">Erkennung</h2>
      <div class="row">
        <label class="toggle"><input type="checkbox" id="cbPerson" checked> Personen blockieren</label>
        <label class="toggle"><input type="checkbox" id="cbSlide" checked> Folien‚Äë√Ñnderung</label>
        <!-- NICHT voraktiviert -->
        <label class="toggle"><input type="checkbox" id="cbAutoCap"> Auto‚ÄëFoto bei Folienwechsel</label>
      </div>
      <div class="row">
        <label>Schwellwert √Ñnderung:
          <input type="range" id="slideThresh" min="5" max="40" value="12"> <span id="slideVal">12%</span>
        </label>
      </div>
      <div class="row">
        <span id="statePerson" class="pill mono">Person: unbekannt</span>
        <span id="stateSlide" class="pill mono">Folie: stabil</span>
      </div>
    </div>

    <div class="controls-bottom card">
      <h2 style="margin:0 0 .25rem;color:#9aa3b2">Status</h2>
      <div class="status">
        <div class="kv"><span>Board erkannt</span><span id="kvBoard">‚Äì</span></div>
        <div class="kv"><span>Aufl√∂sung</span><span id="kvRes">‚Äì</span></div>
        <div class="kv"><span>Modell</span><span id="kvModel">‚Äì</span></div>
        <div class="kv"><span>Gespeichert</span><span id="kvSaved">0</span></div>
      </div>
      <div class="sep"></div>
      <small>
        Hinweis: Kamera-Zugriff funktioniert nur √ºber <code>https://</code> oder <code>http://localhost</code>. Auf Android per Chrome empfohlen.
      </small>
    </div>
  </div>

  <script>
  (function(){
    // ---------- DOM ----------
    const $ = s => document.querySelector(s);
    const stage   = $('#stage');
    const video   = $('#preview');
    const overlay = $('#overlay');
    const ctx     = overlay.getContext('2d');

    const btnStart = $('#btnStart');
    const lensSelect = $('#lensSelect');
    const btnTorch = $('#btnTorch');
    const btnShot  = $('#btnShot');
    const btnChooseDir = $('#btnChooseDir');
    const cbUseDownloads = $('#cbUseDownloads');

    const cbPerson = $('#cbPerson');
    const cbSlide  = $('#cbSlide');
    const cbAutoCap= $('#cbAutoCap');
    const slideThresh = $('#slideThresh');
    const slideVal    = $('#slideVal');

    const permCam = $('#permCam');
    const permFS  = $('#permFS');
    const pillFPS = $('#pillFPS');

    const kvBoard = $('#kvBoard');
    const kvRes   = $('#kvRes');
    const kvModel = $('#kvModel');
    const kvSaved = $('#kvSaved');

    const zoomRange = $('#zoomRange');
    const zoomVal   = $('#zoomVal');

    // ---------- State ----------
    let stream = null, videoTrack = null, torchOn = false;
    let selectedDeviceId = null;
    let dirHandle = null, savedCount = 0;

    // Recognition state
    let cvReady = false, cvLoading = false;
    let segmenter = null, tfLoading = false;
    let boardQuad = null;
    let lastSlideThumb = null;
    let lastChangeGateT = 0;
    let personPresentOnBoard = false;

    // Perf
    let rafId = 0, fpsFrames = 0, fpsT = performance.now();

    // ---------- UI Helpers ----------
    function setZoom(z){ stage.style.setProperty('--zoom', z); zoomVal.textContent = z.toFixed(1)+'√ó'; }
    zoomRange.addEventListener('input', () => setZoom(parseFloat(zoomRange.value)||1));
    setZoom(1);

    slideVal.textContent = slideThresh.value + '%';
    slideThresh.addEventListener('input', () => slideVal.textContent = slideThresh.value + '%');

    function resizeOverlayToVideo(){
      if (video.videoWidth && video.videoHeight) {
        overlay.width = video.videoWidth;
        overlay.height= video.videoHeight;
        kvRes.textContent = `${overlay.width}√ó${overlay.height}`;
      }
    }
    window.addEventListener('resize', resizeOverlayToVideo);
    window.addEventListener('orientationchange', () => setTimeout(resizeOverlayToVideo, 150));

    // ---------- Camera ----------
    async function startCamera(deviceId){
      stopCamera();

      video.setAttribute('playsinline',''); video.muted = true; video.autoplay = true;

      if (!navigator.mediaDevices?.getUserMedia) {
        permCam.textContent = 'Kamera: nicht unterst√ºtzt'; permCam.className = 'pill err';
        alert('getUserMedia wird nicht unterst√ºtzt.');
        return;
      }

      const base = { audio:false, video: { facingMode: { ideal:'environment' }, width:{ ideal:1920 }, height:{ ideal:1080 } } };
      if (deviceId) base.video.deviceId = { exact: deviceId };

      try {
        stream = await navigator.mediaDevices.getUserMedia(base);
      } catch (e1) {
        console.warn('preferred getUserMedia failed', e1);
        stream = await navigator.mediaDevices.getUserMedia({ video:true, audio:false });
      }

      video.srcObject = stream;
      videoTrack = stream.getVideoTracks()[0];

      // Nach Permission die Kameraliste bef√ºllen
      await populateCameras();

      // Torch & Zoom‚ÄëHW
      detectTorchSupport();
      setupHardwareZoom();

      const applyMeta = () => { resizeOverlayToVideo(); };
      if (video.readyState >= 1) applyMeta();
      else video.addEventListener('loadedmetadata', applyMeta, { once:true });

      try { await video.play(); } catch(e){ console.warn('video.play blocked:', e); }

      btnShot.disabled = false;
      permCam.textContent = 'Kamera: ok'; permCam.className = 'pill ok';

      // Libs laden
      loadOpenCV();                      // robustes OpenCV (WASM)
      if (cbPerson.checked) loadSegmentation();

      runLoop();
    }

    function stopCamera(){
      cancelAnimationFrame(rafId);
      if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
      videoTrack = null;
      btnShot.disabled = true;
      ctx.clearRect(0,0,overlay.width, overlay.height);
      boardQuad = null; lastSlideThumb = null; personPresentOnBoard = false;
      // Anzeige‚ÄëZoom zur√ºck
      zoomRange.value = '1'; setZoom(1);
    }

    async function populateCameras(){
      try{
        const devices = await navigator.mediaDevices.enumerateDevices();
        const cams = devices.filter(d => d.kind === 'videoinput');
        // Einfache Heuristik zur Linsenerkennung
        const labelRank = (label) => {
          const L = (label||'').toLowerCase();
          if (L.includes('tele')) return 3;
          if (L.includes('back') && (L.includes('aux') || L.includes('camera 2') || L.includes('camera3'))) return 2;
          if (L.includes('ultra') || L.includes('wide')) return 1;
          return 0;
        };
        // Sortiere: tele > aux/back > wide > rest
        cams.sort((a,b) => labelRank(b.label)-labelRank(a.label));
        lensSelect.innerHTML = '';
        for (const c of cams){
          const opt = document.createElement('option');
          opt.value = c.deviceId;
          opt.textContent = c.label || `Kamera ${lensSelect.length+1}`;
          lensSelect.appendChild(opt);
        }
        lensSelect.disabled = cams.length === 0;
        // Vorbelegung: falls selectedDeviceId gesetzt
        if (selectedDeviceId) lensSelect.value = selectedDeviceId;
      }catch(e){ console.warn('enumerateDevices failed', e); }
    }

    lensSelect.addEventListener('change', async () => {
      selectedDeviceId = lensSelect.value;
      await startCamera(selectedDeviceId);
    });

    function detectTorchSupport(){
      try {
        const caps = videoTrack?.getCapabilities?.();
        btnTorch.disabled = !(caps && 'torch' in caps);
      } catch { btnTorch.disabled = true; }
    }

    function setupHardwareZoom(){
      try {
        const caps = videoTrack?.getCapabilities?.();
        if (caps && caps.zoom && (typeof caps.zoom === 'number' || caps.zoom.max)){
          const min = caps.zoom.min ?? 1;
          const max = caps.zoom.max ?? 5;
          const step= caps.zoom.step?? 0.1;
          zoomRange.min = String(min);
          zoomRange.max = String(Math.max(3, max));
          zoomRange.step= String(step);
          const settings = videoTrack.getSettings?.() || {};
          const cur = settings.zoom ?? 1;
          zoomRange.value = String(cur);
          setZoom(parseFloat(zoomRange.value)||1);
          zoomRange.oninput = async () => {
            const val = Number(zoomRange.value);
            setZoom(val);
            try { await videoTrack.applyConstraints({ advanced:[{ zoom: val }] }); }
            catch(e){ /* wenn HW‚ÄëZoom scheitert, bleibt Anzeige‚ÄëZoom aktiv */ }
          };
        } else {
          // bleibt Anzeige‚ÄëZoom (CSS)
          zoomRange.min = '1'; zoomRange.max = '5'; zoomRange.step = '0.1';
          zoomRange.oninput = () => setZoom(parseFloat(zoomRange.value)||1);
        }
      } catch {
        zoomRange.oninput = () => setZoom(parseFloat(zoomRange.value)||1);
      }
    }

    // Pinch‚Äëto‚ÄëZoom (Anzeige)
    let pinchD0 = 0, zoom0 = 1;
    stage.addEventListener('touchstart', (e)=>{ if (e.touches.length===2){ pinchD0 = dist(e.touches[0], e.touches[1]); zoom0 = parseFloat(zoomRange.value)||1; }}, {passive:true});
    stage.addEventListener('touchmove',  (e)=>{ if (e.touches.length===2){ const d = dist(e.touches[0], e.touches[1]); const factor = d/pinchD0; const z = Math.min(parseFloat(zoomRange.max), Math.max(parseFloat(zoomRange.min), zoom0*factor)); zoomRange.value = String(z); setZoom(z); }}, {passive:true});
    function dist(a,b){ const dx=a.clientX-b.clientX, dy=a.clientY-b.clientY; return Math.hypot(dx,dy); }

    btnTorch.addEventListener('click', async () => {
      const track = videoTrack; if (!track) return;
      try { torchOn = !torchOn; await track.applyConstraints({ advanced:[{ torch: torchOn }] });
            btnTorch.textContent = torchOn ? 'üî¶ Taschenlampe AN' : 'üî¶ Taschenlampe'; }
      catch (e){ console.warn('Torch not supported', e); alert('Taschenlampe wird nicht unterst√ºtzt.'); }
    });

    btnStart.addEventListener('click', () => startCamera(selectedDeviceId));

    // ---------- Ordner & Speichern ----------
    btnChooseDir.addEventListener('click', chooseDirectory);
    async function chooseDirectory(){
      if (!window.showDirectoryPicker) {
        permFS.textContent = 'Dateizugriff: nicht unterst√ºtzt'; permFS.className = 'pill warn';
        alert('Ordnerwahl nicht unterst√ºtzt. Fallback: Downloads.');
        return;
      }
      try {
        dirHandle = await window.showDirectoryPicker({ mode:'readwrite', id:'tafel-capture' });
        const perm = await dirHandle.requestPermission({ mode:'readwrite' });
        if (perm === 'granted') {
          permFS.textContent = 'Dateizugriff: ok'; permFS.className = 'pill ok';
          document.getElementById('dirStatus').textContent = 'Ordner gew√§hlt';
          document.getElementById('dirStatus').className = 'pill ok';
        }
      } catch (e) { console.warn('chooseDirectory', e); }
    }

    async function saveBlob(name, blob){
      if (dirHandle) {
        try {
          const fh = await dirHandle.getFileHandle(name, { create:true });
          const w  = await fh.createWritable(); await w.write(blob); await w.close();
          kvSaved.textContent = String(++savedCount);
          return true;
        } catch(e){ console.warn('write failed, fallback', e); }
      }
      if (cbUseDownloads.checked || !dirHandle) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = name; a.click();
        setTimeout(() => URL.revokeObjectURL(url), 2000);
        kvSaved.textContent = String(++savedCount);
        return true;
      }
      return false;
    }

    btnShot.addEventListener('click', async () => {
      const shot = await captureAndRectify();
      if (shot) await saveBlob(`tafel_${ts()}.jpg`, shot);
    });

    function ts(){ const d=new Date(), p=n=>String(n).padStart(2,'0'); return `${d.getFullYear()}-${p(d.getMonth()+1)}-${p(d.getDate())}_${p(d.getHours())}-${p(d.getMinutes())}-${p(d.getSeconds())}`; }

    // ---------- Capture (nur ROI der Tafel) ----------
    async function captureAndRectify(){
      if (!stream || !cvReady || !window.cv?.Mat || !boardQuad) return null;
      // Offscreen in Videoaufl√∂sung
      const w = overlay.width || video.videoWidth || 1280;
      const h = overlay.height|| video.videoHeight|| 720;
      const cap = document.createElement('canvas'); cap.width=w; cap.height=h;
      const capCtx = cap.getContext('2d', { willReadFrequently:true });
      capCtx.drawImage(video, 0, 0, w, h);

      const mat = cv.imread(cap);
      const roi = warpToBoard(mat, boardQuad); // nur Tafel
      const out = document.createElement('canvas'); out.width = roi.cols; out.height = roi.rows;
      cv.imshow(out, roi);
      const blob = await new Promise(res => out.toBlob(res, 'image/jpeg', 0.9));
      mat.delete(); roi.delete();
      return blob;
    }

    // ---------- OpenCV laden (robust) ----------
    function loadOpenCV(){
      if (cvReady || cvLoading) return; cvLoading = true;
      const s = document.createElement('script');
      s.src = 'https://cdn.jsdelivr.net/npm/@techstark/opencv-js@4.9.0-1/opencv.js';
      s.async = true; s.crossOrigin='anonymous';
      window.cv = window.cv || {};
      window.cv.onRuntimeInitialized = () => { cvReady = true; kvModel.textContent = 'OpenCV'; };
      s.onload = () => { if (window.cv?.Mat && !cvReady){ cvReady=true; kvModel.textContent='OpenCV'; } };
      s.onerror = () => { cvLoading = false; kvModel.textContent = 'OpenCV: Ladefehler'; };
      document.head.appendChild(s);
    }

    // ---------- TF.js Personensegmentierung ----------
    async function loadSegmentation(){
      if (segmenter) return segmenter;
      if (tfLoading) { while(!segmenter) await new Promise(r=>setTimeout(r,100)); return segmenter; }
      tfLoading = true;
      try {
        await import('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.16.0/dist/tf.min.js');
        const mod = await import('https://cdn.jsdelivr.net/npm/@tensorflow-models/body-segmentation@1.0.2/dist/body-segmentation.min.js');
        const bs = mod.bodySegmentation;
        segmenter = await bs.createSegmenter(bs.SupportedModels.MediaPipeSelfieSegmentation, {
          runtime:'tfjs', modelType:'landscape', enableSegmentationSmoothing:true
        });
        kvModel.textContent = (kvModel.textContent ? kvModel.textContent+' + ' : '') + 'SelfieSeg';
      } catch (e) { console.warn('TF load failed', e); }
      return segmenter;
    }

    cbPerson.addEventListener('change', () => { if (cbPerson.checked) loadSegmentation(); });

    // ---------- Board-Tools (OpenCV) ----------
    function orderQuad(pts){ pts.sort((a,b)=>a.y-b.y); const top=pts.slice(0,2).sort((a,b)=>a.x-b.x); const bot=pts.slice(2).sort((a,b)=>a.x-b.x); return [top[0],top[1],bot[1],bot[0]]; }
    function polygonArea(pts){ let a=0; for(let i=0;i<pts.length;i++){ const p=pts[i], q=pts[(i+1)%pts.length]; a += p.x*q.y - q.x*p.y; } return a/2; }
    function findBoardQuad(mat){
      const g = new cv.Mat(); cv.cvtColor(mat, g, cv.COLOR_RGBA2GRAY);
      cv.GaussianBlur(g, g, new cv.Size(5,5), 0);
      const e = new cv.Mat(); cv.Canny(g, e, 50, 150);
      const contours = new cv.MatVector(); const hier = new cv.Mat();
      cv.findContours(e, contours, hier, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);
      let best=null, bestArea=0;
      for (let i=0;i<contours.size();i++){
        const c = contours.get(i);
        const peri = cv.arcLength(c, true);
        const approx = new cv.Mat(); cv.approxPolyDP(c, approx, 0.02*peri, true);
        if (approx.rows===4 && cv.isContourConvex(approx)) {
          const pts=[]; for (let j=0;j<4;j++) pts.push({x: approx.intPtr(j,0)[0], y: approx.intPtr(j,0)[1]});
          const area = Math.abs(polygonArea(pts));
          if (area>bestArea){ bestArea=area; best=pts; }
        }
        c.delete();
      }
      g.delete(); e.delete(); contours.delete(); hier.delete();
      return best ? orderQuad(best) : null;
    }
    function warpToBoard(mat, quad){
      const [tl,tr,br,bl] = quad;
      const wA = Math.hypot(br.x-bl.x, br.y-bl.y), wB = Math.hypot(tr.x-tl.x, tr.y-tl.y);
      const hA = Math.hypot(tr.x-br.x, tr.y-br.y), hB = Math.hypot(tl.x-bl.x, tl.y-bl.y);
      const W = Math.max(320, Math.round(Math.max(wA,wB))), H = Math.max(240, Math.round(Math.max(hA,hB)));
      const src = cv.matFromArray(4,1,cv.CV_32FC2,[tl.x,tl.y,tr.x,tr.y,br.x,br.y,bl.x,bl.y]);
      const dst = cv.matFromArray(4,1,cv.CV_32FC2,[0,0,W,0,W,H,0,H]);
      const M = cv.getPerspectiveTransform(src,dst);
      const out = new cv.Mat(); cv.warpPerspective(mat, out, M, new cv.Size(W,H));
      src.delete(); dst.delete(); M.delete();
      return out;
    }
    function drawQuad(q){
      ctx.clearRect(0,0,overlay.width, overlay.height);
      if (!q) return;
      ctx.save();
      ctx.strokeStyle='rgba(76,201,240,0.9)'; ctx.lineWidth=3;
      ctx.beginPath();
      ctx.moveTo(q[0].x,q[0].y);
      for (let i=1;i<4;i++) ctx.lineTo(q[i].x,q[i].y);
      ctx.closePath(); ctx.stroke();
      ctx.restore();
    }

    // ---------- Fallback-Thumb (ohne OpenCV) ----------
    function thumb64GrayFromCanvas(canvas){
      const tmp = document.createElement('canvas'); tmp.width=64; tmp.height=64;
      const tctx = tmp.getContext('2d'); tctx.drawImage(canvas, 0,0,64,64);
      const data = tctx.getImageData(0,0,64,64).data;
      const out = new Uint8Array(64*64);
      for (let i=0,j=0;i<data.length;i+=4,++j){
        out[j] = (data[i]*0.299 + data[i+1]*0.587 + data[i+2]*0.114) | 0;
      }
      return out;
    }
    function diffPercent(a,b){ let sum=0; const n=a.length; for(let i=0;i<n;i++) sum+=Math.abs(a[i]-b[i]); return (sum/(n*255))*100; }

    // ---------- Main Loop ----------
    async function runLoop(){
      const tick = async () => {
        rafId = requestAnimationFrame(tick);
        if (!stream) return;

        // FPS
        fpsFrames++; const now = performance.now();
        if (now - fpsT > 1000) { pillFPS.textContent = `${fpsFrames} FPS`; fpsFrames=0; fpsT=now; }

        // alle 300ms erkennen
        if (!tick.lastT || (now - tick.lastT) > 300) {
          tick.lastT = now;

          // Offscreen-Canvas in Videoaufl√∂sung
          const w = overlay.width || video.videoWidth || 1280;
          const h = overlay.height|| video.videoHeight|| 720;
          const cap = document.createElement('canvas'); cap.width=w; cap.height=h;
          const capCtx = cap.getContext('2d'); capCtx.drawImage(video, 0,0,w,h);

          let changed = false;

          if (cvReady && window.cv?.Mat) {
            const mat = cv.imread(cap);
            const found = findBoardQuad(mat);
            boardQuad = found || null;
            kvBoard.textContent = found ? 'ja' : 'nein';
            drawQuad(boardQuad);

            if (boardQuad && cbSlide.checked) {
              // Thumb nur aus der Tafel-ROI
              const roi = warpToBoard(mat, boardQuad);
              const th = (() => {
                const dst = new cv.Mat(); const size = new cv.Size(64,64);
                cv.resize(roi, dst, size, 0,0, cv.INTER_AREA);
                const gray = new cv.Mat(); cv.cvtColor(dst, gray, cv.COLOR_RGBA2GRAY);
                const out = new Uint8Array(64*64); out.set(gray.data);
                dst.delete(); gray.delete(); return out;
              })();

              if (lastSlideThumb) {
                const dp = diffPercent(th, lastSlideThumb);
                const thr = parseFloat(slideThresh.value);
                if (dp > thr) {
                  if (now - lastChangeGateT > 800) { changed = true; lastChangeGateT = now; }
                } else {
                  lastChangeGateT = now;
                }
                document.getElementById('stateSlide').textContent = 'Folie: ' + (dp>thr ? `√Ñnderung (${dp.toFixed(1)}%)` : 'stabil');
                document.getElementById('stateSlide').className = 'pill mono ' + (dp>thr ? 'warn' : 'ok');
              } else {
                lastChangeGateT = now;
              }
              lastSlideThumb = th;

              // Personenmaske nur auf ROI (blockiert Auto-Foto, wenn Person sichtbar)
              if (cbPerson.checked && segmenter) {
                try {
                  // Segmentierung direkt auf dem Video (schneller als auf ROI)
                  const seg = await segmenter.segmentPeople(video, { multiSegmentation:false });
                  let pctOnROI = 0;
                  if (seg && seg.length>0 && seg[0].mask) {
                    // Projiziere grob: Erzeuge eine Maske in ROI-Aufl√∂sung √ºber Cap (vereinfachte Annahme)
                    // (Genauigkeit reicht aus, um H√§nde/K√∂pfe auf der Tafel zu erkennen)
                    const m = seg[0].mask;
                    // Z√§hle Alpha > 128
                    let cnt=0; for (let i=3;i<m.data.length;i+=4) if (m.data[i]>128) cnt++;
                    const pct = (cnt / (m.width*m.height)) * 100;
                    // Heuristik: Anteil auf Tafel ‚âà globaler Anteil (vereinfachend)
                    // Konservativ: h√∂here Schwelle, damit kleine Reste nicht blocken
                    pctOnROI = pct;
                  }
                  personPresentOnBoard = pctOnROI > 3.0; // konservativer als zuvor
                  document.getElementById('statePerson').textContent = 'Person: ' + (personPresentOnBoard?'ja':'nein');
                  document.getElementById('statePerson').className = 'pill mono ' + (personPresentOnBoard?'warn':'ok');
                } catch(e){ /* ignore */ }
              } else {
                personPresentOnBoard = false;
              }

              // Auto-Foto NUR wenn Board erkannt, √Ñnderung auf ROI, und (optional) keine Person auf ROI
              if (cbAutoCap.checked && changed && (!cbPerson.checked || !personPresentOnBoard)) {
                const blob = await captureAndRectify();
                if (blob) await saveBlob(`tafel_${ts()}.jpg`, blob);
              }
              roi?.delete?.();
            } else {
              // Kein Board -> keine Auto-Capture-Ausl√∂sung
              document.getElementById('stateSlide').textContent = 'Folie: ‚Äì (kein Board)';
              document.getElementById('stateSlide').className = 'pill mono';
              personPresentOnBoard = false;
            }

            mat.delete();
          } else {
            // OpenCV noch nicht bereit ‚Üí Anzeige, aber keine Auto-Capture
            kvBoard.textContent = 'OpenCV l√§dt ‚Ä¶';
            ctx.clearRect(0,0,overlay.width, overlay.height);
            document.getElementById('stateSlide').textContent = 'Folie: ‚Äì (Board-Erkennung l√§dt)';
            document.getElementById('stateSlide').className = 'pill mono';
          }
        }
      };
      tick();
    }

    // ---------- Events & Init ----------
    btnStart.disabled = false;

    permCam.textContent = 'Kamera: ?'; permCam.className = 'pill mono';
    permFS.textContent  = 'Dateizugriff: ?'; permFS.className = 'pill mono';

    if (!window.isSecureContext && location.hostname!=='localhost') {
      alert('Hinweis: Kamera funktioniert nur √ºber HTTPS oder http://localhost');
    }
  })();
  </script>
</body>
</html>
