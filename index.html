
<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, height=device-height, initial-scale=1, viewport-fit=cover, user-scalable=no"
  />
  <title>TafelCapture v2 ‚Äì lokal, smart, stabil</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #0b0e13; --fg: #e9eef5; --muted:#a7b3c0; --accent:#4ea1ff;
      --ok:#11c46a; --warn:#ffb020; --bad:#ff4d6d;
    }
    html, body { margin:0; padding:0; background:var(--bg); color:var(--fg); font-family:system-ui,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif; height:100%; overflow:hidden; }
    #app { display:grid; grid-template-rows:auto 1fr auto; height:100dvh; width:100vw; }
    header { display:flex; gap:.5rem; flex-wrap:wrap; align-items:center; padding:.5rem .75rem; background:#0f131a; border-bottom:1px solid #1a212c; }
    header .group { display:flex; gap:.5rem; align-items:center; flex-wrap:wrap; }
    button, select, .chip {
      background:#16202c; color:var(--fg); border:1px solid #223041; border-radius:.5rem; padding:.5rem .65rem; font-size:.95rem;
    }
    button.primary { background:#1a2b3f; border-color:#2a4060; }
    .kpi { font-variant-numeric: tabular-nums; color:var(--muted); }
    .kpi b { color:var(--fg); }
    #stage { position:relative; background:black; overflow:hidden; touch-action:none; }
    video#video, canvas#overlay { position:absolute; inset:0; width:100%; height:100%; object-fit:cover; transform-origin:center center; }
    canvas#overlay { pointer-events:none; }
    #bottomBar { display:flex; align-items:center; gap:.75rem; padding:.6rem .8rem; background:#0f131a; border-top:1px solid #1a212c; }
    #zoomSlider { width:100%; }
    #status { display:grid; grid-template-columns: repeat(5, auto); gap:.75rem 1.2rem; align-items:center; padding:.35rem .75rem; font-size:.9rem; color:var(--muted); }
    .ok{color:var(--ok)} .warn{color:var(--warn)} .bad{color:var(--bad)}
    .spacer{flex:1} .mono{font-family:ui-monospace,Menlo,Consolas,monospace} .muted{color:var(--muted)}
    .chip { display:inline-flex; gap:.45rem; border-radius:999px; }
    #banner { position:absolute; left:50%; top:12px; transform:translateX(-50%); background:rgba(15,19,26,.85); border:1px solid #263445; padding:.45rem .7rem; border-radius:.5rem; font-size:.9rem; z-index:5; display:none; }
    #debug { position:absolute; right:.5rem; bottom:.5rem; background:rgba(15,19,26,.8); border:1px solid #263445; border-radius:.5rem; padding:.4rem .6rem; font-size:.8rem; color:var(--muted); max-width:45vw; pointer-events:none; display:none; white-space:pre; z-index:6; }
  </style>
  <!-- OpenCV.js (WASM) ‚Äì mit locateFile, damit die .wasm sicher vom CDN geladen wird -->
  <script>
    // Konfig vor Laden von OpenCV: sichere Pfade f√ºr .wasm
    self.Module = {
      locateFile: (path) => {
        // L√§dt sowohl opencv.js Neben-Dateien als auch .wasm vom offiziellen CDN
        return 'https://docs.opencv.org/4.x/' + path;
      }
    };
  </script>
  <script async src="https://docs.op.js</script>
</head>
<body>
  <div id="app">
    <header>
      <div class="group">
        <button id="btnStart" class="primary">üé• Kamera starten</button>
        <select id="selCam" title="Kamera / Linse w√§hlen" disabled>
          <option>‚Äî Kamera wird geladen ‚Äî</option>
        </select>
        <button id="btnSnap" disabled>üì∏ Manuell</button>
      </div>
      <div class="group">
        <button id="btnDir">üìÅ Ordner w√§hlen</button>
        <span class="kpi" id="saveMode">Speichern: <b>Download</b></span>
      </div>
      <div class="group">
        <label class="chip"><input type="checkbox" id="tglBoardChange" checked> Folien-√Ñnderung</label>
        <label class="chip"><input type="checkbox" id="tglAuto"> Auto Foto</label>
        <label class="chip"><input type="checkbox" id="tglBlocker" checked> Objekte blockieren</label>
        <label class="chip"><input type="checkbox" id="tglFace"> Face-Blocker (optional)</label>
        <label class="chip"><input type="checkbox" id="tglOCR"> OCR (optional)</label>
      </div>
      <div class="spacer"></div>
      <div class="group">
        <span class="kpi" id="kpiRes">‚Äî</span>
        <span class="kpi" id="kpiFps">‚Äî</span>
      </div>
    </header>

    <div id="stage">
      <div id="banner"></div>
      <video id="video" playsinline muted></video>
      <canvas id="overlay"></canvas>
      <div id="debug"></div>
    </div>

    <div id="bottomBar">
      <label for="zoomSlider">üîé Zoom</label>
      <input id="zoomSlider" type="range" min="1" max="10" step="0.01" value="1" disabled>
      <span id="zoomInfo" class="kpi">Anzeige 1.00√ó | HW ‚Äî</span>
    </div>

    <div id="status">
      <div>Board erkannt: <b id="stBoard" class="bad">nein</b></div>
      <div>Auto: <b id="stAuto" class="warn">aus</b></div>
      <div>Blocker: <b id="stBlock" class="warn">‚Äî</b></div>
      <div>Modelle: <span id="stModels" class="mono">OpenCV?</span></div>
      <div>Diff: <span id="stDiff" class="mono">‚Äî</span></div>
    </div>
  </div>

  <script>
  // ===== Utils =====
  const $ = s => document.querySelector(s);
  const on = (el, ev, fn, opts) => el.addEventListener(ev, fn, opts);
  const clamp = (v,l,h)=>Math.max(l,Math.min(h,v));
  const fmt = (n,d=2)=>Number(n).toFixed(d);
  const banner = $('#banner');
  function showBanner(msg, cls='warn', ms=3000){ banner.textContent=msg; banner.style.display='block'; banner.className=cls; clearTimeout(showBanner._t); showBanner._t=setTimeout(()=>banner.style.display='none', ms); }
  const debugBox = $('#debug');
  let SHOW_DEBUG = (new URL(location.href).searchParams.get('debug') === '1');

  // ===== Elements =====
  const video = $('#video');
  const overlay = $('#overlay'), ctxOv = overlay.getContext('2d');
  const btnStart = $('#btnStart'), selCam = $('#selCam'), btnSnap = $('#btnSnap');
  const btnDir = $('#btnDir'), saveMode = $('#saveMode');
  const tglBoardChange = $('#tglBoardChange'), tglAuto = $('#tglAuto');
  const tglBlocker = $('#tglBlocker'), tglFace = $('#tglFace'), tglOCR = $('#tglOCR');
  const kpiRes = $('#kpiRes'), kpiFps = $('#kpiFps'), stBoard = $('#stBoard');
  const stAuto = $('#stAuto'), stBlock = $('#stBlock'), stModels = $('#stModels'), stDiff = $('#stDiff');
  const zoomSlider = $('#zoomSlider'), zoomInfo = $('#zoomInfo');

  // ===== State =====
  let mediaStream=null, track=null, caps=null, sets=null;
  let hardwareZoomSupported=false, hwMin=1, hwMax=1, displayZoom=1;
  let dirHandle=null, haveFSAccess=('showDirectoryPicker' in window);
  let cvReady=false, cvFailed=false;
  let loopRunning=false;
  let boardQuad=null, boardFound=false, H_warp=null, targetW=1600,targetH=900;
  let prevThumb=null; let lastChangeTs=0; const CHANGE_THRESH=0.09, STABLE_MS=800, COOLDOWN_MS=3500;
  let fpsCounter={last: performance.now(), frames:0};

  // ===== Layout sync =====
  function resizeOverlay(){ const r=video.getBoundingClientRect(); overlay.width=Math.round(r.width); overlay.height=Math.round(r.height); }
  new ResizeObserver(resizeOverlay).observe($('#stage'));
  function applyDisplayTransform(){ const t=`scale(${displayZoom})`; video.style.transform=t; overlay.style.transform=t; }

  // ===== OpenCV init (with timeout & fallback) =====
  async function ensureCV(timeoutMs=8000){
    if (cvReady || cvFailed) return cvReady;
    const start=performance.now();
    return new Promise((res)=>{
      const tick=()=> {
        if (typeof cv!=='undefined' && cv?.Mat){ cvReady=true; stModels.textContent='OpenCV, Motion'; res(true); return; }
        if (performance.now()-start>timeoutMs){ cvFailed=true; stModels.textContent='(ohne OpenCV)'; showBanner('OpenCV konnte nicht geladen werden ‚Äì Board-Erkennung aus', 'bad', 5000); res(false); return; }
        requestAnimationFrame(tick);
      };
      tick();
    });
  }

  // ===== Camera =====
  async function listCameras(){
    const devs = await navigator.mediaDevices.enumerateDevices();
    const cams = devs.filter(d=>d.kind==='videoinput');
    const score = l=>{
      l=(l||'').toLowerCase();
      let s=0;
      if (l.includes('tele')) s-=30;
      if (l.includes('aux')) s-=20;
      if (l.includes('wide')) s-=10;
      if (l.includes('ultra')) s+=5;
      if (l.includes('front')) s+=50;
      if (l.includes('back')||l.includes('rear')||l.includes('environment')) s-=10;
      return s;
    };
    cams.sort((a,b)=>score(a.label)-score(b.label));
    selCam.innerHTML='';
    cams.forEach(c=>{
      const o=document.createElement('option');
      o.value=c.deviceId; o.textContent=c.label||`Kamera ${c.deviceId.slice(0,6)}`; selCam.appendChild(o);
    });
    selCam.disabled = cams.length===0;
    if (cams.length===0) showBanner('Keine Kamera gefunden', 'bad', 5000);
  }

  async function startCamera(deviceId=null){
    try{
      btnStart.disabled=true;
      if (!navigator.mediaDevices?.getUserMedia){
        showBanner('getUserMedia nicht verf√ºgbar (HTTPS?)', 'bad', 6000);
        btnStart.disabled=false; return;
      }
      if (mediaStream){ mediaStream.getTracks().forEach(t=>t.stop()); mediaStream=null; }

      const constraints = deviceId ? { video:{deviceId:{exact:deviceId}}, audio:false } : {
        video:{
          facingMode:{ideal:'environment'},
          width:{ideal:1920}, height:{ideal:1080},
          frameRate:{ideal:30, max:60}
        }, audio:false
      };

      mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
      video.srcObject = mediaStream;
      await video.play().catch(()=>{}); // sicher starten
      track = mediaStream.getVideoTracks()[0];
      caps = track.getCapabilities?.()||{};
      sets = track.getSettings?.()||{};
      hardwareZoomSupported = 'zoom' in (caps||{});
      if (hardwareZoomSupported){ hwMin=caps.zoom.min??1; hwMax=caps.zoom.max??1; }

      kpiRes.textContent = `Aufl√∂sung: ${sets.width||video.videoWidth||'‚Äî'}√ó${sets.height||video.videoHeight||'‚Äî'}`;

      await listCameras();
      btnSnap.disabled=false; zoomSlider.disabled=false;

      await new Promise(r=> video.onloadedmetadata ? video.onloadedmetadata=r : setTimeout(r,100));
      resizeOverlay(); applyDisplayTransform();

      // Processing loop
      if (!loopRunning){ loopRunning=true; processingLoop(); }
      showBanner('Kamera l√§uft', 'ok', 1500);
    }catch(err){
      console.error('startCamera error', err);
      let hint='Unbekannter Fehler';
      if (err.name==='NotAllowedError') hint='Zugriff verweigert (Kamera-Erlaubnis)';
      if (err.name==='NotFoundError') hint='Keine passende Kamera gefunden';
      if (err.name==='NotReadableError') hint='Kamera wird von einer anderen App benutzt';
      if (err.name==='OverconstrainedError') hint=`Constraint nicht erf√ºllbar (${err.constraint||'‚Äî'})`;
      showBanner(`Kamera-Fehler: ${hint}`, 'bad', 6000);
      btnStart.disabled=false;
    }
  }

  function updateFps(){ fpsCounter.frames++; const now=performance.now(); if (now - fpsCounter.last >= 1000){ kpiFps.textContent=`FPS: ${fpsCounter.frames}`; fpsCounter.frames=0; fpsCounter.last=now; } }

  // ===== Zoom =====
  async function applyZoom(total){
    let hw=1, disp=total;
    if (hardwareZoomSupported){
      hw = clamp(total, hwMin, hwMax);
      try{ await track.applyConstraints({advanced:[{zoom:hw}]}); } catch(e){ console.warn('HW zoom fail', e); hw=1; disp=total; }
      disp = total / hw;
    }
    displayZoom = clamp(disp, 1, 10);
    applyDisplayTransform();
    zoomInfo.textContent = `Anzeige ${fmt(displayZoom,2)}√ó | HW ${hardwareZoomSupported?fmt(hw,2)+'√ó':'‚Äî'}`;
  }
  on($('#stage'), 'wheel', (e)=>{ if (e.ctrlKey||e.metaKey){ e.preventDefault(); const cur=parseFloat(zoomSlider.value); const z=clamp(cur+(e.deltaY<0?0.1:-0.1),1,10); zoomSlider.value=z; applyZoom(z);} }, {passive:false});
  on(zoomSlider,'input',()=>applyZoom(parseFloat(zoomSlider.value)));

  // ===== File System Access =====
  async function chooseDirectory(){
    if (!haveFSAccess){ showBanner('FS Access API nicht unterst√ºtzt ‚Äì nutze Downloads', 'warn', 5000); return; }
    try{
      dirHandle = await window.showDirectoryPicker({mode:'readwrite'});
      saveMode.innerHTML = 'Speichern: <b>Ordner</b>';
    }catch(e){ console.warn('dir pick', e); }
  }
  async function saveImage(blob, base='Tafel'){
    const ts=new Date(), p=s=>String(s).padStart(2,'0');
    const name = `${base}_${ts.getFullYear()}${p(ts.getMonth()+1)}${p(ts.getDate())}_${p(ts.getHours())}${p(ts.getMinutes())}${p(ts.getSeconds())}.png`;
    if (dirHandle && haveFSAccess){
      const perm = await dirHandle.requestPermission?.({mode:'readwrite'});
      if (perm==='granted'){
        const fh = await dirHandle.getFileHandle(name,{create:true});
        const w = await fh.createWritable(); await w.write(blob); await w.close();
        return {mode:'folder', name};
      }
    }
    const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=name; document.body.appendChild(a); a.click(); URL.revokeObjectURL(a.href); a.remove();
    return {mode:'download', name};
  }

  // ===== Image helpers =====
  function drawFrameTo(canvas){
    const c=canvas||document.createElement('canvas');
    c.width=overlay.width; c.height=overlay.height;
    c.getContext('2d', {willReadFrequently:true}).drawImage(video, 0,0, c.width, c.height);
    return c;
  }
  function grayThumb(srcCanvas, tw=128, th=72){
    const c=document.createElement('canvas'); c.width=tw; c.height=th;
    const x=c.getContext('2d', {willReadFrequently:true});
    x.drawImage(srcCanvas, 0,0, tw,th);
    const id=x.getImageData(0,0,tw,th).data;
    const out=new Float32Array(tw*th);
    for(let i=0,j=0;i<id.length;i+=4,j++){ out[j]=(0.299*id[i]+0.587*id[i+1]+0.114*id[i+2])/255; }
    return {data:out,w:tw,h:th};
  }
  function mse(a,b){ if(!a||!b||a.data.length!==b.data.length) return 1; let s=0; for(let i=0;i<a.data.length;i++){ const d=a.data[i]-b.data[i]; s+=d*d; } return s/a.data.length; }

  // ===== OpenCV utils =====
  function orderTLTRBRBL(pts){
    // robust: tl=min(x+y), br=max(x+y), tr=max(x-y), bl=min(x-y)
    const bySum=[...pts].sort((a,b)=>(a.x+a.y)-(b.x+b.y));
    const byDiff=[...pts].sort((a,b)=>(a.x-a.y)-(b.x-b.y));
    const tl=bySum[0], br=bySum[bySum.length-1], tr=byDiff[byDiff.length-1], bl=byDiff[0];
    return [tl,tr,br,bl];
  }
  function detectBoardQuad(frameCanvas, scale=0.5){
    // returns [{x,y}*4] in overlay space or null
    const w=frameCanvas.width, h=frameCanvas.height;
    const sw=Math.max(320, Math.round(w*scale)), sh=Math.max(180, Math.round(h*scale));
    const src=cv.imread(frameCanvas);
    const resized=new cv.Mat(); cv.resize(src,resized,new cv.Size(sw,sh),0,0,cv.INTER_AREA);
    const gray=new cv.Mat(); cv.cvtColor(resized,gray,cv.COLOR_RGBA2GRAY);
    cv.GaussianBlur(gray,gray,new cv.Size(5,5),0);
    const edges=new cv.Mat(); cv.Canny(gray,edges,60,150);
    const kernel=cv.Mat.ones(3,3,cv.CV_8U); cv.dilate(edges,edges,kernel);

    const contours=new cv.MatVector(), hierarchy=new cv.Mat();
    cv.findContours(edges,contours,hierarchy,cv.RETR_LIST,cv.CHAIN_APPROX_SIMPLE);

    let best=null, bestScore=-1;
    for(let i=0;i<contours.size();i++){
      const cnt=contours.get(i);
      const peri=cv.arcLength(cnt,true);
      const approx=new cv.Mat(); cv.approxPolyDP(cnt, approx, 0.02*peri, true);
      if (approx.rows!==4){ approx.delete(); continue; }
      const area=cv.contourArea(approx); if (area < sw*sh*0.12){ approx.delete(); continue; }
      if (!cv.isContourConvex(approx)){ approx.delete(); continue; }

      const pts=[]; const d=approx.data32S;
      for(let j=0;j<d.length;j+=2) pts.push({x:d[j], y:d[j+1]});
      const ord=orderTLTRBRBL(pts);
      const w1=Math.hypot(ord[1].x-ord[0].x, ord[1].y-ord[0].y);
      const w2=Math.hypot(ord[2].x-ord[3].x, ord[2].y-ord[3].y);
      const h1=Math.hypot(ord[3].x-ord[0].x, ord[3].y-ord[0].y);
      const h2=Math.hypot(ord[2].x-ord[1].x, ord[2].y-ord[1].y);
      const wAvg=(w1+w2)/2, hAvg=(h1+h2)/2;
      const rectScore=1 - Math.abs(w1-w2)/wAvg - Math.abs(h1-h2)/hAvg;
      const areaScore=area/(sw*sh);
      const ar=wAvg/hAvg; const arScore=(ar>0.8 && ar<2.2)?0.5:0.0;
      const score=areaScore + rectScore + arScore;
      if (score>bestScore){
        bestScore=score;
        best=ord.map(p=>({x:p.x*(w/sw), y:p.y*(h/sh)}));
      }
      approx.delete();
    }
    src.delete(); resized.delete(); gray.delete(); edges.delete(); kernel.delete(); contours.delete(); hierarchy.delete();
    return best;
  }
  function computeHomography(q){
    const [tl,tr,br,bl]=orderTLTRBRBL(q);
    const srcTri=cv.matFromArray(4,1,cv.CV_32FC2,[ tl.x,tl.y, tr.x,tr.y, br.x,br.y, bl.x,bl.y ]);
    const dstTri=cv.matFromArray(4,1,cv.CV_32FC2,[ 0,0, targetW,0, targetW,targetH, 0,targetH ]);
    const H=cv.getPerspectiveTransform(srcTri,dstTri); srcTri.delete(); dstTri.delete(); return H;
  }
  function warpBoard(frameCanvas, H){
    const src=cv.imread(frameCanvas); const dst=new cv.Mat();
    cv.warpPerspective(src, dst, new cv.Size(targetW,targetH), cv.INTER_LINEAR, cv.BORDER_REPLICATE);
    const out=document.createElement('canvas'); out.width=targetW; out.height=targetH; cv.imshow(out,dst);
    src.delete(); dst.delete(); return out;
  }

  // ===== Loop =====
  async function processingLoop(){
    const cvOk = await ensureCV(); // OpenCV evtl. aus
    let frameIdx=0;
    let lastMotion=null; const MOTION_T=0.18, MOTION_FRAC=0.035;

    const step = async ()=>{
      if (!mediaStream){ loopRunning=false; return; }
      updateFps();

      const ow=overlay.width, oh=overlay.height;
      if (ow>0 && oh>0){
        const frame=drawFrameTo(); // canvas
        if (cvOk){
          // Board-Detect nicht jeden Frame
          if (!boardFound || (frameIdx%10===0)){
            const q = detectBoardQuad(frame, 0.5);
            if (q){ boardQuad=q; boardFound=true; if (H_warp) H_warp.delete(); H_warp=computeHomography(boardQuad); }
            else { boardFound=false; boardQuad=null; if (H_warp){ H_warp.delete(); H_warp=null; } }
          }
          // zeichnen
          ctxOv.clearRect(0,0,ow,oh);
          if (boardQuad){
            ctxOv.lineWidth=3; ctxOv.strokeStyle='rgba(78,161,255,0.9)'; ctxOv.fillStyle='rgba(78,161,255,0.15)';
            ctxOv.beginPath(); ctxOv.moveTo(boardQuad[0].x,boardQuad[0].y);
            for(let i=1;i<4;i++) ctxOv.lineTo(boardQuad[i].x,boardQuad[i].y);
            ctxOv.closePath(); ctxOv.stroke(); ctxOv.fill();
          }
          stBoard.textContent=boardFound?'ja':'nein'; stBoard.className=boardFound?'ok':'bad';

          // Change + Blocker nur wenn Board da ist
          if (boardFound && H_warp){
            const warped = warpBoard(frame, H_warp);
            const thumb = grayThumb(warped, 128, 72);
            let diffVal = prevThumb ? mse(thumb, prevThumb) : null;
            prevThumb = thumb;

            // Motion-Blocker (innerhalb Board, approximiert √ºber diff zwischen zwei Thumbs)
            if (!lastMotion) lastMotion = grayThumb(warped, 128, 72);
            const curM = grayThumb(warped, 128, 72);
            let changes=0; for(let i=0;i<curM.data.length;i++){ if (Math.abs(curM.data[i]-lastMotion.data[i])>MOTION_T) changes++; }
            const frac = changes / curM.data.length; const motionBlock = frac > MOTION_FRAC;
            lastMotion = curM;

            stDiff.textContent = (diffVal!==null)?fmt(diffVal,3):'‚Äî';
            stBlock.textContent = tglBlocker.checked ? (motionBlock?'blockiert':'frei') : 'aus';
            stBlock.className = tglBlocker.checked ? (motionBlock?'bad':'ok') : 'warn';

            const now=performance.now();
            const stable = (now - lastChangeTs) > STABLE_MS;
            if (tglBoardChange.checked && diffVal!==null && diffVal>CHANGE_THRESH && stable){
              lastChangeTs = now;
              if (SHOW_DEBUG) { debugBox.textContent=`Folien: √Ñnderung (diff=${fmt(diffVal,3)})`; debugBox.style.display='block'; clearTimeout(processingLoop._dt); processingLoop._dt=setTimeout(()=>debugBox.style.display='none', 1000); }
            }

            // Auto Capture
            if (tglAuto.checked && diffVal!==null && diffVal>CHANGE_THRESH && stable){
              const cooldown = (now - (processingLoop._lastCap||0)) > COOLDOWN_MS;
              const blockCond = tglBlocker.checked ? !motionBlock : true;
              const faceCond = await faceBlockVerdict(frame); // optional
              if (cooldown && blockCond && !faceCond){
                await captureAndSave('Auto');
                processingLoop._lastCap = performance.now();
              }
            }
          } else {
            ctxOv.clearRect(0,0,ow,oh);
            stDiff.textContent='‚Äî';
          }
        } else {
          // Kein CV: nur Live-Bild, manueller Snap m√∂glich
          ctxOv.clearRect(0,0,ow,oh);
          stBoard.textContent='nein'; stBoard.className='bad';
          stDiff.textContent='‚Äî'; stModels.textContent='(ohne OpenCV)';
        }
      }

      frameIdx++;
      requestAnimationFrame(step);
    };
    requestAnimationFrame(step);
  }

  // ===== Face blocker (lazy) =====
  let faceModel=null, tfLoaded=false, blazeLoaded=false;
  async function ensureFaceModel(){
    if (faceModel) return true;
    if (!tfLoaded){ await import('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js'); tfLoaded=true; }
    if (!blazeLoaded){ await import('https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface@0.1.2/dist/blazeface.min.js'); blazeLoaded=true; }
    if (window.blazeface){ faceModel = await blazeface.load(); stModels.textContent += ', BlazeFace'; return true; }
    return false;
  }
  async function faceBlockVerdict(frameCanvas){
    if (!tglFace.checked) return false;
    try{ const ok=await ensureFaceModel(); if (!ok||!boardQuad) return false;
      const preds = await faceModel.estimateFaces(frameCanvas, false);
      if (!preds?.length) return false;
      // Center inside board?
      for (const p of preds){
        if (!p.topLeft || !p.bottomRight) continue;
        const cx=(p.topLeft[0]+p.bottomRight[0])/2, cy=(p.topLeft[1]+p.bottomRight[1])/2;
        if (pointInQuad({x:cx,y:cy}, boardQuad)) return true;
      }
    }catch(e){ console.warn('faceBlock',e); }
    return false;
  }
  function triArea(a,b,c){ return Math.abs((a.x*(b.y-c.y)+b.x*(c.y-a.y)+c.x*(a.y-b.y))/2); }
  function polyArea(q){ return triArea(q[0],q[1],q[2])+triArea(q[0],q[2],q[3]); }
  function pointInQuad(p,q){ const A=polyArea(q); const s=triArea(p,q[0],q[1])+triArea(p,q[1],q[2])+triArea(p,q[2],q[3])+triArea(p,q[3],q[0]); return Math.abs(s-A)<1e-1*A; }

  // ===== Capture =====
  async function captureAndSave(prefix='Tafel'){
    let outCanvas=null;
    if (boardFound && H_warp && typeof cv!=='undefined' && cv?.Mat){
      const frame=drawFrameTo();
      outCanvas = warpBoard(frame, H_warp);
    } else {
      outCanvas = drawFrameTo();
    }
    const blob = await new Promise(res=> outCanvas.toBlob(res, 'image/png', 0.95));
    const r = await saveImage(blob, prefix);
    showBanner(`Foto gespeichert (${r.mode})`, 'ok', 1800);
    if (tglOCR.checked){ await ensureOCR(); runOCR(outCanvas); }
  }

  // ===== OCR (lazy) =====
  let tessLoaded=false;
  async function ensureOCR(){ if (tessLoaded) return; await import('https://cdn.jsdelivr.net/npm/tesseract.js@5.1.1/dist/tesseract.min.js'); tessLoaded=true; stModels.textContent+=', OCR'; }
  async function runOCR(canvas){
    try{
      const worker = await Tesseract.createWorker('deu');
      const { data:{ text } } = await worker.recognize(canvas);
      await worker.terminate();
      if (SHOW_DEBUG){ debugBox.textContent='OCR:\n'+(text||'‚Äî'); debugBox.style.display='block'; clearTimeout(runOCR._t); runOCR._t=setTimeout(()=>debugBox.style.display='none', 2500); }
      console.log('OCR:', text);
    }catch(e){ console.warn('OCR',e); }
  }

  // ===== Events =====
  on(btnStart,'click',()=>startCamera());
  on(selCam,'change',()=>startCamera(selCam.value));
  on(btnSnap,'click',()=>captureAndSave('Manuell'));
  on(btnDir,'click',chooseDirectory);
  on(tglAuto,'change',()=>{ stAuto.textContent=tglAuto.checked?'an':'aus'; stAuto.className=tglAuto.checked?'ok':'warn'; });
  on(document,'keydown',(e)=>{
    if (e.key.toLowerCase()==='d'){ SHOW_DEBUG=!SHOW_DEBUG; debugBox.style.display = SHOW_DEBUG?'block':'none'; }
    if (e.key.toLowerCase()==='c'){ captureAndSave('Manuell'); }
    if (e.key==='+'){ const z=clamp(parseFloat(zoomSlider.value)+0.1,1,10); zoomSlider.value=z; applyZoom(z); }
    if (e.key==='-'){ const z=clamp(parseFloat(zoomSlider.value)-0.1,1,10); zoomSlider.value=z; applyZoom(z); }
  });

  // ===== Init =====
  (async function init(){
    stAuto.textContent='aus'; stAuto.className='warn';
    saveMode.innerHTML = haveFSAccess ? 'Speichern: <b>Download / Ordner</b>' : 'Speichern: <b>Download</b>';
    zoomInfo.textContent = `Anzeige ${fmt(displayZoom,2)}√ó | HW ‚Äî`;
    try{ await listCameras(); }catch{}
    // Zeige, ob OpenCV grunds√§tzlich geladen werden kann
    ensureCV().then(ok=>{ if(!ok){ // Deaktiviere Auto/Blocker automatisch
        tglBoardChange.checked=false; tglAuto.checked=false; tglFace.checked=false; 
        showBanner('OpenCV nicht bereit ‚Äì Auto/Erkennung deaktiviert', 'warn', 5000);
      }
    });
  })();
  </script>
</body>
</html>
