<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TafelCapture ‚Äì Android 15</title>
  <style>
    :root {
      --bg: #0f1115; --fg: #e8eaf0; --muted: #9aa3b2; --accent: #4cc9f0; --ok:#2ecc71; --warn:#f1c40f; --err:#e74c3c;
      --card:#161a22; --border:#283042; --btn:#1f2633; --btn2:#243042;
    }
    * { box-sizing: border-box }
    html, body { height: 100% }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, Noto Sans, Ubuntu, Cantarell, "Fira Sans", "Droid Sans", sans-serif; background: var(--bg); color: var(--fg); }
    button, select, input[type="checkbox"] { font: inherit }

    /* Responsive Layout: portrait vs. landscape based on uploaded mockups */
    .app { display: grid; gap: .75rem; padding: .75rem; height: 100vh; }
    @media (orientation: portrait) {
      .app { grid-template-rows: auto 1fr auto; grid-template-columns: 1fr; }
      .controls-top { grid-row:1; }
      .stage { grid-row:2; }
      .controls-bottom { grid-row:3; }
    }
    @media (orientation: landscape) {
      .app { grid-template-columns: 1fr 320px; grid-template-rows: 1fr auto; }
      .stage { grid-column:1; grid-row:1 / span 2; }
      .controls-top { grid-column:2; grid-row:1; }
      .controls-bottom { grid-column:2; grid-row:2; }
    }

    .card { background: var(--card); border: 1px solid var(--border); border-radius: 10px; padding: .75rem; }
    .controls-top .row, .controls-bottom .row { display:flex; gap:.5rem; flex-wrap:wrap; align-items:center; margin:.5rem 0; }
    .controls-top h2, .controls-bottom h2 { margin: 0 0 .25rem 0; font-size: 1rem; color: var(--muted) }

    .btn { background: var(--btn); color: var(--fg); border:1px solid var(--border); border-radius:8px; padding:.55rem .8rem; cursor:pointer; }
    .btn.primary { background: linear-gradient(180deg, #2a3446, #1e2635); border-color:#3a4a66 }
    .btn:disabled { opacity:.5; cursor:not-allowed }
    .toggle { display:flex; align-items:center; gap:.4rem; }

    .stage { position: relative; }
    video, canvas { width:100%; height:100%; object-fit: contain; background: #000; border-radius: 10px; }
    #preview { position:absolute; inset:0; }
    #overlay { position:absolute; inset:0; pointer-events:none; }

    .status { display:grid; grid-template-columns: 1fr 1fr; gap:.35rem; font-size:.85rem; color:var(--muted) }
    .status div { background:#11151d; border:1px solid var(--border); border-radius:8px; padding:.35rem .5rem; }
    .kv { display:flex; justify-content:space-between; gap:.75rem; }

    .pill { display:inline-flex; align-items:center; gap:.4rem; padding:.15rem .5rem; border-radius:999px; font-size:.8rem; border:1px solid var(--border); }
    .pill.ok { color: var(--ok) }
    .pill.warn { color: var(--warn) }
    .pill.err { color: var(--err) }

    .sep { height:1px; background: var(--border); margin:.5rem 0; }
    small a { color: var(--accent); text-decoration: none }
  </style>
</head>
<body>
  <div class="app">
    <div class="stage card">
      <video id="preview" playsinline autoplay muted></video>
      <canvas id="overlay"></canvas>
    </div>

    <div class="controls-top card">
      <h2>Aufnahme &amp; Ordner</h2>
      <div class="row">
        <button class="btn primary" id="btnStart">Kamera starten</button>
        <button class="btn" id="btnTorch" disabled>üî¶ Taschenlampe</button>
        <button class="btn" id="btnShot" disabled>üì∏ Manuell ausl√∂sen</button>
      </div>
      <div class="row">
        <button class="btn" id="btnChooseDir">üìÅ Ordner w√§hlen</button>
        <span id="dirStatus" class="pill warn">kein Ordner</span>
        <label class="toggle"><input type="checkbox" id="cbUseDownloads" /> Fallback: Downloads nutzen</label>
      </div>
      <div class="row">
        <span class="pill" id="permCam">Kamera: ?</span>
        <span class="pill" id="permFS">Dateizugriff: ?</span>
        <span class="pill" id="pillFPS">0 FPS</span>
      </div>
      <div class="sep"></div>
      <h2>Erkennung</h2>
      <div class="row">
        <label class="toggle"><input type="checkbox" id="cbPerson" checked> Personenerkennung</label>
        <label class="toggle"><input type="checkbox" id="cbSlide" checked> Folien-√Ñnderung</label>
      </div>
      <div class="row">
        <label>Schwellwert √Ñnderung: <input type="range" id="slideThresh" min="5" max="40" value="12"> <span id="slideVal">12%</span></label>
      </div>
      <div class="row">
        <span id="statePerson" class="pill">Person: unbekannt</span>
        <span id="stateSlide" class="pill">Folie: stabil</span>
      </div>
    </div>

    <div class="controls-bottom card">
      <h2>Status</h2>
      <div class="status">
        <div class="kv"><span>Board erkannt</span><span id="kvBoard">-</span></div>
        <div class="kv"><span>Aufl√∂sung</span><span id="kvRes">-</span></div>
        <div class="kv"><span>Modell</span><span id="kvModel">-</span></div>
        <div class="kv"><span>Gespeichert</span><span id="kvSaved">0</span></div>
      </div>
      <div class="sep"></div>
      <small>
        Hinweis: Kamera-Zugriff funktioniert nur √ºber <code>https://</code> oder <code>http://localhost</code>. Auf Android per Chrome empfohlen.<br/>
        Mehr Infos: getUserMedia (MDN) &amp; File System Access API (Chrome).<br/>
      </small>
    </div>
  </div>

  <!-- External libs are loaded lazily by JS when needed to reduce startup cost. -->
  <script>
  (function(){
    const qs = sel => document.querySelector(sel);
    const video = qs('#preview');
    const overlay = qs('#overlay');
    const ctx = overlay.getContext('2d');
    const btnStart = qs('#btnStart');
    const btnTorch = qs('#btnTorch');
    const btnShot = qs('#btnShot');
    const btnChooseDir = qs('#btnChooseDir');
    const cbUseDownloads = qs('#cbUseDownloads');
    const cbPerson = qs('#cbPerson');
    const cbSlide = qs('#cbSlide');
    const slideThresh = qs('#slideThresh');
    const slideVal = qs('#slideVal');

    const pillFPS = qs('#pillFPS');
    const permCam = qs('#permCam');
    const permFS = qs('#permFS');
    const dirStatus = qs('#dirStatus');

    const kvBoard = qs('#kvBoard');
    const kvRes = qs('#kvRes');
    const kvModel = qs('#kvModel');
    const kvSaved = qs('#kvSaved');

    const statePerson = qs('#statePerson');
    const stateSlide = qs('#stateSlide');

    let stream = null;
    let torchOn = false;
    let dirHandle = null; // FileSystemDirectoryHandle
    let savedCount = 0;

    // Detection state
    let boardQuad = null; // [[x,y]x4]
    let lastQuadAt = 0;
    let rectifiedSize = { w: 1280, h: 720 };
    let lastSlideThumb = null; // Uint8Array grayscale 64x64
    let slideStableSince = 0;
    let personPresent = false;

    // Perf
    let animId = 0;
    let lastFpsT = performance.now();
    let frames = 0;

    slideVal.textContent = slideThresh.value + '%';
    slideThresh.addEventListener('input', () => slideVal.textContent = slideThresh.value + '%');

    function ts() {
      const d = new Date();
      const pad = n => String(n).padStart(2,'0');
      return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}_${pad(d.getHours())}-${pad(d.getMinutes())}-${pad(d.getSeconds())}`;
    }

    // ==== KAMERA: FIXED START ====
    async function startCamera() {
      try {
        stopCamera();

        // Sicher f√ºr Mobile: verhindert Autoplay-Blockaden
        video.setAttribute('playsinline', '');
        video.muted = true;
        video.autoplay = true;

        if (!('mediaDevices' in navigator) || !navigator.mediaDevices.getUserMedia) {
          permCam.textContent = 'Kamera: nicht unterst√ºtzt'; permCam.className = 'pill err';
          alert('getUserMedia wird von diesem Browser nicht unterst√ºtzt.');
          return;
        }

        // Bevorzugt R√ºckkamera + moderate Aufl√∂sung; bei Fehler sauberer Fallback
        const preferred = { video: { facingMode: { ideal: 'environment' }, width: { ideal: 1920 }, height: { ideal: 1080 } }, audio: false };
        try {
          stream = await navigator.mediaDevices.getUserMedia(preferred);
        } catch (e1) {
          console.warn('[Camera] preferred failed:', e1?.name || e1);
          // Minimaler Fallback ‚Äì nimmt, was verf√ºgbar ist
          stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
        }

        // Stream binden
        video.srcObject = stream;

        // Aufl√∂sung/Canvas erst setzen, wenn Metadaten da sind (verhindert 0√ó0/Schwarz)
        const applyMeta = () => {
          const w = video.videoWidth  || overlay.clientWidth  || 1280;
          const h = video.videoHeight || overlay.clientHeight || 720;
          overlay.width = w;
          overlay.height = h;
          kvRes.textContent = `${w}√ó${h}`;
        };
        if (video.readyState >= 1) applyMeta();
        else video.addEventListener('loadedmetadata', applyMeta, { once: true });

        try {
          await video.play(); // bei Mobile evtl. 2. Tap n√∂tig, aber muted+playsinline hilft
        } catch (ePlay) {
          console.warn('[Camera] play() blocked:', ePlay?.name || ePlay);
          // Keine UI-√Ñnderung ‚Äì erneutes Tippen auf "Kamera starten" reicht
        }

        btnShot.disabled = false;
        permCam.textContent = 'Kamera: ok'; permCam.className = 'pill ok';

        detectTorchSupport();
        runLoop();
      } catch (e) {
        console.error(e);
        permCam.textContent = 'Kamera: blockiert'; permCam.className = 'pill err';
        alert('Kamera konnte nicht gestartet werden: ' + (e.message || e));
      }
    }
    // ==== KAMERA: FIXED ENDE ====

    function stopCamera() {
      cancelAnimationFrame(animId);
      if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
      btnShot.disabled = true;
      // Optional: Overlay leeren (sichtbar nur bei Transparenz)
      // ctx.clearRect(0,0,overlay.width, overlay.height);
    }

    async function detectTorchSupport() {
      try {
        const track = stream?.getVideoTracks?.()[0];
        const caps = track?.getCapabilities?.();
        if (caps && 'torch' in caps) {
          btnTorch.disabled = false;
        } else {
          btnTorch.disabled = true;
        }
      } catch {}
    }

    btnTorch.addEventListener('click', async () => {
      const track = stream?.getVideoTracks?.()[0];
      if (!track) return;
      try {
        torchOn = !torchOn;
        await track.applyConstraints({ advanced: [{ torch: torchOn }] });
        btnTorch.textContent = torchOn ? 'üî¶ Taschenlampe AN' : 'üî¶ Taschenlampe';
      } catch (e) {
        console.warn('Torch not supported', e);
        alert('Taschenlampe wird von diesem Ger√§t/Kamera nicht unterst√ºtzt.');
      }
    });

    btnStart.addEventListener('click', startCamera);

    // Directory picker & saving
    async function chooseDirectory() {
      if (!('showDirectoryPicker' in window)) {
        alert('Ordnerwahl wird von diesem Browser nicht unterst√ºtzt. Es wird der Downloads-Fallback genutzt.');
        permFS.textContent = 'Dateizugriff: nicht unterst√ºtzt'; permFS.className = 'pill warn';
        dirStatus.textContent = 'kein Ordner'; dirStatus.className = 'pill warn';
        return;
      }
      try {
        dirHandle = await window.showDirectoryPicker({ mode: 'readwrite', id: 'tafel-capture' });
        const perm = await dirHandle.requestPermission({ mode:'readwrite' });
        if (perm === 'granted') {
          permFS.textContent = 'Dateizugriff: ok'; permFS.className = 'pill ok';
          dirStatus.textContent = 'Ordner gew√§hlt'; dirStatus.className = 'pill ok';
        } else {
          permFS.textContent = 'Dateizugriff: verweigert'; permFS.className = 'pill err';
          dirStatus.textContent = 'kein Ordner'; dirStatus.className = 'pill warn';
        }
      } catch (e) {
        console.warn(e);
        // user aborted or not supported
      }
    }
    btnChooseDir.addEventListener('click', chooseDirectory);

    async function saveBlob(name, blob) {
      // Preferred: write to chosen directory
      if (dirHandle) {
        try {
          const fileHandle = await dirHandle.getFileHandle(name, { create: true });
          const writable = await fileHandle.createWritable();
          await writable.write(blob);
          await writable.close();
          savedCount++; kvSaved.textContent = String(savedCount);
          return true;
        } catch (e) {
          console.warn('Write failed, falling back to download', e);
        }
      }
      if (cbUseDownloads.checked || !dirHandle) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = name; a.click();
        setTimeout(() => URL.revokeObjectURL(url), 2000);
        savedCount++; kvSaved.textContent = String(savedCount);
        return true;
      }
      return false;
    }

    btnShot.addEventListener('click', async () => {
      const shot = await captureAndRectify();
      if (!shot) return;
      await saveBlob(`tafel_${ts()}.jpg`, shot);
    });

    // Lazy loaders
    let cvReady = false; let cvLoading = false;
    function loadOpenCV() {
      if (cvReady || cvLoading) return;
      cvLoading = true;
      const s = document.createElement('script');
      s.src = 'https://docs.opencv.org/4.x/opencv.js';
      s.async = true;
      s.onload = () => {
        // OpenCV sets global cv; wait until runtime is ready
        const check = () => { if (cv && cv['onRuntimeInitialized']) { cv['onRuntimeInitialized'] = () => { cvReady = true; }; } };
        try { check(); } catch {}
        setTimeout(() => { if (!cvReady && cv && cv.Mat) cvReady = true; }, 1500);
      };
      document.head.appendChild(s);
    }

    let tfReady = false; let tfLoading = false; let segmenter = null;
    async function loadSegmentation() {
      if (segmenter) return segmenter;
      if (tfLoading) { while(!segmenter) { await new Promise(r=>setTimeout(r,100)); } return segmenter; }
      tfLoading = true;
      // Load TF.js and body-segmentation
      await import('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.16.0/dist/tf.min.js');
      const mod = await import('https://cdn.jsdelivr.net/npm/@tensorflow-models/body-segmentation@1.0.2/dist/body-segmentation.min.js');
      const bs = mod.bodySegmentation;
      // Use MediaPipe selfie segmentation (fast)
      segmenter = await bs.createSegmenter(bs.SupportedModels.MediaPipeSelfieSegmentation, {
        runtime: 'tfjs', modelType: 'landscape', enableSegmentationSmoothing: true
      });
      kvModel.textContent = 'SelfieSegmentation';
      tfReady = true;
      return segmenter;
    }

    // Board detection & rectification using OpenCV.js
    function findBoardQuad(mat) {
      // mat: cv.Mat (RGBA)
      const src = new cv.Mat(); cv.cvtColor(mat, src, cv.COLOR_RGBA2GRAY);
      cv.GaussianBlur(src, src, new cv.Size(5,5), 0);
      const edges = new cv.Mat(); cv.Canny(src, edges, 50, 150);
      const contours = new cv.MatVector(); const hierarchy = new cv.Mat();
      cv.findContours(edges, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);
      let best = null; let bestArea = 0;
      for (let i=0;i<contours.size();i++) {
        const c = contours.get(i);
        const peri = cv.arcLength(c, true);
        const approx = new cv.Mat(); cv.approxPolyDP(c, approx, 0.02*peri, true);
        if (approx.rows === 4 && cv.isContourConvex(approx)) {
          const pts = [];
          for (let j=0;j<4;j++) pts.push({x: approx.intPtr(j,0)[0], y: approx.intPtr(j,0)[1]});
          const area = Math.abs( polygonArea(pts) );
          if (area > bestArea) { bestArea = area; best = pts; }
        }
        c.delete();
      }
      src.delete(); edges.delete(); contours.delete(); hierarchy.delete();
      return best ? orderQuad(best) : null;
    }

    function polygonArea(pts){
      let a=0; for (let i=0;i<pts.length;i++){ const p=pts[i], q=pts[(i+1)%pts.length]; a += p.x*q.y - q.x*p.y; } return a/2;
    }

    function orderQuad(pts){
      // Return [tl,tr,br,bl]
      pts.sort((a,b)=>a.y-b.y);
      const top = pts.slice(0,2).sort((a,b)=>a.x-b.x);
      const bot = pts.slice(2).sort((a,b)=>a.x-b.x);
      return [top[0], top[1], bot[1], bot[0]];
    }

    function warpToBoard(mat, quad) {
      const [tl,tr,br,bl] = quad;
      const widthA = Math.hypot(br.x - bl.x, br.y - bl.y);
      const widthB = Math.hypot(tr.x - tl.x, tr.y - tl.y);
      const maxW = Math.max(widthA, widthB);
      const heightA = Math.hypot(tr.x - br.x, tr.y - br.y);
      const heightB = Math.hypot(tl.x - bl.x, tl.y - bl.y);
      const maxH = Math.max(heightA, heightB);
      const dstSize = new cv.Size(Math.max(320, Math.round(maxW)), Math.max(240, Math.round(maxH)));
      const srcTri = cv.matFromArray(4,1,cv.CV_32FC2, [tl.x,tl.y, tr.x,tr.y, br.x,br.y, bl.x,bl.y]);
      const dstTri = cv.matFromArray(4,1,cv.CV_32FC2, [0,0, dstSize.width,0, dstSize.width,dstSize.height, 0,dstSize.height]);
      const M = cv.getPerspectiveTransform(srcTri, dstTri);
      const dst = new cv.Mat(); cv.warpPerspective(mat, dst, M, dstSize);
      srcTri.delete(); dstTri.delete(); M.delete();
      rectifiedSize = { w: dstSize.width, h: dstSize.height };
      return dst;
    }

    function drawQuad(q) { if (!q) return; ctx.save(); ctx.clearRect(0,0,overlay.width, overlay.height); ctx.strokeStyle = 'rgba(76,201,240,0.9)'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(q[0].x,q[0].y); for (let i=1;i<q.length;i++) ctx.lineTo(q[i].x,q[i].y); ctx.closePath(); ctx.stroke(); ctx.restore(); }

    function thumb64Gray(mat) {
      // returns Uint8Array length 4096 (64*64)
      const dst = new cv.Mat(); const size = new cv.Size(64,64);
      cv.resize(mat, dst, size, 0,0, cv.INTER_AREA);
      const gray = new cv.Mat(); cv.cvtColor(dst, gray, cv.COLOR_RGBA2GRAY);
      const arr = new Uint8Array(64*64);
      const srcData = gray.data; arr.set(srcData);
      dst.delete(); gray.delete();
      return arr;
    }

    function diffPercent(a,b){
      let sum=0; for (let i=0;i<a.length;i++){ sum += Math.abs(a[i]-b[i]); }
      // max diff per pixel 255 -> normalize
      return (sum / (a.length*255)) * 100;
    }

    async function captureAndRectify() {
      if (!stream) return null;
      // draw current frame to an offscreen canvas
      const w = overlay.width, h = overlay.height;
      ctx.drawImage(video, 0,0, w,h);
      // to OpenCV mat
      const mat = cv.imread(overlay);
      let quad = boardQuad;
      if (!quad) {
        quad = findBoardQuad(mat);
      }
      let roi = null;
      if (quad) {
        roi = warpToBoard(mat, quad);
      } else {
        roi = mat.clone();
      }
      // Encode JPEG via canvas
      const can = document.createElement('canvas');
      can.width = roi.cols; can.height = roi.rows;
      cv.imshow(can, roi);
      const blob = await new Promise(res => can.toBlob(res, 'image/jpeg', 0.9));
      mat.delete(); roi.delete();
      return blob;
    }

    async function ensureLibs() {
      if (!cvReady) loadOpenCV();
      if (cbPerson.checked) await loadSegmentation();
    }

    async function runLoop() {
      await ensureLibs();
      const w = overlay.width, h = overlay.height;
      const capCanvas = document.createElement('canvas'); capCanvas.width=w; capCanvas.height=h; const capCtx = capCanvas.getContext('2d');

      const tick = async () => {
        animId = requestAnimationFrame(tick);
        if (!stream) return;
        // draw
        ctx.clearRect(0,0,w,h);
        // overlay updated by drawQuad later

        // every ~250ms run detection to save battery
        const now = performance.now();
        const doDetect = (now - lastQuadAt) > 250;
        if (doDetect && cv && cvReady) {
          capCtx.drawImage(video, 0,0,w,h);
          const mat = cv.imread(capCanvas);
          const found = findBoardQuad(mat);
          if (found) { boardQuad = found; lastQuadAt = now; kvBoard.textContent = 'ja'; } else { kvBoard.textContent = 'nein'; }
          drawQuad(boardQuad);

          // Person detection (optional)
          if (cbPerson.checked && segmenter) {
            try {
              const seg = await segmenter.segmentPeople(video, { multiSegmentation: false });
              // For simplicity count any person pixels proportion > 1.5%
              const any = seg && seg.length>0 && seg[0].mask;
              if (any) {
                const { width: mw, height: mh, data } = seg[0].mask;
                let cnt=0; for (let i=3;i<data.length;i+=4){ if (data[i]>128) cnt++; }
                const pct = (cnt / (mw*mh)) * 100;
                personPresent = pct > 1.5;
              } else {
                personPresent = false;
              }
            } catch(e) { console.warn('seg failed', e); }
          } else {
            personPresent = false;
          }
          statePerson.textContent = 'Person: ' + (personPresent? 'ja' : 'nein');
          statePerson.className = 'pill ' + (personPresent? 'warn' : 'ok');

          // Slide change detection (optional)
          let changed = false;
          if (cbSlide.checked) {
            let roi = null;
            if (boardQuad) roi = warpToBoard(mat, boardQuad); else roi = mat;
            const th = thumb64Gray(roi);
            if (lastSlideThumb) {
              const dp = diffPercent(th, lastSlideThumb);
              const thresh = parseFloat(slideThresh.value);
              const tnow = performance.now();
              if (dp > thresh) {
                if (tnow - slideStableSince > 800) { changed = true; }
              } else {
                slideStableSince = tnow;
              }
              stateSlide.textContent = 'Folie: ' + (dp>thresh ? `√Ñnderung (${dp.toFixed(1)}%)` : 'stabil');
              stateSlide.className = 'pill ' + (dp>thresh ? 'warn' : 'ok');
            } else {
              slideStableSince = performance.now();
            }
            lastSlideThumb = th;
            if (roi!==mat) roi.delete();
          }

          // Auto capture: only when slide changed AND no person visible
          if (changed && !personPresent) {
            const blob = await captureAndRectify();
            if (blob) await saveBlob(`tafel_${ts()}.jpg`, blob);
          }

          mat.delete();
        }

        // FPS meter
        frames++; if (now - lastFpsT > 1000) { pillFPS.textContent = `${frames} FPS`; frames = 0; lastFpsT = now; }
      };
      tick();
    }

    // Init
    cbPerson.addEventListener('change', () => { if (cbPerson.checked) loadSegmentation(); });

    // Permissions UI defaults
    permCam.textContent = 'Kamera: ?'; permCam.className='pill';
    permFS.textContent = 'Dateizugriff: ?'; permFS.className='pill';

    // Safety: check secure context
    if (!window.isSecureContext && location.hostname!=='localhost') {
      alert('Hinweis: Kamera funktioniert nur √ºber HTTPS oder http://localhost');
    }
  })();
  </script>
</body>
</html>
